<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git</title>
    <url>/2026/02/07/tools/git%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>git教程可以查看<a href="https://liaoxuefeng.com/books/git/time-travel/index.html">时光机穿梭 - Git教程 - 廖雪峰的官方网站</a></p>
<p>可谓是非常详细了。以下仅仅记录常用指令方便查找</p>
<p>注意，git在没输入git config –global（全局）或指定文件路径时，都是对当前目录的操作</p>
<h4 id="初始化和添加"><a href="#初始化和添加" class="headerlink" title="初始化和添加"></a>初始化和添加</h4><p>文件-（add）-track-（commit）-git保险柜</p>
<p>git init：在某一路径下，创建一个”保险柜“，用于存放保险柜的名字默认叫master，我已经通过</p>
<p>git config –global init.defaultBranch main将默认repo名改为main</p>
<p>git add 文件名(当前目录下)或文件路径 把目标文件放入track上面（未进repo）</p>
<p>git add.  添加所有</p>
<p>git commit -m “对文件的描述（随便写，但是必须有）”</p>
<h4 id="git管理"><a href="#git管理" class="headerlink" title="git管理"></a>git管理</h4><p>git status 查看当前文件夹下有哪些未进入track</p>
<p>git diff 查看差异</p>
<p>git log 查看git操作日志，git上面commit后面有很大一串怪字符，那是id</p>
<p>git show 某某id（git log里面的）</p>
<h4 id="git文件内容控制"><a href="#git文件内容控制" class="headerlink" title="git文件内容控制"></a>git文件内容控制</h4><p>git checkout id “filename” 把filename变为相关id版本</p>
<p>（完成 add commit会进入一次log操作，得到一个不同的id）</p>
<p>git reset –hard 版本回退到上个版本的已提交状态</p>
<p>git reset –soft  回退到上个版本的未提交状态</p>
<p>git reset –mixed  回退到上个版本已添加但未提交的状态</p>
<p>cs61b的ssh密匙在home</p>
<h4 id="github"><a href="#github" class="headerlink" title="github"></a>github</h4><p>git remote add skeleton <a href="https://github.com/Berkeley-CS61B/skeleton-sp18.git">https://github.com/Berkeley-CS61B/skeleton-sp18.git</a></p>
<p>添加了一个叫skeleton的库，这个库不会和我的冲突，多个可共存</p>
<p>git pull origin main –rebase拉取远程代码到本地并变基</p>
<p>git pull –rebase –allow-unrelated-histories skeleton master 导入了cs61b的初始代码</p>
<p>git push origin main本地推送到远端</p>
<p>如果是第一次建库，由于github上面有readme，比你电脑提交记录新，所以会拒绝，此时可git pull origin main –rebase 或者git push -f origin main强制推送</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>gpt规范回答</title>
    <url>/2026/02/07/tools/gpt/</url>
    <content><![CDATA[<h1 id="ChatGPT-回答风格规范（技术向）"><a href="#ChatGPT-回答风格规范（技术向）" class="headerlink" title="ChatGPT 回答风格规范（技术向）"></a>ChatGPT 回答风格规范（技术向）</h1><h2 id="一、总体原则"><a href="#一、总体原则" class="headerlink" title="一、总体原则"></a>一、总体原则</h2><p>以<strong>技术准确性与工程严谨性</strong>为最高优先级；若涉及不确定的知识、结论或工程应用前提，必须明确标注不确定性或适用条件。</p>
<p>回答风格偏向理工科 &#x2F; 计算机专业语境，避免口语化表达。</p>
<p>不进行无关寒暄，不使用表情符号，不做情绪化评价。<br>二、回答结构规范</p>
<hr>
<p>结论优先：<br>若问题存在明确答案或判断，先给出严谨结论；<br>再补充通俗解释（无需比喻）和必要的推导。</p>
<p>格式要求：<br>尽量少用 Markdown 结构符号；标题不强制加粗，列表可使用自然分段表达。<br>仅在以下情形使用 Markdown：</p>
<ul>
<li><p>极少量关键术语强调</p>
</li>
<li><p>代码必须使用代码块</p>
</li>
<li><p>数学符号可使用 LaTeX<br>不同观点或层次使用普通文本分段。</p>
</li>
</ul>
<p>层次清晰：<br>使用编号或自然标题；<br>一问一答，不发散。</p>
<p>信息密度优先：<br>避免空泛描述；<br>每一段都应承载实质信息。<br>三、内容深度要求</p>
<hr>
<p>技术问题默认采用偏底层 &#x2F; 原理级解释。</p>
<p>概念复杂度处理规则：</p>
<ul>
<li><p>若概念属于工科或计算机领域较复杂、难以直观理解，则直接严格按照原规范解释：严谨结论 → 通俗解释 → 代码示例 → 性质&#x2F;用途&#x2F;作用 → 工程影响 → 下钻层面 → 询问是否继续深入</p>
</li>
<li><p>若概念较简单，可用一段话和一个例子直接解释清楚，解释完询问用户是否需要完整严格解释；若用户要求，则严格执行上述完整流程</p>
</li>
</ul>
<p>介绍抽象概念时，遵循以下顺序：</p>
<ol>
<li><p>先给出严谨结论</p>
</li>
<li><p>给出通俗解释（无需比喻）</p>
</li>
<li><p>提供至少一个完整正确的代码示例；可根据概念特点拓展出其他示例，代码长度不限，正确性优先于简短</p>
</li>
<li><p>说明概念性质、用法、作用和必要性</p>
</li>
<li><p>讨论可能的工程层面影响或特性</p>
</li>
<li><p>结束后询问用户是否需要进一步下钻</p>
</li>
</ol>
<p>下钻按层次逐步推进：<br>运行期层面 → 编译期层面 → 体系结构 &#x2F; 机器层面。</p>
<p>必要时涉及：</p>
<ul>
<li><p>数据结构不变式</p>
</li>
<li><p>体系结构或标准定义</p>
</li>
</ul>
<p>不因“可能看不懂”而主动简化内容。<br>四、代码与示例规范</p>
<hr>
<p>代码优先确保正确，然后解释清楚；长度不限。<br>示例代码应：</p>
<ul>
<li><p>最小化但可覆盖概念核心</p>
</li>
<li><p>可根据抽象特性拓展出其他示例</p>
</li>
<li><p>若为对比说明，明确指出差异与结论</p>
</li>
</ul>
<h2 id="五、题型特殊约定"><a href="#五、题型特殊约定" class="headerlink" title="五、题型特殊约定"></a>五、题型特殊约定</h2><p>选择题：直接给出答案，不提供解析。</p>
<p>概念性提问：给出严格定义，必要时提供反例。</p>
<p>是 &#x2F; 否问题：先明确回答“是”或“否”，再说明成立条件或例外。<br>六、语言与术语</p>
<hr>
<p>中文为主；关键术语在首次出现时保留英文原名。<br>不进行中英混写式解释性废话。<br>统一使用学术界或工程实践中通行的术语与表述。<br>七、不应出现的内容</p>
<hr>
<p>无前提支撑的不确定性模糊表述（如“可能”“大概”“一般来说”）。<br>与问题无关的类比、故事性描述或泛泛而谈。<br>重复用户已明确掌握的基础知识。<br>八、优先级说明</p>
<hr>
<p>本规范在本对话及后续对话中：<br>高于默认回答风格；<br>低于用户在单次提问中明确指定的特殊要求。</p>
<p>—— 本文档可随时增补或修订 ——</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>gdb初步</title>
    <url>/2026/02/07/tools/gdb%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><p>常见命令</p>
<p>gcc  draft.c  -o draft</p>
<p>把draft.c源文件编译,输出成draft</p>
<p>注意-o后面必须紧跟draft文件名，其他位置没有讲究。</p>
<p>gcc draft.c -g -o draft,生成调试信息，gdb要用</p>
<p>只要-o后面紧跟draft文件名，</p>
<p>gcc -g -o myprog main.c<br>gcc -o myprog -g main.c<br>gcc main.c -g -o myprog都是合法的</p>
<h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><p>用上面的-g命令编译下，</p>
<p>gdb .&#x2F;draft 启动</p>
<p>gdb r&#x2F;gdb run开始程序</p>
<p>gdb b 数字 在某一行加上断点</p>
<p>gdb b 函数名在函数处加上断点</p>
<p>遇到断点后 gdb l查看断点处10行代码</p>
<p>没遇到断点就是从开头依次输出10行代码</p>
<p>gdb l x,y查看x到y处代码</p>
<p>gdb g 变量名查看变量值</p>
<p>gbd x&#x2F;s 变量名 输出字符串变量 gdb x&#x2F;c 变量名 输出字符变量</p>
<p>gdb bt 查看调用的栈帧（backtrace）</p>
<p>gdb i b查看所有断点</p>
<p>gdb delete 1删除断点1 </p>
<p>gdb delete 删除所有断点</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>markdown常见语法</title>
    <url>/2026/02/07/tools/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>&gt; 表示单行引用</p>
<p>&gt;&gt;表示引用的嵌套</p>
<p>效果:</p>
<blockquote>
<p>知行合一</p>
</blockquote>
<h3 id="标题字号"><a href="#标题字号" class="headerlink" title="标题字号"></a>标题字号</h3><p>字符 # + 空格+要输入的字符+回车来表示<br>或者选中，shift+1-6直接转换</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h6 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h6><blockquote>
<p>1.+space</p>
</blockquote>
<h6 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h6><blockquote>
<p>*+space:</p>
</blockquote>
<blockquote>
<p>+或者是-都可以</p>
</blockquote>
<p>HTML语法，段落中显示&bull; :&amp;bull;</p>
<blockquote>
<p>&amp;bull;</p>
</blockquote>
<h6 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h6><blockquote>
<p>- [ ] </p>
</blockquote>
<p>表示任务列表 ,出现&bull; []的情况，可以在[]后加一个空格</p>
<h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><h6 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h6><blockquote>
<p>`&#96;&#96;</p>
</blockquote>
<p>`&#96;&#96;开始，`&#96;&#96;结束（会自动有`&#96;&#96;),下面可以选择语言</p>
<h6 id="长水平分割线"><a href="#长水平分割线" class="headerlink" title="长水平分割线"></a>长水平分割线</h6><blockquote>
<p>-–</p>
<p>***</p>
</blockquote>
<p>— + 回车，或者*** + 回车</p>
<h6 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h6><blockquote>
<p>[^1]</p>
</blockquote>
<p>最末尾[^1]:脚注内容或网址</p>
<h6 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h6><blockquote>
<p> !<a href=""></a> </p>
</blockquote>
<p>括号里面写入网页地址或者本地地址，本地地址记得去引号</p>
<p>注意，本地的话，把文件的相对地址写到_post文件夹下，网站写到.index.html下</p>
<p>.&#x2F;image&#x2F;picture.png</p>
<h6 id="目录索引"><a href="#目录索引" class="headerlink" title="目录索引"></a>目录索引</h6><p>[TOC]放在开头，自动根据标题分索引</p>
<h4 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h4><h6 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h6><blockquote>
<p>$+ESC</p>
</blockquote>
<p>出现$$,在这两个美元符号之间输入LaTex语法，即可实现在行内插入公式。</p>
<blockquote>
<p>$$ + 回车</p>
</blockquote>
<p>行间插入公式</p>
<h6 id="字符表"><a href="#字符表" class="headerlink" title="字符表"></a>字符表</h6><p><img src="/./image/%E5%B8%8C%E8%85%8A%E5%AD%97%E7%AC%A6markdown.png"></p>
<p><img src="/./image/%E5%85%AC%E5%BC%8F1.png"></p>
<p><img src="/./image/%E7%95%8C%E5%AE%9A%E7%AC%A6.png"></p>
<p>上述定界符与<code>\left</code>和<code>right</code>组合使用可以使得定界符匹配其内容的高度。比如矩阵</p>
<p>\left|\begin{matrix}    a &amp; b &amp; c \    d &amp; e &amp; f \    g &amp; h &amp; i   \end{matrix} \right|</p>
<p><img src="/./image/%E5%85%AC%E5%BC%8F2.png"></p>
<p><img src="/./image/%E5%85%AC%E5%BC%8F3.png"></p>
<p><img src="/./image/%E5%85%AC%E5%BC%8F4.png"></p>
<p><img src="/./image/%E5%85%AC%E5%BC%8F5.png"></p>
<h6 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h6><blockquote>
<p> 使用<code>^</code>来输出上标，使用<code>_</code>来输出下标，使用<code>{}</code>包含作用范围。</p>
</blockquote>
<p> \sum_{n&#x3D;1}^\infty k  $\sum_{n&#x3D;1}^\infty k $</p>
<p>$$<br>\sum_{n&#x3D;1}^\infty k<br>$$</p>
<blockquote>
<p>矩阵中的各元素通过用<code>$</code>来分隔，<code>\\</code>来换行。</p>
</blockquote>
<p>\begin{vmatrix} 0&amp;1&amp;2\ 3&amp;4&amp;5\ 6&amp;7&amp;8\ \end{vmatrix}</p>
<blockquote>
<p>用<code>\begin{cases}</code>和<code>\end{cases}</code>来构造分段函数，中间则用<code>\\</code>来分段:</p>
</blockquote>
<p>f(x) &#x3D;  \begin{cases} 2x,,,x&gt;0\ 3x,,,x\le0\ \end{cases}</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu指令</title>
    <url>/2026/02/07/tools/ubuntu%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>终端实际上配置有一系列应用程序，储存在文件管理系统里面，输入指令将调取这些程序。<br>通过环境变量搜索程序<br>shell实际上可以是一种编程语言，循环那些都可以实现</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>ctrl+c 退出当前进程<br>ctrl 清空，回到顶部<br>sudo 超级用户（慎用，除非必要）<br>sudo su(下面的提示符从$变为#，即默认从user变为root）<br>exit退出root<br>.+文件名代表隐藏文件</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>  &lt; 重定向键盘输入为文件输入</p>
<p>&gt;重定向标准输出到文件</p>
<p>文件将被覆盖</p>
<p>&gt;&gt;重定向便准输出到文件，但不覆盖，而是追加</p>
<p>2&gt;输入错误到某文件</p>
<p>.&#x2F;draft &lt; draft.in &gt;draft.out 2&gt;error.log</p>
<p>但是注意输出错误日志可能会占用一定cpu从而影响正常程序运行</p>
<h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>echo表示打印文本</p>
<p>echo hello<br>echo $PATH,显示以冒号为分割的路径变量<br>echo ​$HOME（环境变量）,–&#x2F;home&#x2F;hardestnut<br>我输入date，会在这些路径下查找是否有相关的程序</p>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>寻找可执行文件，找不到文件夹</p>
<p>which .ssh没反应  which ssh显示路径</p>
<p>which echo–&#x2F;usr&#x2F;bin&#x2F;echo</p>
<p>或者 find ~ -name “ssh”</p>
<p>顺便说一句，文件名都以&#x2F;开头</p>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前路径–&#x2F;home&#x2F;hardestnut</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd 改变到目标路径<br>cd 默认到主目录<br>cd -回到上一次目录（两者之间来回）<br>cd  &#x2F;home<br>cd &#x2F;回到根目录&#x2F;<br>(值得注意的是，开头的&#x2F;指的是根目录，&#x2F;bin对，&#x2F;local错，&#x2F;usr&#x2F;local对，因为&#x2F;下没有local目录<br>cd ..回到上一个路径<br>cd ..&#x2F;other_directory：切换到当前目录的上一级目录中的other_directory。<br>cd ~ 带到主目录（home&#x2F;username）可作为相对路径</p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls ~\目标文件 </p>
<p>ls：显示当前路径下的文件<br>ls .. 上一级文件目录<br>(Usage: ls [OPTION]… [FILE]…   这里面…表示0，1或多个选项<br>ls –help<br>ls -l  +文件夹名显示详细信息</p>
<h5 id="ls展示信息解读"><a href="#ls展示信息解读" class="headerlink" title="ls展示信息解读"></a>ls展示信息解读</h5><p>lrwxrwxrwx   1 root root       7 Nov 23  2023 bin -&gt; usr&#x2F;bin<br>l表示这是一个符号链接,类似于快捷方式，指向另一个文件或目录。（d表示目录</p>
<p>rwxrwxrwx 表示所有用户（所有者、用户组、其他用户）都有读、写、执行权限。（r-x表示缺少w）</p>
<p>1：表示硬链接的数量。对于符号链接，通常这个数字是 1。对于目录来说，硬链接数表示该目录下有多少个子目录（包括 . 和 ..）</p>
<p>ls -a  显示所有文件，包括以 . 开头的隐藏文件。<br>ls -lh  显示人类可读的文件大小<br>ls -R  递归列出所有子目录的内容。<br>ls -lt  按文件的修改时间排序，最近修改的文件排在最前面。<br>ls -lS  按文件的大小排序，最大文件排在最前面。<br>ls -F  在文件名后添加标识符，表示文件类型。&#x2F; 表示目录，* 表示可执行文件。<br>ls -color 不同类型染色<br>ls -1竖着排版，看起来舒服点<br>多个选项可以一起使用，通常没有问题。ls -lat</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv 功能1：移动文件路径 功能2：重命名文件<br>mv filename(如果只有一个) 目标路径<br>mv 路径（多个，精确） 目标路径<br>mv filename*（通配符）（多个） 目标路径(将把全部文件都移过去）</p>
<p>重命名：mv 旧名字 新名字</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp 复制文件<br>cp filename 新路径  或 旧路经 新路径</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>递归删除即指删除当前文件夹及其所有子文件夹</p>
<p>rm删除（通常不是递归删除，即删除以上的所有目录）<br>rm 文件名&#x2F;路径（rm默认删除文件<br>rm -r filename&#x2F;path(递归删除所有空）</p>
<p>sudo rm -rf …强制删除（谨慎！！！！</p>
<p>rmdir 文件名&#x2F;路径（允许你在目录为空的时候删除一个目录）</p>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir创造目录 “name”</p>
<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>man+另一个程序名，将提供该程序的手册<br>man ls(ls的使用）man echo</p>
<h4 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向&lt; &gt;"></a>重定向&lt; &gt;</h4><p>echo +&gt;输入重定向：echo “hello”&gt;hello.txt(覆盖或创建）<br>echo “hello”&gt;&gt;hello.txt(末尾追加或者创建）<br>cat &lt;hello.txt输出内容<br>cat &lt;hello.txt &gt;hello2.txt 相当于把第一个文件内容复制给第二个</p>
<p>|  ： 命令1|命令2<br>把左边命令的输出内容作为右边命令的输入内容<br>ls -a|tail -n2(表示输出最后两行内容)</p>
<p>查找文件：find 路径1 路径2… -name “文件名”2&gt;&#x2F;dev&#x2F;null<br>后面的2&gt;&#x2F;dev&#x2F;null表示不输出无关的，否则在大路径下查找可能会输出一坨。2(标准错误输出)&gt;&#x2F;dev&#x2F;null(文件黑洞，相当于垃圾桶)&#x2F;dev(设备文件,这些文件是与硬件设备或虚拟设备交互的接口)<br>&#x2F;null虚拟设备</p>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file+文件名 判断文件类型</p>
<p>如file draft3</p>
<p>输出：draft3: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, BuildID[sha1]&#x3D;320cbb94642d466c28181ba5732e78d0b22fa1cd, for GNU&#x2F;Linux 3.2.0, not stripped</p>
<p>分别表示64位可执行文件（linux的ELF表示可执行文件） 处理器架构 版本，动态链接依赖，动态链接器路径，哈希标识，保留调试信号（-g）</p>
<p>又如file draft3.c,输出draft3.c: C source, Unicode text, UTF-8 text, with CRLF line terminators。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ctrl+tab切换标签页</p>
<p>按上箭头和下箭头能查阅历史命令</p>
<p>在命令输入一半按tab会显示所有可能的完整命令</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>hexo详解</title>
    <url>/2026/02/07/tools/hexo%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="hexo是什么"><a href="#hexo是什么" class="headerlink" title="hexo是什么"></a>hexo是什么</h3><p>hexo是基于node.js的静态站点生成器</p>
<p>能够将含有结构化元数据的文本（通常使用markdown）在构建期转换为纯静态的HTML&#x2F;CSS&#x2F;JS文件，并部署到静态托管环境</p>
<p>（通俗来讲就是：把一堆markdown当成源码编译成网站）</p>
<h3 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h3><p>1.<strong>hexo init</strong></p>
<p>在某个目录下初始化，生成一个新的 Hexo 站点。</p>
<p>生成标准目录结构（_config.yml、package.json、scaffolds、source、themes 等），并自动安装依赖。 </p>
<p>等价于“创建项目骨架”，只需执行一次。</p>
<p>2.<strong>hexo new</strong> [layout] <title></p>
<p>layout是post时，titile应为文章名，作用是在soutce&#x2F;_post下创建新文件title</p>
<p>layout是page时，title应为索引头类型，比如about，categories，tag，对应网站上home同级别的索引头</p>
<p>对应source下的文件夹about，categories等。</p>
<p>3.<strong>hexo clean</strong></p>
<p>清理生成缓存和静态文件（删除 public&#x2F; 和缓存目录）。</p>
<p>4.<strong>hexo generate (hexo g)</strong></p>
<p>将 Markdown 源文件编译为静态 HTML 文件,输出到public&#x2F; ，构建产物生成</p>
<p>5.<strong>hexo server (hexo s)</strong></p>
<p>启动本地 HTTP 服务预览站点。</p>
<p>在本地用网站<a href="http://localhost:4000浏览">http://localhost:4000浏览</a></p>
<p>可以用<strong>hexo s -g</strong>,即先生成再启动服务。</p>
<p>hexo s相当于本地调试服务器，不涉及真实部署。</p>
<h3 id="hexo构架"><a href="#hexo构架" class="headerlink" title="hexo构架"></a>hexo构架</h3><h3 id="hexo创建新索引头"><a href="#hexo创建新索引头" class="headerlink" title="hexo创建新索引头"></a>hexo创建新索引头</h3>]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>vim常见用法</title>
    <url>/2026/02/07/tools/vim%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>某一路径下，按ls查看所有文件，有一文件filename，vim+”filename”进入vim</p>
<h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><p>vim按esc进入普通模式，这个模式下可以进行dd，u等操作：</p>
<hr>
<h5 id="1-删除操作"><a href="#1-删除操作" class="headerlink" title="1.删除操作"></a>1.删除操作</h5><h6 id="a-删除整行"><a href="#a-删除整行" class="headerlink" title="a.删除整行"></a>a.删除整行</h6><p>dd   删除光标下1行</p>
<p>5dd 删除光标下5行</p>
<p>D     从当前位置删除到行尾</p>
<h6 id="b-d-移动位置"><a href="#b-d-移动位置" class="headerlink" title="b.d+移动位置"></a>b.d+移动位置</h6><p>dgg   删除到文件开头（gg会直接到开头)</p>
<p>dG    删除到文件末尾 (caps+g也就是G会直接到末尾，shift+g也可以)</p>
<p>ggdG删除全文 就是先去开头，再删除到末尾</p>
<p>de     删除当前位置到当前单词完（e是到达当前单词末尾）</p>
<p>diw   删除当前单词</p>
<p>di”    删除下一个个””里面的内容</p>
<p>di{    删除下一个{}里面的内容</p>
<h6 id="c-删除直到指定字符"><a href="#c-删除直到指定字符" class="headerlink" title="c.删除直到指定字符"></a>c.删除直到指定字符</h6><p>dt +单个字符，删除到字符处，字符不删</p>
<p>尽在本行生效</p>
<hr>
<h5 id="2-撤销"><a href="#2-撤销" class="headerlink" title="2.撤销"></a>2.撤销</h5><p>u  撤销</p>
<p>ctrl+r 重做撤销操作</p>
<hr>
<h5 id="3-选中文本"><a href="#3-选中文本" class="headerlink" title="3.选中文本"></a>3.选中文本</h5><p>先把光标调整到开始选中的位置，在普通模式下按</p>
<p>v    从光标当前位置开始，光标所经过的地方会被选中，再按一下v结束。   </p>
<p>V    从光标当前行开始，光标经过的行都会被选中，再按一下Ｖ结束。   </p>
<p>ggVG  选中全部的文本。</p>
<hr>
<h5 id="4-复制"><a href="#4-复制" class="headerlink" title="4.复制"></a>4.复制</h5><h6 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h6><p>1.Vim 通过“<strong>寄存器</strong>”机制实现剪切板操作。寄存器是 Vim 内部用来存储文本的结构，可以用于复制剪切粘贴</p>
<p>按:reg 查看寄存器内容</p>
<p><img src="file:///C:/Users/hardestnut/Pictures/Typedown/70b8b7a0-7e02-4c89-a256-f16cd8bf0c8d.png" alt="70b8b7a0-7e02-4c89-a256-f16cd8bf0c8d"></p>
<p>“ 默认寄存器，ctrl+shift+c 储存到这</p>
<p>0 上次复制（yank）的内容</p>
<p>1-9 删除操作历史</p>
<p>+ 系统剪切板</p>
<h6 id="部分指令"><a href="#部分指令" class="headerlink" title="部分指令"></a>部分指令</h6><p>y&#x2F;ctrl +shift+c 储存到默认寄存器，只能ubuntu内部使用</p>
<p>“+y 储存到系统剪切板（需开启），全局使用。</p>
<p>似乎开启后第一个指令也能在全局使用？？</p>
<hr>
<h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><p>1.到行尾：A，顺带进入insert模式</p>
<p> 或者$进入行尾</p>
<p>2.到指定行</p>
<p> 50G 到50行</p>
<p>3.+数字，当前行数向下</p>
<p>4.组合使用</p>
<table>
<thead>
<tr>
<th><code>:[行号]s/old/new</code></th>
<th>在指定行替换文本</th>
</tr>
</thead>
<tbody><tr>
<td><code>:[行号]d</code></td>
<td>删除指定行</td>
</tr>
<tr>
<td><code>:[行号1],[行号2]d</code></td>
<td>删除行号范围内的内容</td>
</tr>
</tbody></table>
<p>5.特殊命令 </p>
<p>‘’两次’跳转到最后修改</p>
<p>‘.跳转到最后修改</p>
<hr>
<h4 id="插入模式："><a href="#插入模式：" class="headerlink" title="插入模式："></a>插入模式：</h4><p>i&#x2F;a&#x2F;o：插入模式，i光标前插入（当前光标），a光标后插入（没鸟用），o下方插入新行</p>
<p>光标移动：箭头或jkhl，上下左右<br>gg 文件开头，G 文件末尾 :n第n行<br>w下个单词开头，b上个单词开头，%匹配括号跳转</p>
<p>复制：<br>yy复制当行<br>yw复制一个单词<br>yG复制光标到结尾</p>
<p>删除：<br>x：删除光标所在字符。<br>dd：删除当前行。<br>dG：删除光标到文件末尾的所有内容</p>
<p>粘贴p</p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>另外在普通模式下按 : 进入命令模式，这个模式下可以执行保存退出等操作</p>
<hr>
<h5 id="1-打开内置终端"><a href="#1-打开内置终端" class="headerlink" title="1.打开内置终端"></a>1.打开内置终端</h5><h6 id="打开不同位置终端"><a href="#打开不同位置终端" class="headerlink" title="打开不同位置终端"></a>打开不同位置终端</h6><p>:terminal 或者:term 在上面打开一个终端</p>
<p>:rightbelow vert term在右边打开终端</p>
<p>在终端里面输入exit关闭终端</p>
<h6 id="设置终端大小"><a href="#设置终端大小" class="headerlink" title="设置终端大小"></a>设置终端大小</h6><p>有时候会发现vim的位置太窄不舒服，在vim里面输入：</p>
<p>:vertical resize 50(将当前窗口宽度设置为 50 个字符宽度)</p>
<p>ctrl+w+-或者ctrl+w++字体大小调整</p>
<h6 id="终端复制"><a href="#终端复制" class="headerlink" title="终端复制"></a>终端复制</h6><p>按ctrl \ ctrl n进入普通模式，此时按V进入可视模式或者鼠标直接复制都可以</p>
<h6 id="退出普通终端"><a href="#退出普通终端" class="headerlink" title="退出普通终端"></a>退出普通终端</h6><p>交互模式-&gt;ctrl \ ctrl n-&gt;普通模式-&gt; i -&gt; 交互模式</p>
<h6 id="终端切换"><a href="#终端切换" class="headerlink" title="终端切换"></a>终端切换</h6><p>鼠标点击vim后无法选中term?</p>
<p>同时按住ctrl w，不要放，按hjkl切换窗口</p>
<p>比如我喜欢用:rightbelow vert terminal ，进入vim后同时按ctrl w l就可以进入term</p>
<hr>
<h5 id="2-保存退出"><a href="#2-保存退出" class="headerlink" title="2.保存退出"></a>2.保存退出</h5><p>:q！强制退出，:wq保存并退出  :q退出</p>
<hr>
<h5 id="3-文本替换"><a href="#3-文本替换" class="headerlink" title="3.文本替换"></a>3.文本替换</h5><p>:s&#x2F;old&#x2F;new&#x2F;：替换当前行第一个匹配项。</p>
<p>:s&#x2F;old&#x2F;new&#x2F;g：替换当前行所有匹配项。</p>
<p>:%s&#x2F;old&#x2F;new&#x2F;g：替换全文所有匹配项。</p>
<p>:&lt;start&gt;,&lt;end&gt;s&#x2F;old&#x2F;new&#x2F;g：替换某几行</p>
<p>这里%代表全文</p>
<hr>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>安装的vundle管理器，后面的插件加入到Plugin：后面，然后到vim里面输入:PluginInstall。不同插件具体配置看博客或官方文档</p>
<h5 id="nerdtree"><a href="#nerdtree" class="headerlink" title="nerdtree"></a>nerdtree</h5><p>打开:NERDTree 关闭:NERDTreeClose</p>
<p>切换文件树（开&#x2F;关）:NERDTreeToggle</p>
<p>.&#x2F;vimrc里面配置了快捷键，可按F3开关(:NERDTreeToggle)</p>
<p>k&#x2F;j上下移动，按enter进入文件</p>
<p>u进入上级目录</p>
<p>C将当前目录作为工作目录</p>
<p>m打开菜单 a添加文件</p>
<hr>
<h5 id="syntastic"><a href="#syntastic" class="headerlink" title="syntastic"></a>syntastic</h5><p>安装了语法检查器syntastic,:w保存后自动检查语法错误并标亮</p>
<p>按:Error输出错误原因 </p>
<p>:q退出错误框</p>
<p>:SyntasticToggleMod 切换开&#x2F;关</p>
<p>比如你写伪代码按：w就会很多错，可以输入这个关闭</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>DAG</title>
    <url>/2026/02/05/algorithm/1.dp/DAG-dp/</url>
    <content><![CDATA[<p>什么是DAG，即有向无环图，有些</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>cpp进阶初步</title>
    <url>/2026/02/07/algorithm/3.stl/1.cpp%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-class语法"><a href="#1-class语法" class="headerlink" title="1.class语法"></a>1.class语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">()</span></span>&#123;<span class="comment">/**/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Name::func2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>public 可被其他程序使用，private只能被当前类的函数使用，protected只能被当前类的函数，和继承类使用.</p>
<p>我们常把数据设置为私有的或保护的，需要数据时调用public的函数获得数据即可，就不需要暴露数据的来去,例如getB</p>
<h6 id="类函数"><a href="#类函数" class="headerlink" title="类函数"></a>类函数</h6><p>1.函数写法</p>
<p> 内联：函数实现直接写在class里面,比如func3</p>
<p>外联：函数定义在class内，实现在class外，比如func2(注意语法ClassName::func2)</p>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><p>1.默认构造函数 ClassName(){}</p>
<p>若无任何构造函数会自动生成默认构造函数，当自定义了构造函数将不会生成默认构造函数。</p>
<p>注意构造函数不会对POD类型（c原有的类型，int…）进行初始化</p>
<p>2.初始化列表（就是构造函数的简写方式）</p>
<p>int a;double b;</p>
<p>ClassName():a(0),b(114.514){}</p>
<p>3.单参数的构造函数最最最好加上explicit（能避免隐式转换）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">MyClass</span>(<span class="type">int</span> a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass class1=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面那个构造是正确的，因为有隐式转换：编译器看到10（int）赋值给class1（MyClass类）会寻找转换方式，即从int到MyClass的构造函数，从而发生以下</p>
<p>int num&#x3D;10;</p>
<p>MyClass temp(10);</p>
<p>MyClass class1&#x3D;temp;</p>
<h6 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h6><p>只检测，不改变对象为访问函数，如isEmpty()</p>
<p>改变对象为修改函数，如makeEmpty()</p>
<p>所有函数默认为修改函数，要使函数为访问函数需要用const :</p>
<p>void makeEmpty( ) const { }</p>
<p>一个函数为常量成员函数，那么他只能使用其他的const函数，只能修改mutable变量</p>
<h6 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h6><p>IntCell obj1 √，默认构造</p>
<p>IntCell obj1(1) √，int参数构造</p>
<p>IntCell obj2&#x3D;1×(若是构造函数用Explicit修饰是错的，若没用他修饰，则是对的！默认转换)</p>
<p>IntCell obj2()×会误以为是函数声明，返回值是IntCell</p>
<p>甚至可以用指针</p>
<p>IntCell *m;</p>
<p>m&#x3D;new IntCell(0);</p>
<p>m-&gt;write(5);</p>
<p>delete m;</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>图储存</title>
    <url>/2026/02/07/algorithm/2.%E5%9B%BE/%E5%9B%BE%E5%82%A8%E5%AD%98/</url>
    <content><![CDATA[<p>对于图的储存而言，算法上一般用邻接表和邻接矩阵两种方法</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在 𝑢<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="u"> 到 𝑣<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="v"> 的边，为 0 表示不存在．如果是带边权的图，可以在 <code>adj[u][v]</code> 中存<img src="C:\Users\mec\Pictures\算法图解\链式前向星.png" alt="链式前向星">储 𝑢<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="u"> 到 𝑣<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="v"> 的边的边权．<br>    &#x2F;&#x2F;u-&gt;v<br>    adj[u][v]&#x3D;1;</p>
<p>注意不能有重边，优点是查某边很快，缺点是稀疏图效率低</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>一般情况下，都用邻接表方法储存图</p>
<p>实现方法有很多，有vector，指针 链表（理论），链式前向星（数组+链式索引），我们采用链式索引</p>
<p>定义head[a]储存a指向的边的信息</p>
<p>e[i]为索引i所对应的点</p>
<p>ne[i]为索引i的下一个索引</p>
<p>idx为目前储存的边数</p>
<p>我们储存a-&gt;b,a-&gt;c两条边如图所示</p>
<p>先储存a-&gt;c,分配idx2&#x3D;1，然后e[idx2]代表a指向的c</p>
<p>后面插入a-&gt;b,分配idx1&#x3D;2，然后e[idx1]&#x3D;b代表a-&gt;b,然后让ne[idx1]&#x3D;head[a]即idx2。两个边就建好了</p>
<p><img src="C:\Users\mec\Pictures\算法图解\链式前向星.png" alt="链式前向星"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n=x<span class="number">+10</span>,m=<span class="number">2</span>*y<span class="number">+10</span>;</span><br><span class="line"><span class="comment">//我们假设有x个节点，y条无向边（一般题目会给）</span></span><br><span class="line"><span class="comment">//2*y表明无向边可以看成两条特殊的有向边</span></span><br><span class="line"><span class="type">int</span> h[n],e[m],ne[m],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">     e[idx]=b;ne[idx]=h[a];h[a]=idx;idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>h[i]表示第i个节点的头节点，后面接入i节点指向的所有节点的idx索引，无顺序之分。e[idx]表示第idx个空间分配的值，ne[idx]表示第idx个空间的值所指向的的下一个值的索引。idx从零开始递增。 整体而言可以把e[]看作一个内存池，从这个内存池里面取出边，一个一个赋值，接在h[]后面</p>
<p>add函数是把e的第idx位置存成b，ne[idx]&#x3D;h[a]表示把原来h[a]指向的索引成为ne的下一个索引，在让h[a]指向idx，idx自增，即可完成插入</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>图</category>
      </categories>
  </entry>
  <entry>
    <title>参数传递</title>
    <url>/2026/02/07/algorithm/3.stl/3.%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>一般来说，c++常见几种参数传递</p>
<p>1.一般值（int ，double，对象）</p>
<p>2.引址调用 int &amp;</p>
<p>3.常数引用调用const int &amp;</p>
<p>4.（cpp里面少用)裸指针</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>线性dp</title>
    <url>/2026/02/05/algorithm/1.dp/%E7%BA%BF%E6%80%A7dp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>vector和string</title>
    <url>/2026/02/07/algorithm/3.stl/2.vector%E5%92%8Cstring/</url>
    <content><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>#include&lt;vector&gt;</p>
<p><code>vector</code> 的数据储存在堆空间中，不会爆栈。一般情况 <code>vector</code> 可以替换掉普通数组。</p>
<p>注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销</p>
<h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>vector&lt;类型&gt; arr(长度，[初值])</p>
<p>括号及里面的内容可省，默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr; <span class="comment">// 构造int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 构造初始长100的int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ()); <span class="comment">// 构造初始100行，不指定列数的二维数组 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">200</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始200列的二维数组，初值为-1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>],没初始化的二维数组，有<span class="number">100</span>个元素，每一个arr[i]都是一个vector，相当行数不变，列数不定的二维数组</span><br><span class="line">arr[i].push_back;</span><br></pre></td></tr></table></figure>



<p>注意，vector创建完后，可以当作普通数组用，如</p>
<p>vector&lt;int&gt; arr(100) 创建100个长度的可变长数组–&gt;arr[0]&#x3D;1;</p>
<h5 id="尾增尾删push-back-pop-back"><a href="#尾增尾删push-back-pop-back" class="headerlink" title="尾增尾删push_back(),pop_back()"></a>尾增尾删push_back(),pop_back()</h5><ul>
<li><strong><code>.push_back(元素)</code></strong>：在 vector 的最后一个内存后增加一格内存，并给这个内存赋值，数组长度+1(!)</li>
<li><strong><code>.pop_back()</code></strong>：删除 vector 的最后一格内存及其元素，数组长度-1</li>
</ul>
<p>arr.push_back(100);</p>
<p>arr.pop_back();</p>
<p>arr&#x3D;{0,0,0,0},arr.push_back(9)–&gt;arr&#x3D;{0,0,0,0,9}</p>
<h5 id="获取长度-size"><a href="#获取长度-size" class="headerlink" title="获取长度.size()"></a>获取长度.size()</h5><p>获取当前 vector 的长度</p>
<p>注意返回值是无符号整数size_t</p>
<p>o(1)复杂度</p>
<h5 id="清空-clear"><a href="#清空-clear" class="headerlink" title="清空.clear()"></a>清空.clear()</h5><p>arr.clear();</p>
<p>o(n)复杂度</p>
<h5 id="判空-empty"><a href="#判空-empty" class="headerlink" title="判空 .empty()"></a>判空 .empty()</h5><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p>
<p>时间复杂度：o(1)</p>
<h5 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h5><p><strong><code>.resize(新长度, [默认值])</code></strong></p>
<p>修改 vector 的长度</p>
<p>如果是缩短，则删除多余的值</p>
<p>如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变）</p>
<p>时间复杂度：o(n)</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>std::string是cpp的一种类，可以存储任意长度的文本内容，长度可以动态改变。可以通过下标访问字符，或者使用成员函数修改字符串内容，而不必手动管理内存。</p>
<p>声明：std::string str;</p>
<p>初始化：std::string s&#x3D;”hello world”</p>
<p>可通过+增加字符std::string s &#x3D; “Hello”;s +&#x3D; “ World”;</p>
<h6 id="1-访问元素"><a href="#1-访问元素" class="headerlink" title="1.访问元素"></a>1.访问元素</h6><p>可以通过s[i]或者s.at(i),</p>
<p>两者都可以修改原string串内容</p>
<p>s[i]无越界检查，但更高效，s.at(i)会检查越界</p>
<h6 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法."></a>2.方法.</h6><p>数组长度 s.length()或者s.size()</p>
<p>是否为空 s.empty()</p>
<p>追加字符 s.append()</p>
<p>插入 s.insert(pos,str)</p>
<p>删除 s.erase(pos,len)</p>
<p>清空 s.clear()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    s += <span class="string">&quot; World&quot;</span>;      <span class="comment">// 动态扩展</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;,&quot;</span>);  <span class="comment">// 在指定位置插入字符</span></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl; <span class="comment">// 输出: Hello, World</span></span><br><span class="line">    std::cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; std::endl; <span class="comment">// 随机访问字符: H</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>重载运算符</title>
    <url>/2026/02/07/algorithm/3.stl/5.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p><strong>operator</strong>是C++的一个关键字，它和运算符（如“&#x3D;”）一起使用，表示一个<strong>运算符重载函数</strong>，在理解时可将operator和待重载的运算符整体（如“operator&#x3D;”）视为一个函数名。</p>
<p>实现运算符重载的方式通常有以下两种：</p>
<p>1.运算符重载实现为类的成员函数；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在student类里面</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> student&amp; a)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.score&gt;a.score)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运算符重载实现为非类的成员函数（即全局函数）。</p>
<p>两个参数分别为左右操作数（至少一个是自定义类，可以只有一个或者另一个是int等）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> student &amp;a,<span class="type">const</span> student &amp;b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score&gt;b.score)&#123;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>不能违反运算符原来的语法规则；</p>
<p>不能创建新的运算符；</p>
<p>有一些运算符是不能重载的，如“sizeof”；</p>
<ul>
<li>&#x3D;、()、[]、-&gt;操作符只能被类的成员函数重载。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2026/02/07/algorithm/3.stl/6.%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="迭代器是什么？"><a href="#迭代器是什么？" class="headerlink" title="迭代器是什么？"></a>迭代器是什么？</h3><p>通俗来讲，迭代器用来指明stl容器位置</p>
<p>我们创建一个迭代器，实际上是创建了迭代器类的一个对象，实现了类似指针的操作。所以他的本质不是指针，但很像指针</p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    cout&lt;&lt;v[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator  i=v.<span class="built_in">begin</span>();i!=v.<span class="built_in">end</span>();++i)</span><br></pre></td></tr></table></figure>

<p>begin()指向第一项,end()指向<strong>最后一项的后一项</strong></p>
<h3 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h3><ol>
<li></li>
</ol>
<p>itr++，++itr：迭代器进入下一个位置</p>
<p><strong>注意！itr++实际上是重载运算符，他会返回一个对象！例如i++就是返回老的i，然后i本身封装的指针值++（类似指针移动）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后缀 it++</span></span><br><span class="line">    Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        Iterator tmp = *<span class="keyword">this</span>; <span class="comment">// 保存旧值（拷贝）</span></span><br><span class="line">        ++ptr;                <span class="comment">// 再移动</span></span><br><span class="line">        <span class="keyword">return</span> tmp;           <span class="comment">// 返回旧值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>前缀自增 <code>++it</code> 表示“先移动迭代器，再使用结果”，返回的是<strong>自增后的迭代器本身（通常是引用）</strong>。<br>后缀自增 <code>it++</code> 表示“先使用旧位置，再移动迭代器”，返回的是<strong>自增前迭代器的一个副本</strong>。</p>
<p>后缀形式为了返回旧值，必须保存一个临时对象；前缀形式不需要。</p>
<p><strong>不需要旧值的情况下应当使用前缀形式</strong>；前缀在语义和性能上都更优。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2026/02/07/algorithm/3.stl/4.%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>函数模板是一个用于产生函数的公式。</p>
<p>语法：</p>
<p>template &lt;typename T&gt; +函数声明</p>
<p>所以template和函数声明可以分为两行写，中间不能有其他语句。</p>
<p>(和template&lt;class T&gt;完全等价)</p>
<p>然后把想泛化的类型换成T即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>stl</category>
      </categories>
  </entry>
  <entry>
    <title>c++语法</title>
    <url>/2026/02/07/language/c++/c++%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-万能头-include"><a href="#1-万能头-include" class="headerlink" title="1.万能头#include&lt;bits&#x2F;std++.h&gt;"></a>1.万能头#include&lt;bits&#x2F;std++.h&gt;</h4><h4 id="2-命名空间namespace"><a href="#2-命名空间namespace" class="headerlink" title="2.命名空间namespace"></a>2.命名空间namespace</h4><p>namespace准确来说是防止重名，而对某些变量，函数的修饰，因为它并不是物理储存结构，而是编译时的二进制修饰。不恰当的类比:int x;struct x{int x;};这两个语句不冲突，但是去掉struct 就重名了。</p>
<h5 id="namespace性质"><a href="#namespace性质" class="headerlink" title="namespace性质"></a>namespace性质</h5><h6 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h6><p>namespace S{</p>
<p>}括号里面放函数，变量等</p>
<h6 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h6><p>命名空间可以嵌套</p>
<p>namespace Outer { namespace Inner { void Func() { } }</p>
<p>在一个文件里面，如果有全局</p>
<p>访问:Outer::Inner::Func();</p>
<h6 id="可多次使用"><a href="#可多次使用" class="headerlink" title="可多次使用"></a>可多次使用</h6><h6 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h6><p>完全限定名：<code>std::cout</code></p>
<p>只用当前一次</p>
<p>using声明：<code>using std::cout;</code></p>
<p>用一个，输入该命令后全域都可以使用</p>
<p>using指令：<code>using namespace std;</code></p>
<p>命名空间导入</p>
<h5 id="namespace变量性质"><a href="#namespace变量性质" class="headerlink" title="namespace变量性质"></a>namespace变量性质</h5><p>当前文件修改namespace里面的变量会生效，但是不会影响到下一次编译</p>
<p>在某处引入using namespace A或者using A::…，只会在当前作用域生效</p>
<p>至此，using namespace std是什么已经很清楚了，注意std权限是可读，无法修改cout等函数，假设用hexedit修改源码，会造成编译立即崩溃</p>
<h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h4><p>int func(int &amp;a){}</p>
<p>表示a按照传引用 传递，也就是外面的值可以像用指针那样改变</p>
<p>后面a正常用，不要当成指针*a用。</p>
<h4 id="4-头文件细微变化"><a href="#4-头文件细微变化" class="headerlink" title="4.头文件细微变化"></a>4.头文件细微变化</h4><p>多头文件#include&lt;iostream&gt;</p>
<p>而c头文件可以正常用，但是推荐去掉.h,前面加c，比如&lt;stdio.h&gt; —&gt; &lt;cstdio&gt;</p>
<h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h4><p>迭代器是 C++ STL 提供的一种泛型指针，这种数据类型用于检查和遍历容器内元素，理解为指针即可</p>
<h6 id="begin和end"><a href="#begin和end" class="headerlink" title="begin和end"></a>begin和end</h6><p>begin()指向容器的第一个元素，注意！end()指向容器的最后一个元素的后一个元素！end通常作为未查找到的返回值</p>
<h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>vector &lt;int&gt;::iterator it;</p>
<p>for(set &lt;int&gt;::iterator it&#x3D;dict.begin();it!&#x3D;dict.end();++it)</p>
<p>cout&lt;&lt;*it&lt;&lt;”\n”;</p>
<h6 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h6><p>1.随机访问迭代器 ：</p>
<p>功能最全，支持解引用，成员访问，自增自减，迭代器加减，迭代器距离，比较，下标。和数组指针几乎一样</p>
<p>vector，deque容器支持</p>
<p>如</p>
<p>vector&lt;int&gt;::iterator it &#x3D; v.begin();<br>    cout &lt;&lt; *it &lt;&lt; endl;      &#x2F;&#x2F; 输出第一个元素<br>    cout &lt;&lt; *(it + 3) &lt;&lt; endl; &#x2F;&#x2F; 输出第四个元素<br>    it +&#x3D; 2;                  &#x2F;&#x2F; 跳跃到第3个元素<br>    cout &lt;&lt; *it &lt;&lt; endl;      &#x2F;&#x2F; 输出<br>    cout &lt;&lt; (v.end() - v.begin()) &lt;&lt; endl; &#x2F;&#x2F; 元素个数<br>    cout &lt;&lt; it[1] &lt;&lt; endl;    &#x2F;&#x2F; 相当于 *(it + 1)</p>
<p>2.双向迭代器：</p>
<p>比随机访问迭代器更弱一点，不支持迭代器位置比较it_1&lt;it_2，和随即跳转it+n</p>
<p>list,set,map是双向</p>
<p>3.前向迭代器 多次读写，单向，输出迭代器，只写一次，单向，输入迭代器，只读一次，单向。很少用。</p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>比如vector容器，动态扩容之后会重新找一块更大的空间，所以原来的迭代器会失效</p>
<h6 id="迭代器辅助函数"><a href="#迭代器辅助函数" class="headerlink" title="迭代器辅助函数"></a>迭代器辅助函数</h6><p>辅助函数可用于各种迭代器，通常用于写模板或泛型代码</p>
<p>#include&lt;algorithm&gt;</p>
<p>advance(it,n);使得迭代器向前&#x2F;后移动n，（随即迭代器里的it+&#x3D;n;)</p>
<p>distance（it2,it1)；计算两个迭代器之间距离，即元素个数。it2要&lt;&#x3D;it1</p>
<p>iter_swap(it1,it2);交换迭代器指向的值</p>
<h5 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h5><h6 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h6><p>用于处理字符串的输入输出流。从string里面读入</p>
<p>c++里面，流是数据从一个对象到另一个对象的流动。数据输入输出通过IO流实现，cin&#x2F;cout是istream，ostream创建的对象（cin，cout是抽象实现，不能创建和拷贝，但是可以引用，istream &amp; _cin&#x3D;cin对，istream _cin&#x3D;cin和istream _cin都错。 而stringstream不是抽象类，可以直接创建）</p>
<h6 id="2-创建-一般来说创建名为ss"><a href="#2-创建-一般来说创建名为ss" class="headerlink" title="2.创建(一般来说创建名为ss)"></a>2.创建(一般来说创建名为ss)</h6><p>a.直接创建</p>
<p>string arr(“hello world”);</p>
<p>stringstream ss;</p>
<p>ss&lt;&lt; arr;</p>
<p>cout &lt;&lt;ss.str()&lt;&lt;endl;</p>
<p>b.初始化创建</p>
<p>stringsream ss(“hello world”);</p>
<h6 id="3-输出"><a href="#3-输出" class="headerlink" title="3.输出"></a>3.输出</h6><p>调用ss.str();不能直接输出ss</p>
<h6 id="4-修改流"><a href="#4-修改流" class="headerlink" title="4.修改流"></a>4.修改流</h6><p>ss.str(“fuck world”)</p>
<h6 id="5-常见用法"><a href="#5-常见用法" class="headerlink" title="5.常见用法"></a>5.常见用法</h6><p>string line,wold;</p>
<p>while(getline(cin,line)){</p>
<p>stringstream ss(line)</p>
<p>while(ss&gt;&gt;word)…</p>
<p>}</p>
<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p>自动推导类型</p>
<p>如auto x&#x3D;6—x为int</p>
<p>auto x&#x3D;arr.size();—x为size_t</p>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>一种类，string s&#x3D;”hello world”</p>
<p>1.访问元素可以通过s[i]或者s.at(i),</p>
<p>两者都可以修改原string串内容</p>
<p>s[i]无越界检查，但跟高效，s.at(i)会检查越界</p>
<p>2.方法.</p>
<p>数组长度 s.length()或者s.size()</p>
<p>是否为空 s.empty()</p>
<p>追加字符 s.append()</p>
<p>插入         s.insert(pos,str)</p>
<p>删除          s.erase(pos,len)</p>
<p>清空          s.clear()</p>
]]></content>
      <categories>
        <category>language</category>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>java回忆录</title>
    <url>/2026/02/07/language/java/java%E5%9B%9E%E5%BF%86%E5%BD%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>面向对象编程：区别于面向过程编程，一个小程序需要几个函数和几个变量，我们分别编写再一一使用，面向过程（围绕函数展开）。而面向对象则是根据需求抽象出不同的对象并为不同的对象实现不同功能。<br><a href="https://www.zhihu.com/question/27468564/answer/757537214">https://www.zhihu.com/question/27468564/answer/757537214</a></p>
<h3 id="方法积累：查java手册"><a href="#方法积累：查java手册" class="headerlink" title="方法积累：查java手册"></a>方法积累：查java手册</h3><h5 id="字符串类："><a href="#字符串类：" class="headerlink" title="字符串类："></a>字符串类：</h5><p>substring,length,equals;</p>
<p>StringBuilder:length,append,delete,reverse,insert,join(用字符分隔),repeat,replace</p>
<h5 id="Math"><a href="#Math" class="headerlink" title="Math:"></a>Math:</h5><p>exp(),log(),pow(,)sqrt(),sin(),asin(),</p>
<p>toDegrees(),toRadians(),random()</p>
<h5 id="Number包装类-Number-Java-SE-11-JDK-11"><a href="#Number包装类-Number-Java-SE-11-JDK-11" class="headerlink" title="Number包装类:Number (Java SE 11 &amp; JDK 11 )"></a>Number包装类:<a href="https://www.runoob.com/manual/jdk1.6/java.base/java/lang/Number.html">Number (Java SE 11 &amp; JDK 11 )</a></h5><p>…Value()？，把某种包装类变成…数据类型(如x.intValue,x为Double等)</p>
<p>ValueOf(),如Integer.ValueOf(int);</p>
<p>可以用Integer i&#x3D;…;底层调用的就是valueof</p>
<p>不用Integer i&#x3D;new Integer(int);这个即将被淘汰。</p>
<p>equal()</p>
<p>Integer.parseInt(String或String,int(这里int是进制，不写int默认10)</p>
<h5 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h5><p>biginteger:任意精度整数运算</p>
<p>创建：BigInteger ..&#x3D;new BigInteger(“字符串”);</p>
<p>BigInteger ..&#x3D;BigInteger.ValueOf(100);</p>
<p>运算：c&#x3D;a.add(b(biginter类型))</p>
<p>a.multiply a.mod a.pow a.divide a.subtract a.compareTo</p>
<p>输入:in.nextbiginteger() 或者常规加valueof</p>
<p>输出:常规输出即可</p>
<h4 id="数据储存"><a href="#数据储存" class="headerlink" title="数据储存"></a>数据储存</h4><p>1.栈内存用于存储基本数据类型,基本数据类型,方法调用时的局部变量</p>
<p>2.堆由 JVM（Java 虚拟机）统一管理，储存Java里面所有对象</p>
<p>3.new:new Walrus(1000.0,3);new实例化一个对象，从堆里面分配相应内存这里是32，64共96bits，并返回其地址</p>
<p> Walrus newwalrus:创建一个引用对象，期间创建一个64bits(固定64！)的内存，默认为空，然后把new的返回赋给它，那么newwalrus就可以使用了:newwalrus&#x3D;new Walrus(1000.0,3)</p>
<p>注意重新指向对象可能导致原对象丢失</p>
<p>4.在一个类里面创建构造函数(constructor)，</p>
<p>pubic 类名(参数){</p>
<p>this. …&#x3D;….;</p>
<p>…</p>
<p>}</p>
<p>那么创建对象的时候将new 类(参数)； 没有构造函数的话（会有默认的空构造函数）：new类（）。</p>
<p>5.方法 的值传递：</p>
<p>a.传入对象数组等，相当于传入的是一个副本p’，让p’指向新的对象new，外面的p不会变，但是p’.name变了，外面的p.name也会变（地址）</p>
<p>b.原始类型：值传递，外面不变</p>
<p>6.数组也是对象，即类似于3那种，int[] arr&#x3D;new int[]{1,2,2,3,1};</p>
<p>7.String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</p>
<h4 id="文件规则"><a href="#文件规则" class="headerlink" title="文件规则"></a>文件规则</h4><p>1.源代码的文件名必须与公共类的类名相同</p>
<p>2.main方法必须为public</p>
<h4 id="方法（类似于函数）"><a href="#方法（类似于函数）" class="headerlink" title="方法（类似于函数）"></a>方法（类似于函数）</h4><p>1.点号用于调用方法</p>
<p>2.输出函数</p>
<p>System.ou.println(“”);输出后有换行符</p>
<p>System.out.print(“”);输出后无换行符</p>
<p>2.5：注意，bufferread比上面这个输入快很多</p>
<p>3.数学库Math.pow( , );Math.sqrt();</p>
<p>Math.sin();Math.exp();</p>
<p>常量Math.PI;Math.E;</p>
<p>（返回值类型是long）Math.round();四舍五入</p>
<p>避免使用前缀:import static java.lang.Math.*;</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>1.byte（1） short（2） int（4） long（8） float（4） double（8） boolean char</p>
<p>2.无 无符号类型</p>
<p>3.长整型有L或l后缀，float有F&#x2F;f后缀。十六进制0x前缀</p>
<p>4.java整型大小与平台无关</p>
<p>5.正无穷大：Double.POSITIVE_INFINITY</p>
<p>   负无穷大：Double.NEGATIVE_INFINITY</p>
<p>   不是数：Double.NaN(所有的NaN值都是不同的）,判断是不是数Double.isNaN(x)</p>
<p>6.unicode转义在解析代码之前处理</p>
<p>println等价于pr\u0069tf   哈哈哈unicode只是编码格式，大多数情况等价</p>
<p>7.var 变量&#x3D;1；变量自动识别为int.</p>
<p>8.常量:final double ADF;表示ADF变量只能被赋值一次</p>
<p>9.类常量，放在main方法外，同一个类的其他方法也能用:public <strong>static​</strong>  fianl double</p>
<p>10.二元运算符连接两个变量的时候，自动进行类型转换，忘高精度，浮点数的变量方向转化</p>
<p>11.不在boolean类型和其他之间类型转换，用B?1:0</p>
<p>12.枚举类型：枚举是一种特殊的类，该类里面所有的常量都是他的实例。</p>
<p>enum   size(类) {A,B,C,D};</p>
<p>Size x&#x3D;Size.B;</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><p>跳过没学</p>
<h5 id="运算符级别"><a href="#运算符级别" class="headerlink" title="运算符级别"></a>运算符级别</h5><p>同c</p>
<p>1.注意a+&#x3D;b+&#x3D;c，加等于是右结合运算符，等价于a +&#x3D;(b+&#x3D;c)</p>
<p>2.java无逗号运算符</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>String  a&#x3D;””;</p>
<p>String不是字符串类型，是一个预定义类</p>
<p>这意味着string有很多方法</p>
<p>string进行了特殊优化，使其使用起来像基本类型，可以直接拼接</p>
<p>注意string储存的是对象引用，是堆上的对象，是对象的地址，赋值后改变则都会改变</p>
<p>（有点像c的指针）赋值新值后会导致原值留在内存里面</p>
<h5 id="子串-substring方法"><a href="#子串-substring方法" class="headerlink" title="子串:substring方法"></a>子串:substring方法</h5><p>String greeting &#x3D;”hello”;</p>
<p>String s&#x3D;greeting.substring(0,3) &#x2F;&#x2F;从从零到第一个不想复制的位置</p>
<p>(s&#x3D;&#x3D;”hel”)</p>
<h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><p>java支持字符串的拼接</p>
<h6 id="字符与字符"><a href="#字符与字符" class="headerlink" title="字符与字符"></a>字符与字符</h6><h6 id="字符与其他类型"><a href="#字符与其他类型" class="headerlink" title="字符与其他类型"></a>字符与其他类型</h6><p>int age &#x3D;18;</p>
<p>String information&#x3D;”name”+age;</p>
<p>—- name18</p>
<h5 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h5><p>equals 比较字符串是否相等，注意字符串不用&#x3D;&#x3D;比较，因为比的是地址，可能出bug</p>
<p>join 用指定分隔符隔开若干个字符串</p>
<p>repeat 把一个字符串重复指定次数次，成为一个新的字符串</p>
<p>length 返回指定字符串所需要的代码单元个数</p>
<p>很多，可以去oracle官网查看api注释</p>
<h5 id="不能改变"><a href="#不能改变" class="headerlink" title="不能改变"></a>不能改变</h5><p>string指向的内容不能修改，但是可以重新指向新的目标</p>
<p>但是string指向的内容可以共享</p>
<h5 id="空串和null"><a href="#空串和null" class="headerlink" title="空串和null"></a>空串和null</h5><p>空串是一个 java 对象，有自己的串长度 ( 0) 和内容 (空)。</p>
<p>null表示目前没有任何对象与该变量关联</p>
<p>检查一个字符串是否为 null：if (str&#x3D;&#x3D;null)</p>
<h4 id="构建字符串StringBuilder"><a href="#构建字符串StringBuilder" class="headerlink" title="构建字符串StringBuilder"></a>构建字符串StringBuilder</h4><p><code>StringBuilder</code> 是允许原地修改字符串的类</p>
<h5 id="创建StringBuilder类字符串"><a href="#创建StringBuilder类字符串" class="headerlink" title="创建StringBuilder类字符串"></a>创建StringBuilder类字符串</h5><p>StringBuilder  x&#x3D;new StringBuilder(“hello(或者String变)”);</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><h6 id="增加append"><a href="#增加append" class="headerlink" title="增加append"></a>增加append</h6><p>x.append(“ “);</p>
<h6 id="插入insert"><a href="#插入insert" class="headerlink" title="插入insert"></a>插入insert</h6><h6 id="替换replace"><a href="#替换replace" class="headerlink" title="替换replace"></a>替换replace</h6><h6 id="删除delete-deleteCharAt"><a href="#删除delete-deleteCharAt" class="headerlink" title="删除delete&#x2F;deleteCharAt"></a>删除delete&#x2F;deleteCharAt</h6><p>注意从零开始的问题</p>
<h6 id="反转reverse"><a href="#反转reverse" class="headerlink" title="反转reverse"></a>反转reverse</h6><h6 id="获取长度length"><a href="#获取长度length" class="headerlink" title="获取长度length"></a>获取长度length</h6><h6 id="转化为string"><a href="#转化为string" class="headerlink" title="转化为string"></a>转化为string</h6><p>String y&#x3D;x.toStrin();</p>
<h4 id="构建字符串StringBuffer"><a href="#构建字符串StringBuffer" class="headerlink" title="构建字符串StringBuffer"></a>构建字符串StringBuffer</h4><p>语法基本同StringBuilder，区别在于StringBuilder更快，但只适用于单线程，而StringBuilder适用于多线程</p>
<h5 id="理解多线程"><a href="#理解多线程" class="headerlink" title="理解多线程"></a>理解多线程</h5><p><a href="https://www.cnblogs.com/brokyz/p/14707360.html">Java多线程详解——一篇文章搞懂Java多线程 - brokyz - 博客园</a></p>
<h5 id="文本块d"><a href="#文本块d" class="headerlink" title="文本块d"></a>文本块d</h5><h4 id="输入语句"><a href="#输入语句" class="headerlink" title="输入语句"></a>输入语句</h4><h5 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1.导入库"></a>1.导入库</h5><p>import java.util.*.;(util包含输入输出和数据结构的一些方法，*表示全部方法，除了concurrent并发库)</p>
<h5 id="2-构建一个输入对象"><a href="#2-构建一个输入对象" class="headerlink" title="2.构建一个输入对象"></a>2.构建一个输入对象</h5><p>利用Scanner方法</p>
<p>Scanner x&#x3D;new Scanner(System.in);</p>
<p>接着就可以通过x，调用scanner方法</p>
<h5 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h5><p>输入一整行 String name &#x3D;in.nextLine;</p>
<p>输入一个单词(空格) in.next();</p>
<p>int，double之类  in.nextInt();</p>
<h4 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h4><p>System.out.print();</p>
<p>Systrm.out.printf(“ “,…)(就是c里面的printf)</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h5 id="形式1：java14引入"><a href="#形式1：java14引入" class="headerlink" title="形式1：java14引入"></a>形式1：java14引入</h5><p>根据seasoncode的值(case)给season字符串直接赋值</p>
<p>String(表示字符串类型，也可以是int等)   season&#x3D;switch(seasoncode){</p>
<p>case 0 -&gt;”spring”;……</p>
<p>}</p>
<p>如果seasoncode是null，则抛出NullPointerException， 即异常</p>
<h4 id="日期-date-过时-，time类"><a href="#日期-date-过时-，time类" class="headerlink" title="日期 date(过时)，time类"></a>日期 date(过时)，time类</h4><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”），可以用来描述和匹配字符串的特定模式。</p>
<table>
<thead>
<tr>
<th>this is text</th>
<th>匹配字符串 “this is text”</th>
</tr>
</thead>
<tbody><tr>
<td>this\s+is\s+text</td>
<td>注意字符串中的 <strong>\s+</strong>。匹配单词 “this” 后面的 <strong>\s+</strong> 可以匹配多个空格，之后匹配 is 字符串，再之后 <strong>\s+</strong> 匹配多个空格然后再跟上 text 字符串。可以匹配这个实例：this is text</td>
</tr>
<tr>
<td>^\d+(.\d+)?</td>
<td>^ 定义了以什么开始\d+ 匹配一个或多个数字? 设置括号内的选项是可选的. 匹配 “.”可以匹配的实例：”5”, “1.5” 和 “2.21”。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>language</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java学习笔记</title>
    <url>/2026/02/07/language/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md/</url>
    <content><![CDATA[<h2 id="概念规则"><a href="#概念规则" class="headerlink" title="概念规则"></a>概念规则</h2><ol>
<li><p>实例和对象和类区别：<br>实例是通过类创建的对象，比如我string a，a就是string类的实例。比如人类，里面的李白和杜甫就是实例。<br>对象更宽泛，你可以说任何内存实体都是对象。<br>但是一般可以认为实例和对象就是一回事，可以换用。</p>
</li>
<li><p>源代码的文件名必须与公共类的类名相同</p>
</li>
<li><p>main方法必须为public</p>
</li>
<li><p>字符串区间规律：从零开始，操作长度为n–（0,n)例如x.delete(0,4)删除第1-4个，第一个代表起始位置，第二个代表总长度</p>
</li>
<li><p>java.lang是java核心包，无需import</p>
</li>
</ol>
<h2 id="方法积累"><a href="#方法积累" class="headerlink" title="方法积累"></a>方法积累</h2><h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h6 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h6><p>1.java无内置字符串类型，但有一个预定义类string，每个字符串都是string类的实例，这意味着string有很多方法</p>
<p>2.string进行了特殊优化，使其使用起来像基本类型，可以直接拼接</p>
<p>3.注意string储存的是对象在内存中位置的引用，是对象在堆上的<strong>地址</strong>。但是String是不可变对象引用，给某一个string对象引用赋新值，会导致这个引用直接指向新的对象。同时赋值新值后，会导致原值留在内存里面。</p>
<p>String s1&#x3D;”hello”;</p>
<p>String s4&#x3D;”hello”;</p>
<p>s4&#x3D;”nima”;</p>
<p>System.out.println(s1);—-输出hello!</p>
<h6 id="构建："><a href="#构建：" class="headerlink" title="构建："></a>构建：</h6><p>a.字面量:String s1&#x3D;”hello”;高效率</p>
<p>b.构造方法:String s2&#x3D;new String (“nima”);</p>
<p>区别：</p>
<p>a.存储在 <strong>字符串常量池</strong>中，如果常量池中已经存在 <code>&quot;hello&quot;</code>，Java 就不会再创建新的对象，而是 <strong>直接引用已存在的</strong>。</p>
<p>b.会 <strong>在堆内存中新建一个字符串对象</strong>。</p>
<p>String s1&#x3D;”hello”;</p>
<p>String s4&#x3D;”hello”;</p>
<p>String s2&#x3D;new String (“hello”);</p>
<p>s1.equals(s2)–true</p>
<p>s1.equals(s4)–true</p>
<p>s1&#x3D;&#x3D;s2–true(地址相同,同一个)</p>
<p>s1&#x3D;&#x3D;s4–false</p>
<h6 id="拼接"><a href="#拼接" class="headerlink" title="拼接 +"></a>拼接 +</h6><p>String s3&#x3D;s1+s4;—“hellohello”</p>
<p>注意！</p>
<p>1.Java 中 <code>String</code> 是不可变的，所以每次拼接字符串，实际上是创建了一个新的字符串对象，而不是在原字符串基础上修改。</p>
<p>2.实际编译器会生成类似这样的代码：String s &#x3D; new StringBuilder().append(s1).append(s4).toString();</p>
<p>所以每次+都会创建新的字符串对象，性能差</p>
<p>建议用StringBuilder</p>
<h5 id="substring方法"><a href="#substring方法" class="headerlink" title="substring方法"></a>substring方法</h5><p>返回新的子串</p>
<p>String substring(int beginIndex)</p>
<p>&#x2F;&#x2F;从该索引开始到结束<br>String substring(int beginIndex, int endIndex)</p>
<p>&#x2F;&#x2F;注意如果看成数组索引的话，endindex要+1</p>
<p>输出完自动添加换行</p>
<p>eg：</p>
<p>String str &#x3D; “hello world”;<br>System.out.println(str.substring(0, 5)); &#x2F;&#x2F; 输出 “hello”<br>System.out.println(str.substring(6));   &#x2F;&#x2F; 输出 “world”</p>
<h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><p>很多类都有这个方法</p>
<p>String str&#x3D;”hello world”;</p>
<p>str.length()&#x3D;&#x3D;11;</p>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p>s1.equals(s2);</p>
<p>“hello”.equals(s2);</p>
<p>不要用等于&#x3D;&#x3D;,&#x3D;&#x3D;代表比较位置，只有字符串字面量可能相等</p>
<h5 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase"></a>equalsIgnoreCase</h5><p>s1.equalsIgnoreCase(s2)比较忽略大小写</p>
<h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h5><p>s1.compareTo(s2)</p>
<p>按照字典顺序比较两个字符串，相等返回1，小于返回负数，大于返回正数</p>
<h3 id="Stingbuilder类"><a href="#Stingbuilder类" class="headerlink" title="Stingbuilder类"></a>Stingbuilder类</h3><h6 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h6><p>StringBuilder x&#x3D;new StringBuilder(“cao “(或者String变量));</p>
<h5 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h5><p>类似</p>
<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>x..append(“nima”) ,在cao后面追加nima</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>x.delete(0, 4),删除区间内内容（含头不含尾）</p>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>x.reverse(),反转字符串</p>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>x.insert(2, “X”),在指定位置插入</p>
<h5 id="join拼接"><a href="#join拼接" class="headerlink" title="join拼接"></a>join拼接</h5><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>x.replace(1, 3, “XYZ”),替换内容</p>
<h5 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h5><p>x.ToString()变成string类</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>语法基本同StringBuilder，区别在于StringBuilder更快，但只适用于单线程，而StringBuffer适用于多线程</p>
<p>理解多线程</p>
<p><a href="https://www.cnblogs.com/brokyz/p/14707360.html">Java多线程详解——一篇文章搞懂Java多线程 - brokyz - 博客园</a></p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>java.lang.Math无需导入</p>
<h5 id="exp-log-pow-sqrt-sin-asin-toDegrees-toRadians-random"><a href="#exp-log-pow-sqrt-sin-asin-toDegrees-toRadians-random" class="headerlink" title="exp(),log(),pow(),sqrt(),sin(),asin(),toDegrees(),toRadians(),random()"></a>exp(),log(),pow(),sqrt(),sin(),asin(),toDegrees(),toRadians(),random()</h5><p>double a &#x3D; Math.exp(1);            &#x2F;&#x2F; e 的 1 次方，即 e ≈ 2.718<br>double b &#x3D; Math.log(10);           &#x2F;&#x2F; 计算自然对数 ln(10)<br>double c &#x3D; Math.pow(2, 3);         &#x2F;&#x2F; 2 的 3 次方，结果为 8<br>double d &#x3D; Math.sqrt(16);          &#x2F;&#x2F; 计算 16 的平方根，结果为 4<br>double e &#x3D; Math.sin(Math.PI &#x2F; 2);  &#x2F;&#x2F; 计算正弦，sin(π&#x2F;2) &#x3D; 1<br>double f &#x3D; Math.asin(1);           &#x2F;&#x2F; 计算反正弦 asin(1) &#x3D; π&#x2F;2<br>double g &#x3D; Math.toDegrees(Math.PI); &#x2F;&#x2F; 弧度转角度，π 弧度 ≈ 180°<br>double h &#x3D; Math.toRadians(90);     &#x2F;&#x2F; 角度转弧度，90° ≈ π&#x2F;2<br>double i &#x3D; Math.random();          &#x2F;&#x2F; 生成一个 0.0 到 1.0 的随机数</p>
<h3 id="Number包装类Number-Java-SE-11-JDK-11"><a href="#Number包装类Number-Java-SE-11-JDK-11" class="headerlink" title="Number包装类Number (Java SE 11 &amp; JDK 11 )"></a>Number包装类<a href="https://www.runoob.com/manual/jdk1.6/java.base/java/lang/Number.html">Number (Java SE 11 &amp; JDK 11 )</a></h3><p>包装类（Wrapper Class） 是 Java 提供的一种机制，它将基本数据类型（int、<code>char</code>、<code>double</code> 等）包装为 <strong>对象</strong>。这使得基本数据类型能够作为对象使用，例如在 <strong>Java 集合框架</strong>（如 <code>ArrayList</code>、<code>HashMap</code>）中，或者进行类型转换、方法调用等操作。</p>
<p><img src="file:///C:/Users/hardestnut/Pictures/Typedown/39850735-a33b-4c8d-a2f5-5bd5fde0cbe4.png" alt="39850735-a33b-4c8d-a2f5-5bd5fde0cbe4"></p>
<p>抽象类，不能实例化</p>
<p>Double那些是Number的子类，注意BigDecimal，BigInteger也是。是Number子类都可以调用.intValue()方法</p>
<h5 id="intValue-doubleValue……"><a href="#intValue-doubleValue……" class="headerlink" title="intValue,doubleValue……"></a>intValue,doubleValue……</h5><p>Double d &#x3D; 3.99;<br>int i &#x3D; d.intValue();       &#x2F;&#x2F; i &#x3D; 3，截断小数</p>
<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>基本类型转包装对象</p>
<p>Double d &#x3D; Double.valueOf(3.14);        &#x2F;&#x2F; double -&gt; Double 对象</p>
<p>字符串转包装对象</p>
<p>Integer i2 &#x3D; Integer.valueOf(“456”);    &#x2F;&#x2F; 字符串 “456” -&gt; Integer 对象</p>
<h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>BigInteger整数，BigDecimal浮点</p>
<h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><p>1.BigInteger big1 &#x3D; new BigInteger(“123456789012345678901234567890”);</p>
<p>2.valueOf</p>
<h5 id="valueOf"><a href="#valueOf" class="headerlink" title="valueOf"></a>valueOf</h5><p>记得上面说的吗，BigInteger也是Number的子类</p>
<p>BigInteger a&#x3D;BigInteger.valueOf(1000000)</p>
<p>把1000000转换成biginteger类的对象</p>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><p>BigInteger sum &#x3D; big1.add(big2);</p>
<h5 id="multiply"><a href="#multiply" class="headerlink" title="multiply()"></a>multiply()</h5><h5 id="divide"><a href="#divide" class="headerlink" title="divide()"></a>divide()</h5><h5 id="mod"><a href="#mod" class="headerlink" title="mod()"></a>mod()</h5><h5 id="pow-int"><a href="#pow-int" class="headerlink" title="pow(int)"></a>pow(int)</h5><h5 id="subtract"><a href="#subtract" class="headerlink" title="subtract()"></a>subtract()</h5><h5 id="compareTo-1"><a href="#compareTo-1" class="headerlink" title="compareTo()"></a>compareTo()</h5><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h2 id="对象初步"><a href="#对象初步" class="headerlink" title="对象初步"></a>对象初步</h2><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1.基本规则"></a>1.基本规则</h3><p>1.一个文件里面可以有多个类，但是public修饰的类只能有一个，且这个类名必须和文件名一样</p>
<h3 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h3><p>使用构造器构造，构造器名与类相同，前面加上new，</p>
<p>如new class();</p>
<p>Date rightnow–创建一个Date类的对象变量–对象变量不是对象，不能使用对象的方法</p>
<p>注意！：对象变量的值是一个引用，也就是说Date rightnow&#x3D;new Date();,rightnow_2&#x3D;rightnow,此时两个还是指向一个</p>
<p>new Date()–构造一个变量</p>
<p>System.out.println(new Date())–创建的对象变量可以用，但只能用一次（这里date有toString方法，println输出默认使用toString转为字符串）</p>
<p>Date rightnow&#x3D;new Date();</p>
]]></content>
      <categories>
        <category>language</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>c++容器</title>
    <url>/2026/02/07/language/c++/c++%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h4 id="算法algorithm"><a href="#算法algorithm" class="headerlink" title="算法algorithm"></a>算法algorithm</h4><h1 id="容器container"><a href="#容器container" class="headerlink" title="容器container"></a>容器container</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>#include&lt;vector&gt; </p>
<p><code>vector</code> 的数据储存在堆空间中，不会爆栈。一般情况 <code>vector</code> 可以替换掉普通数组。</p>
<p>注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销</p>
<h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>vector&lt;类型&gt; arr(长度，[初值]) </p>
<p>括号及里面的内容可省，默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr; <span class="comment">// 构造int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 构造初始长100的int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ()); <span class="comment">// 构造初始100行，不指定列数的二维数组 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">200</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始200列的二维数组，初值为-1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>],没初始化的二维数组，每一个arr[i]都是一个vector，相当行数不变，列数不定的二维数组</span><br><span class="line">arr[i].push_back;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个二维数组可以理解为100个元素，每个元素都是一维vector</p>
<p>注意，创建完后，可以当作普通数组用，如</p>
<p>vector&lt;int&gt; arr(100),arr[0]&#x3D;1;</p>
<h5 id="尾增尾删push-back-pop-back"><a href="#尾增尾删push-back-pop-back" class="headerlink" title="尾增尾删push_back(),pop_back()"></a>尾增尾删push_back(),pop_back()</h5><ul>
<li><strong><code>.push_back(元素)</code></strong>：在 vector 的最后一个内存后增加一格内存，并给这个内存赋值，数组长度+1(!)</li>
<li><strong><code>.pop_back()</code></strong>：删除 vector 的最后一格内存及其元素，数组长度-1</li>
</ul>
<p>arr.push_back(100);</p>
<p>arr.pop_back();</p>
<p>arr&#x3D;{0,0,0,0},arr.push_back(9)–&gt;arr&#x3D;{0,0,0,0,9}</p>
<h5 id="获取长度-size"><a href="#获取长度-size" class="headerlink" title="获取长度.size()"></a>获取长度.size()</h5><p>获取当前 vector 的长度</p>
<p>注意返回值是无符号整数size_t</p>
<p>o(1)复杂度</p>
<h5 id="清空-clear"><a href="#清空-clear" class="headerlink" title="清空.clear()"></a>清空.clear()</h5><p>arr.clear();</p>
<p>o(n)复杂度</p>
<h5 id="判空-empty"><a href="#判空-empty" class="headerlink" title="判空 .empty()"></a>判空 .empty()</h5><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p>
<p>时间复杂度：o(1)</p>
<h5 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h5><p><strong><code>.resize(新长度, [默认值])</code></strong></p>
<p>修改 vector 的长度</p>
<p>如果是缩短，则删除多余的值</p>
<p>如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变）</p>
<p>时间复杂度：o(n)</p>
<h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><p>#include&lt;stack&gt;</p>
<p>栈不可访问内部元素，只能用弹出看栈顶,所以感觉可以用vector代替stack，或者手写。–</p>
<p>vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p>
<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>stack&lt;类型&gt; a,不初始化</p>
<h5 id="进出栈"><a href="#进出栈" class="headerlink" title="进出栈"></a>进出栈</h5><p>a.push(元素)进</p>
<p>a.pop()弹出</p>
<h5 id="取栈顶"><a href="#取栈顶" class="headerlink" title="取栈顶"></a>取栈顶</h5><p>a.top();</p>
<p>int topnum&#x3D;a.top();</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p>queue&lt;类型&gt; que</p>
<h5 id="进出队"><a href="#进出队" class="headerlink" title="进出队"></a>进出队</h5><p>.push(元素)</p>
<p>.pop()</p>
<h5 id="取队尾队首"><a href="#取队尾队首" class="headerlink" title="取队尾队首"></a>取队尾队首</h5><p>.front()</p>
<p>.back()</p>
<p>int getfront&#x3D;que.front();</p>
<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>自动去重，加入元素后，元素自动从小到大排序的一个容器</p>
<p>注意set不支持下标操作，需要用迭代器</p>
<h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>#include&lt;set&gt;</p>
<h5 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h5><p>set&lt;int&gt; dict;</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>插入：dict.insert(x);</p>
<p>删除：dict.erase(x);</p>
<p>查找：dict.count(x) &#x2F;dict.find(x);</p>
<p>找到了，返回指向x的迭代器，没找到返回特殊迭代器dict.end()</p>
<p>个数：dict.size(x);</p>
<p>清空：dict.clear(x);</p>
<p>判断为空：dict.empty(x);</p>
<h2 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h2><p>新元素被添加到堆的末尾，然后通过”上浮”操作调整位置，保持堆性质，时间复杂度：O(log n)</p>
<h5 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h5><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p>
<p>类型：要储存的数据类型</p>
<p>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</p>
<p>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</p>
<p>priority_queue&lt;int&gt; pque;默认为大顶堆</p>
<p>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; 储存int的小顶堆</p>
<h5 id="进出堆"><a href="#进出堆" class="headerlink" title="进出堆"></a>进出堆</h5><p>.push(元素)</p>
<p>.pop()</p>
<h5 id="取堆顶-大堆顶就是最大值，小就是最小值"><a href="#取堆顶-大堆顶就是最大值，小就是最小值" class="headerlink" title="取堆顶(大堆顶就是最大值，小就是最小值)"></a>取堆顶(大堆顶就是最大值，小就是最小值)</h5><p>只可访问堆顶，其他元素都无法读取到。</p>
<p>.top()</p>
<p>int a&#x3D;pque.top();</p>
]]></content>
      <categories>
        <category>language</category>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/bfs/</url>
    <content><![CDATA[<hr>
<p>title: bfs</p>
<p>data: 2026-02-07 09:33:00</p>
<p>categories:</p>
<ul>
<li><p>algorithm</p>
</li>
<li><p>搜索</p>
</li>
</ul>
<hr>
<p>bfs(breadth first search)宽度优先搜索，一层一层搜，可以用于最短路径问题，最少步骤解答</p>
<p>大致思路是：对于一个图而言，我们放入一个起点，然后拿出这个点，并放入这个点相邻的所有点（相当于访问了），再拿出新放入的点，并放入这些所有的新放入的点的相邻点…依次类推，直到所有点都被放入过。这个过程像水的波纹一层一层的散开，称为深搜。</p>
<p>1.首先复习下图的储存，一般是用数组模拟邻接表，即链式前向星</p>
<p>add函数将节点v和节点u相连这条信息插入到邻接表里面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> m=<span class="number">2</span>*n<span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> head[n],e[m],ne[m],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    ne[idx]=head[v];</span><br><span class="line">    head[v]=idx;</span><br><span class="line">    e[idx]=u;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.接着实现bfs</p>
<p>首先我们维护几个数组：</p>
<p>bool vis[u]记录u节点是否被遍历，是为1，否为0</p>
<p>int d[u] 记录深度，即起点到u点的最小距离</p>
<p>int p[u] 记录是从哪个节点到哪个节点，方便还原路径</p>
<p>具体意义是:p[v]&#x3D;指向v的上一个边u;</p>
<p>这样，我们对于所有点，能知道它到起点的距离，也能回溯任意点的路径！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">10000</span>,m=<span class="number">2</span>*n<span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> e[m],ne[m],idx,head[n];</span><br><span class="line"><span class="type">bool</span> vis[n];</span><br><span class="line"><span class="type">int</span> d[n],p[n];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())Q.<span class="built_in">pop</span>();</span><br><span class="line">    Q.<span class="built_in">push</span>(u);</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    p[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> node=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[node];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="comment">//i是索引的迭代</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[e[i]])&#123;</span><br><span class="line"><span class="comment">//如果没有访问过下一个点，就放入，并让d[下一个点]=d[node]+1，p[下一个点]指向node</span></span><br><span class="line">            Q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">            vis[e[i]]=<span class="number">1</span>;</span><br><span class="line">            d[e[i]]=d[node]<span class="number">+1</span>;</span><br><span class="line">            p[e[i]]=node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数逻辑：首先初始化Q,d,p,vis,然后将u放入Q中。</p>
<p>接着开始bfs循环，每次取出队首，并放入队首指向的所有边，然后更新vis，d，p</p>
<p>注意d的逻辑，是等于d[node]+1</p>
<p>3.访问路径</p>
<p>利用我们的p[u]回溯</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u;i!=<span class="number">-1</span>;i=p[i])&#123;</span><br><span class="line">        last.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(last.<span class="built_in">begin</span>(),last.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;last.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;last[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=u;i!=<span class="number">-1</span>;i=p[i])&#123;</span><br><span class="line">        last.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!last.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=last.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cout&lt;&lt;last[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reverse是反转函数，包含在&lt;algorithm&gt;头文件里面<br>应用（摘自oiwiki）</p>
<hr>
<hr>
<ul>
<li>在一个无权图上求从起点到其他所有点的最短路径。</li>
<li>在 𝑂(𝑛 +𝑚)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="O(n+m)"> 时间内求出所有连通块。（我们只需要从每个没有被访问过的节点开始做 BFS，显然每次 BFS 会走完一个连通块）</li>
<li>如果把一个游戏的动作看做是状态图上的一条边（一个转移），那么 BFS 可以用来找到在游戏中从一个状态到达另一个状态所需要的最小步骤。</li>
<li>在一个有向无权图中找最小环。（从每个点开始 BFS，在我们即将抵达一个之前访问过的点开始的时候，就知道遇到了一个环。图的最小环是每次 BFS 得到的最小环的平均值。）</li>
<li>找到一定在 (𝑎,𝑏)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="(a, b)"> 最短路上的边。（分别从 a 和 b 进行 BFS，得到两个 d 数组。之后对每一条边 (𝑢,𝑣)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="(u, v)">，如果 𝑑𝑎[𝑢] +1 +𝑑𝑏[𝑣] &#x3D;𝑑𝑎[𝑏]<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="d_a[u]+1+d_b[v]&#x3D;d_a[b]">，则说明该边在最短路上）</li>
<li>找到一定在 (𝑎,𝑏)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="(a, b)"> 最短路上的点。（分别从 a 和 b 进行 BFS，得到两个 d 数组。之后对每一个点 v，如果 𝑑𝑎[𝑣] +𝑑𝑏[𝑣] &#x3D;𝑑𝑎[𝑏]<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="d_a[v]+d_b[v]&#x3D;d_a[b]">，则说明该点在某条最短路上）</li>
<li>找到一条长度为偶数的最短路。（我们需要一个构造一个新图，把每个点拆成两个新点，原图的边 (𝑢,𝑣)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="(u, v)"> 变成 ((𝑢,0),(𝑣,1))<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="((u, 0), (v, 1))"> 和 ((𝑢,1),(𝑣,0))<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="((u, 1), (v, 0))">。对新图做 BFS，(𝑠,0)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="(s, 0)"> 和 (𝑡,0)<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="(t, 0)"> 之间的最短路即为所求）</li>
<li>在一个边权为 0&#x2F;1 的图上求最短路，见下方双端队列 BFS。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>dfs</title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/dfs/</url>
    <content><![CDATA[<h3 id="dfs是什么？"><a href="#dfs是什么？" class="headerlink" title="dfs是什么？"></a>dfs是什么？</h3><p>DFS，即深度优先搜索，常用于遍历搜索树或图。</p>
<p><strong>该类搜索算法的特点在于，将要搜索的目标分成若干「层」，每层基于前几层的状态进行决策，直到达到目标状态。</strong></p>
<p>DFS 最显著的特征在于其 <strong>递归调用自身</strong>。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 <strong>每个点仅访问一次</strong>。符合以上两条规则的函数，便是广义上的 DFS。</p>
<h4 id="遍历图"><a href="#遍历图" class="headerlink" title="遍历图"></a>遍历图</h4><p>先了解图的储存 ( 树其实可以算图的一种 ) </p>
<h6 id="图的储存-邻接矩阵，邻接表"><a href="#图的储存-邻接矩阵，邻接表" class="headerlink" title="图的储存:邻接矩阵，邻接表"></a>图的储存:邻接矩阵，邻接表</h6><p>1.对于邻接矩阵而言，如果我们a-&gt;b有边，就让P[a][b]&#x3D;true;以此类推。</p>
<p>2.我们通常用邻接表储存</p>
<p>邻接表可以看成链表数组，一个数组里面每一个元素都是一个链表，对应每一个链表指向的所有节点。类比vector&lt;int&gt; a[maxn].</p>
<p>数据结构定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们假设有a个节点，b条无向边（一般题目会给）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=a<span class="number">+10</span>,m=<span class="number">2</span>*b<span class="number">+10</span>;<span class="comment">//2*b表明无向边可以看成两条特殊的有向边</span></span><br><span class="line"><span class="type">int</span> h[n],e[m],ne[m],idx;</span><br><span class="line"><span class="comment">//h[i]表示第i个节点的头节点，后面接入i节点指向的所有节点的idx索引，无顺序之分。e[idx]表示第idx个空间分配的值，ne[idx]表示第idx个空间的值所指向的的下一个值的索引。idx从零开始递增。</span></span><br><span class="line"><span class="comment">//整体而言可以把e[]看作一个内存池，从这个内存池里面取出边，一个一个赋值，接在h[]后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b;ne[idx]=h[a];h[a]=idx;idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add函数解析：把e的第idx位置存成b，ne[idx]=h[a]表示把原来h[a]指向的索引成为ne的下一个索引，在让h[a]指向idx，idx自增，即可完成插入</span></span><br></pre></td></tr></table></figure>

<h6 id="dfs遍历连通图"><a href="#dfs遍历连通图" class="headerlink" title="dfs遍历连通图"></a>dfs遍历连通图</h6><p>图一般是连通图，若是非连通图，一般只能遍历起点所在的连通分图</p>
<p>算法通常是通过递归实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> if_get[n]=&#123;<span class="literal">false</span>&#125;;<span class="comment">//表示某个点是否被搜索过</span></span><br><span class="line"><span class="comment">//传入u号节点，if_get[u]为true表示遍历过了，然后找到u节点的下一个节点开始dfs，直到每个节点都找到了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    if_get[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">    <span class="type">int</span> j=e[i];</span><br><span class="line">    <span class="keyword">if</span>(!if_get[i])<span class="built_in">bfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历树"><a href="#遍历树" class="headerlink" title="遍历树"></a>遍历树</h4><p>通常为：若是为空则返回，否则递归子树1，子树2….</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLRtraverse</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;T-&gt;data&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">DLRtraverse</span> (T-&gt;lchild);</span><br><span class="line">    <span class="built_in">DLRtraverse</span> (T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>零散小合集</title>
    <url>/2026/02/07/algorithm/%E9%9B%B6%E6%95%A3%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>quicksort快速排序</p>
<p>双指针</p>
<p>1.从待排的数里随便取分界点x，常用两边或中间</p>
<p>2.考虑两个指针i,j分居数两侧，如果指针i指向的数左小于x或右边的j大于x，则向中间走一格。如果i大于x或者j小于x，则停下，等两边停下，交换数。从而保证在x的左边都小于等于x，右边同理</p>
<p>3.由此，一串数通过x划分为左右两串数，对每一串数递归处理即可</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> i=left<span class="number">-1</span>,j=right+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s=q[(left+right)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)<span class="comment">//结束循环意味着i&gt;=j，此时代表完成&#123;</span></span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;s);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;s);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="type">int</span> temp=q[j];</span><br><span class="line">        q[j]=q[i];</span><br><span class="line">        q[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,left,j);</span><br><span class="line">    quick_sort(q,j+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，</p>
<p>1.s应该是q[(left+right)&#x2F;2]这个固定值,而不是left+right)&#x2F;2这个索引，因为虽然s不变，但后面while交换时可能打乱变动q[s]值。</p>
<p>2.建议递归的(q,left,j)不写成(q,left,j-1),因为当排序只有两个，左边指针一来就停止时，右边会到最左边，造成左边的数分串是零，右边跟原来一模一样，造成无限递归。同理,s&#x3D;q[r]时，尽量避开(q,left,j)</p>
<p>即s&#x3D;q[left]或left+right&#x2F;2—-j,j+1;s&#x3D;q[right]或者left+right+1&#x2F;2—-i-1,i。</p>
<p>3.为什么是j,j+1而不是j-1,j?</p>
<p>考虑结束时仅有i&#x3D;j(指向同一个地点)和—-ji—–i在j后面一个，显然划分数串的就是ji中间的缝，对应索引j,j+1或者i-1,i(这里选择ij需要注意2的问题，如果是取中间还是j，毕竟c是向小取整)</p>
<p>mergesort并归排序</p>
<p>这里应用双指针算法</p>
<p>总体思路是不断分割数串，直到小到两个数，再利用递归合并成数串</p>
<p>关键思路是如何把两个排好序得数组合并成大的有序数组</p>
<p>1.对于两串排好序的数列，我们分别在数串两边添加一个指针，如果数串1的值小于数串2，把该值放入一个空数组temp中，数串1指针+1，反之数串2放入空数组，直到某一边到边界停下，这意味着没到边界的数串后面的每一个数都比停下的数串最大的数更大，直接把没到边界的数串后面的数放到temp后面。由此，能把两个排好序的数串整成一个排好序的大数串temp</p>
<p>2.两个数能通过 1 排好，如果只有一个数，不做处理，作为基情况。</p>
<p>3.递归</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(q,left,mid);</span><br><span class="line">    merge_sort(q,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])</span><br><span class="line">            temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++]=q[j++];</span><br><span class="line">    &#125;<span class="comment">//这时可能只有一边完成 需要补刀</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)temp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left,j=<span class="number">0</span>;i&lt;=right;i++,j++)q[i]=temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找</p>
<p>用于查找一段排好序的数列中，指定数的位置</p>
<p>逻辑很简单，判断中间索引的数列值和指定数的大小，不断减小两边区间范围，实现二分逼近</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> a[],<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[middle]&gt;target)right=middle;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[middle]&lt;target)left=middle+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环条件是left&lt;right，跳出循环的时候一定是left&#x3D;&#x3D;right,并且没有触发a[middle]&#x3D;&#x3D;target，说明没有target这个值，返回-1。</p>
<p>如果a[middle]&gt;target,说明target在左边，需要缩小右边，让middle赋值给right。注意&lt;时基本同理，但是应该把middle+1赋值给left，因为left+right&#x2F;2向左边取整，不加一可能造成递归重复数列，无限循环</p>
<p>浮点二分查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">double_search</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="type">double</span> left=<span class="number">0</span>,right=x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right-left&gt;=<span class="number">1e-6</span>)&#123;</span><br><span class="line">    <span class="type">double</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(middle*middle&gt;x)right=middle;</span><br><span class="line">    <span class="keyword">else</span> left=middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无边界问题，简单。这里是平方根的示例</p>
<p>大数 </p>
<p>查看博客三连击</p>
<p>双指针</p>
<p>利用两个变量i,j,以及题目中给出的性质，避免使用ij双层for循环的算法.</p>
<p>例如，考虑一串数，给出数串中不含重复数字的子串的长度最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> maxlength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;check_chong(a,i,j))i++;</span><br><span class="line">        maxlength=max(maxlength,j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxlength+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中双指针实现如上，0&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n,由于每一次i更新后，j的位置不可能相对于上一次j的位置发生后退，因为如果后退，那么上一次j的位置在这个假想的后退后的位置也可以存在。因此每次i更新j不必从零开始，而是优化为从上一次的位置开始，这样ij只需要扫描2n格即可。</p>
<p>下面是完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check_chong</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)b[a[k]<span class="number">-1</span>]++;</span><br><span class="line">    <span class="type">int</span> found=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[k]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            found++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> maxlength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;check_chong(a,i,j))i++;</span><br><span class="line">        maxlength=max(maxlength,j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxlength+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位运算&gt;&gt;常见操作</p>
<p>1.n的二进制表示中第k位是多少n&gt;&gt;k&amp;1</p>
<p>&gt;&gt;位运算符，表示把n的二进制数串往后移k位</p>
<p>&amp;是与运算，&amp;1表示判断奇偶，例如011011&amp;1(即000001),除了最高位其他位都是0所以011011只有0位（011011分别是543210位）的那个1参与有效运算，如果是1，与运算后也是1，对应十进制中的奇数，如果是零，与运算后也是零，对应十进制中的偶数，从而实现判断奇偶。这里用来判断第k位是多少显然也是可以的</p>
<p>2.lowbit：x&amp;-x即x&amp;(~x+1),表示x的第一个1，例如1010000返回10000，1010100返回100。</p>
<p>首先，-x&#x3D;<del>x+1，</del>表示所有位取反。即负数的二进制表示，是找到其正数的二进制数串，每一位取反，最终＋1。如5-00000101，-5-&gt;11111010-&gt;11111011，这样5+-5&#x3D;00000000。</p>
<p>值得注意的是，251和-5比特串都是11111011，如果类型是unsigned ，串的第7位1为符号位，1表示负，从而该串表示-5，如果是signed，则表示251</p>
<p>然后lowbit原理如下，我们假设x的第一个1在k位，那么<del>x的0-k-1位全是1，第k位变成0，</del>x+1（即-x）后，0-k-1位所有1变成0，然后第k位变成1。现在相加，神奇的是，第0-k-1位，x和-x所有都是0，与运算后都是0，k+1位到最后一位全都相反，与运算后也是零，只有第k位是1，从而实现</p>
<p>eg;x:01011110000  ~x:1010001111 -x:1010010000 x&amp;-x：0000010000，输出10000。</p>
<p>离散化</p>
<p>离散化思想是比较少的一堆数要作为下标时，这些数有很大，如果要开数组直接储存这些数的时候，将会占用极大的内存，无法实现，这时考虑到这些数很小，所以把这些数按照大小一一与1，2，3，4等对应，这样内存占用将会极大减小。</p>
<p>530417</p>
<p>kmp</p>
<p>manacher</p>
<p>算法里面的数据结构手搓</p>
<p>链表</p>
<p>用数组模拟链表，常规动态链表比较慢</p>
<p>value[MAXN]存储值</p>
<p>next[MAXN]存储下一个节点的坐标 </p>
<p>idx 当前用到了那个点，用于当作新分配的节点下标</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>零散算法</category>
      </categories>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2026/02/07/algorithm/%E9%9B%B6%E6%95%A3%E7%AE%97%E6%B3%95/hash/</url>
    <content><![CDATA[<p>哈希表（Hash Table，也叫散列表）是一种基于哈希函数的数据结构，用来实现快速的查找、插入和删除操作。</p>
<p>关键思想是，如果我们有很多十分分散的数据，直接储存查找需要大量空间，那么我们不妨使存储位置与存储值之间建立直接关系，从而可以把一堆比较大的数据压缩到一个较小的数据中，这样我们可以很大的压缩空间。</p>
<p>即 <strong>p&#x3D;H(key)</strong> H是散列函数，p是散列地址，key就是储存的关键字</p>
<p>但是一个hash表很有可能遇到”冲突“，即我们不同的关键字，在进行hash(key)压缩后来到了同一个位置，导致无法区分，对此我们常采用开放地址法和链地址法</p>
<h4 id="构造hash"><a href="#构造hash" class="headerlink" title="构造hash"></a>构造hash</h4><p>1.规律：若已知数据的构成都具有某种规律，可根据规律定义hash</p>
<p>2.平方法：把数串平方，取固定的某几位作为映射方式</p>
<p>3.折叠：把数串平均分成几部分，相加，可作为最终hash地址</p>
<p>4.模：H(key)&#x3D;key%x. 最常用的一集</p>
<p><strong>注1：p最好取质数，并离2^n尽量远</strong>，</p>
<p><strong>注2：含负数的模的公式：A%B&#x3D;A-A&#x2F;B*B，有个结论是结果只与A的正负有关</strong> </p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p>1.链地址：我们先进行一次处理如mod(p)得到p个可能的hash地址，然后以这0-p建立p个单链表，分别储存冲突的数字（类比图的储存，一个节点后跟着他到的所有边)</p>
<p>由于”注1“，我们先找到大于hash范围的最小质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_prime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j*j&lt;=x;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">    flag=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>)x+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现find_prime(10000)&#x3D;10007</p>
<p>插入操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10007</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hnum=(number%N+N)%N;<span class="comment">//可处理number是负数的情况，将其映射到正数，如果A是正数就和A%B一样的，如果A是负数等于A%B+B一定是正数</span></span><br><span class="line">e[idx]=number,ne[idx]=h[hnum],h[hnum]=idx,idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hnum=(number%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>零散算法</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>拓扑排序</p>
<p>拓扑序列：一个有向图中，对于任意的边，拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。</p>
<p>可以证明，一个有向无环图一定存在拓扑序列，但不一定唯一</p>
<p>算法：</p>
<p>所有入度为零的点入队，删除该点和所有出边</p>
<p>枚举所有入队的点的指向的点，让其入度减1，若是这些点入度变为零，则入队；若是不为零，不管，直到其他点不断递归到指向它的点，使得入度最终变为零，再入队。</p>
<p>不断重复以上过程，直到集合 𝑆<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="S"> 为空。检查图中是否存在任何边，如果有，那么这个图一定有环路，否则返回 𝐿<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="L">，𝐿<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="L"> 中顶点的顺序就是构造拓扑序列的结果。</p>
<p>首先仍然需要图的储存</p>
<p>其中q代表队列，d代表点的入度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> e[N],ne[N],h[N],idx;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">menset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">add</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">    e[idx]=b;ne[idx]=h[a];h[a]=idx;idx++;</span><br><span class="line">    d[b]++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是toposort</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j=<span class="number">-1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(d[i]==<span class="number">0</span>)q[++j]=i;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=j)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> head=h[q[k]];head!=<span class="number">-1</span>;head=ne[head])&#123;</span><br><span class="line">    <span class="type">int</span> nt=e[head];</span><br><span class="line">    d[nt]--;</span><br><span class="line">    <span class="keyword">if</span>(d[nt]==<span class="number">0</span>)q[++j]=nt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> j==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中，输出topo序列的逻辑</p>
<p>发现我们q[]刚好就是节点的排序，满足前面的节点不依赖于后面的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">toposort</span>())&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cout&lt;&lt;q[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>algorithm</category>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>子集生成</title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h3 id="子集生成"><a href="#子集生成" class="headerlink" title="子集生成"></a>子集生成</h3><p>生成某个整数序列的所有可能子集</p>
<p>下面以从1-n的整数集，无重复数字 举例</p>
<h5 id="增量构造法（递归）"><a href="#增量构造法（递归）" class="headerlink" title="增量构造法（递归）"></a>增量构造法（递归）</h5><p>思路是从第一位开始，对于每一位而言，依次填入这一位后面的所有值，而后面的后面又是这样填，即递归。</p>
<p>若是算法每一步都对，有正确的初始化值，且有终止条件，则可用递归</p>
<p>例如，1 2 3的递归过程用解释树构造如下</p>
<p><img src="file:///D:/Typedown/813127ef-a2ea-447c-ba05-f6b9380c3577.png" alt="813127ef-a2ea-447c-ba05-f6b9380c3577"></p>
<p>a:构造的子集</p>
<p>s:s为当前加入的值，若cur为零，则初始化为1，否则为a[cur-1]的下一个值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_subset</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cur;i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> s=cur?a[cur<span class="number">-1</span>]<span class="number">+1</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=n;i++)&#123;</span><br><span class="line">        a[cur]=i;</span><br><span class="line">        <span class="built_in">print_subset</span>(n,a,cur<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="位向量法-决策树"><a href="#位向量法-决策树" class="headerlink" title="位向量法(决策树)"></a>位向量法(决策树)</h5><p>我们构造一个向量a,a[i]为0或1,a[i]&#x3D;&#x3D;1意味着子集含有i</p>
<p>比如a[4]&#x3D;0,1,1,0;对应子集为2 3.</p>
<p>注意这里递归函数没有for循环限制数量，需要return ；</p>
<p>对于某一位而言，下一位数要么有，要么没有，以此构造递归式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_subset1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i])cout&lt;&lt;i<span class="number">+1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    a[cur]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print_subset1</span>(n,a,cur<span class="number">+1</span>);</span><br><span class="line">    a[cur]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">print_subset1</span>(n,a,cur<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二进制法"><a href="#二进制法" class="headerlink" title="二进制法"></a>二进制法</h5><p>惊讶的发现，我们子集可以看成一个数组，每一位取和不取的集合！将取与不取看成01的话，子集就代表一个二进制串！（和位向量法类似）</p>
<p>先枚举二进制数（就是1-2^n，二进制和十进制没区别），对于每个二进制数，打印出其对应的子集</p>
<p>s&amp;1&lt;&lt;i即s的第i位与上1,判断s的第i位是否为1</p>
<p>很优雅的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);i++)</span><br><span class="line">    <span class="built_in">print_subset2</span>(<span class="number">4</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_subset2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&amp;<span class="number">1</span>&lt;&lt;i)cout&lt;&lt;i<span class="number">+1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>algorithm</category>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>枚举排列</title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/%E6%9E%9A%E4%B8%BE%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="枚举排列"><a href="#枚举排列" class="headerlink" title="枚举排列"></a>枚举排列</h4><p>枚举排列，即列出一个集合的所有排列可能，考虑字典序的话，通常有递归(树深搜)和stl(next_permutation)两种方法</p>
<h5 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation()"></a>next_permutation()</h5><h6 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h6><p>next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)  </p>
<p>first和last是迭代器，一般我们用指针就够了：</p>
<p>next_permutation(p,p+n)</p>
<h6 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h6><p>找出当前序列的<strong>下一个</strong>排列</p>
<h6 id="函数算法"><a href="#函数算法" class="headerlink" title="函数算法"></a>函数算法</h6><p>1.从后向前找到第一个 <strong>升序对</strong>：<code>a[i] &lt; a[i+1]</code>。</p>
<p>2.从后向前找到第一个比 <code>a[i]</code> 大的元素 <code>a[j]</code>，交换 <code>a[i]</code> 和 <code>a[j]</code>。</p>
<p>3.将 <code>a[i+1]</code> 到末尾逆序。</p>
<p>例如，求32154的下一个排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2 1 5 4--1 5第一个升序(i=2)，4比1大(j=4)</span><br><span class="line"></span><br><span class="line">交换--3 2 4 5 1</span><br><span class="line"></span><br><span class="line">逆序--3 2 4 1 5</span><br></pre></td></tr></table></figure>

<h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>输入n个散乱的数</p>
<p>先sort排序，再用next_permutation求下一个排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> p[maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p,p+n);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(p,p+n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归求"><a href="#递归求" class="headerlink" title="递归求"></a>递归求</h5><p>思路是这样，我们从开头固定数字，这样只需要递归的求后面几位的字典序即可</p>
<p>如我们有1 2 3 4，就先固定开头为1，再递归求后面，后面又可以先固定第二位为2，再递归，直到递归完。</p>
<p>算法过程</p>
<p>传入三个变量*n(数组),len数组长,cur已经固定的数的末尾位置</p>
<p>当cur&#x3D;&#x3D;len说明全部固定完成，输出字典序，return，进入上一层递归。</p>
<p>否则我们从数组中所有的数中从小到大选出一个没被用于固定的数，作为当前的值，再递归。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_permutation</span><span class="params">(<span class="type">int</span> *n,<span class="type">int</span> len,<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)std::cout&lt;&lt;n[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">        <span class="type">bool</span> done=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cur;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==n[i])done=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(done)&#123;</span><br><span class="line">        n[cur]=j;</span><br><span class="line">        <span class="built_in">print_permutation</span>(n,len,cur<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 3 1 2</p>
<p>1最小，固定,进入下一层递归</p>
<p>2最小，固定，进入下一层</p>
<p>3最小，固定，进入下一层</p>
<p>cur&#x3D;&#x3D;len,输出1 2 3，return 回固定了 1 2的那一层，此时for循环刚好走到尽头，继续递归到固定1 的那一层，递归前执行到了for(j&#x3D;2,j&lt;3;j++)，所以现在j&#x3D;3，</p>
<p>1 3固定，进入下一层</p>
<p>2固定，进入下一层</p>
<p>cur&#x3D;&#x3D;len,输出1 3 2…以此类推。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>dml</title>
    <url>/2026/02/07/language/oracle/DML/</url>
    <content><![CDATA[<p>dml,操作数据库中的数据（增删改）的语言</p>
<p>主要包括insert，update，delete</p>
<p><strong>注意，DML需要手动commit，否则不会保存。</strong></p>
<p><strong>注意，提交commit后，无法回退</strong></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h6 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h6><p>1.简写方式</p>
<p>列数value数必须一样，除非允许空值，按顺序插入</p>
<p>&#x2F;&#x2F;[]表示可选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name</span><br><span class="line">[(列名<span class="number">1</span>,...列名n)]</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure>

<p>INSERT INTO Websites (name, url, alexa, country) VALUES (‘百度’,’<a href="https://www.baidu.com/','4','CN">https://www.baidu.com/&#39;,&#39;4&#39;,&#39;CN</a>‘);</p>
<h3 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h3><p>注意若无 WHERE 子句，所有的记录都将被更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>基础</title>
    <url>/2026/02/07/algorithm/4.%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/1%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h4><p>1.$\sum_{i&#x3D;1}^{n} A^i &#x3D;\frac {A^{N+1}-1}{A-1}$</p>
<p>当A∈(0,1)，$\sum_{i&#x3D;1}^{n} A^i &lt;&#x3D;\frac {1}{1-A}$</p>
<ol start="2">
<li></li>
</ol>
<p>$\sum _{i&#x3D;1}^N i&#x3D;N(N+1)&#x2F;2$</p>
<p>$\sum _{i&#x3D;1}^N i^2 &#x3D;N(N+1)&#x2F;2$</p>
<p>$\sum _{i&#x3D;1}^N i^k \approx \frac {N^{k+1}}{|k+1|},k\neq-1$</p>
<p>$\sum _{i&#x3D;1}^N {\frac{1}{i}} \approx log_eN$,近似式误差趋近于欧拉常数$\gamma \approx 0.577215$ </p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>最短路</title>
    <url>/2026/02/07/algorithm/5.%E6%90%9C%E7%B4%A2/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p>关于最短路，我们不区分是否有向，无向可以看作特殊的有向，把a-&gt;b和b-&gt;a都写进去</p>
<p><img src="file:///D:/Typedown/7e4cbfdc-0cac-4e78-b02f-6647c7d75a8a.png" alt="7e4cbfdc-0cac-4e78-b02f-6647c7d75a8a"></p>
<p>aw上关于以上几个算法的用途大致分类</p>
<p>多源：起点不确定，可能是任意点</p>
<p>汇点：终点</p>
<h3 id="朴素dijkstra"><a href="#朴素dijkstra" class="headerlink" title="朴素dijkstra"></a>朴素dijkstra</h3><p>求解非负权图上单源最短路径</p>
<p>相比与堆优化版的dijkstra，这个适用于稠密图（堆优化版mlongn在稠密情况下是n^2logn），所以用邻接矩阵来存</p>
<h6 id="松弛操作"><a href="#松弛操作" class="headerlink" title="松弛操作"></a>松弛操作</h6><p> 先说明松弛操作，即当我们发现一条边能够 改善（缩短）源点到某个顶点的当前最短路径估计值 时，就更新这个顶点的最短路径估计值。</p>
<p>if d[v]&gt;d[u]+w(u,v)then update d[v]&#x3D;d[u]+w(u,v)</p>
<p>即某个点a到b再到c的距离小于a到c的距离，就把ac直线距离松弛为a到b再到c</p>
<h6 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h6><p>将结点分成两个集合：已确定最短路长度的点集（记为 𝑆<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="S"> 集合）的和未确定最短路长度的点集（记为 𝑇<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="T"> 集合）。一开始所有的点都属于 𝑇<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="T"> 集合。</p>
<p>1.初始化 𝑑𝑖𝑠(𝑠) &#x3D;0<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="dis(s)&#x3D;0">，其他点的 𝑑𝑖𝑠<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="dis"> 均为 +∞<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="+\infty"></p>
<ol start="2">
<li></li>
</ol>
<p>a.从t里面的点中，计算源点到这些点的距离，最小的那个取出，放到s里面（一定最小，贪心）</p>
<p>b.对刚放入s节点里面的边进行松弛操作（即更新和a中取出的节点有关节点的dist）</p>
<p>3.重复2，直到t为空</p>
<p>时间复杂度：n^2+m</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>首先维护几个结构</p>
<p>n是点数，m是边数，一般来说，n<del>km是稀疏图，m</del>n^2是稠密图</p>
<p>g是邻接矩阵，一般是稠密图在用，g[i][j]表示i指向j的关系，值为零表示没边，为k表示边权为k</p>
<p>dist[k]是k节点到源点的最短距离为dist[k] (未定，可动态变化);</p>
<p>track[k]表示每个点的最短路是否确定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">110</span>,m=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> g[n][n];</span><br><span class="line"><span class="type">int</span> dist[n];</span><br><span class="line"><span class="type">bool</span> track[n];</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算s节点到n节点的最短路,无则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">menset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//注意初始化track所有都是false，初始化track[s]是错的，他会在第一次循环里面自动初始化</span></span><br><span class="line"><span class="comment">//因为如果s==1的时候，t将永远为零</span></span><br><span class="line"><span class="comment">//循环执行n次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//找到最短的节点t</span></span><br><span class="line">    <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!track[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">    t=j;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[t][j])<span class="comment">//可省，因为无路g为零，而dist[j]一定小于dist[t]</span></span><br><span class="line">    dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">    track[t]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>dcl</title>
    <url>/2026/02/07/language/oracle/dcl/</url>
    <content><![CDATA[<p>DCL控制权限 包括GRANT赋予 REVOKE收回</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>ddl</title>
    <url>/2026/02/07/language/oracle/ddl/</url>
    <content><![CDATA[<p>ddl（define)创建修改删除数据库对象</p>
<p>包括create,alter,drop，truncate（类似于delete，但是效率更高，delete是放入回滚段中，truncate无法回滚）</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>oracle体系图示</title>
    <url>/2026/02/07/language/oracle/oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%93%E7%B3%BB.md/</url>
    <content><![CDATA[<img src="file:///C:/Users/mec/Pictures/oracle服务器体系.jpg" title="" alt="oracle服务器体系" data-align="inline">
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>dql</title>
    <url>/2026/02/07/language/oracle/dql/</url>
    <content><![CDATA[<p>dql，query，查询主要是select</p>
<p>查询</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><pre><code>SELECT column1, column2, ...
FROM table_name;

SELECT * FROM table_name;
</code></pre>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>查询当前schema有哪些表</p>
<p>SELECT table_name FROM user_tables;</p>
<h6 id="select-distinct"><a href="#select-distinct" class="headerlink" title="select distinct"></a>select distinct</h6><p>列出column的所有不同值（一个值会且仅会列一次）<br>    SELECT DISTINCT column1, column2, …<br>    FROM table_name;</p>
<h6 id="select-where筛选行"><a href="#select-where筛选行" class="headerlink" title="select where筛选行"></a>select where筛选行</h6><p>查找满足条件的列<br>    SELECT column1, column2, …<br>    FROM table_name<br>    WHERE condition;</p>
<p>where可加的有<strong>运算符 逻辑 特殊</strong></p>
<p>1.运算符&#x3D; &gt; &lt; &gt;&#x3D; ,&lt;&#x3D;, !&#x3D;,&lt;&gt;（或！&#x3D;）</p>
<p>Select * from emp where ename&#x3D;’SMITH’;</p>
<p>2.逻辑 and ，or，not</p>
<p>Select * from emp where sal &gt; 2000 or comm &gt; 500;</p>
<p>select * from emp where not sal &gt; 1500;</p>
<p>3.特殊</p>
<p>空值is null</p>
<p>在什么之间between</p>
<p>在什么之中in</p>
<p>模糊查询like</p>
<p>Select * from emp where comm is null;</p>
<p>Select * from emp where sal between 1500 and 3000;</p>
<p>Select * from emp where sal in (5000,3000,1500);</p>
<p>Select * from emp where ename like ‘M%’;</p>
<p>查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。<strong>%表示多个字值_，下划线表示一个字符</strong></p>
<p><strong>M%</strong> : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。</p>
<p> <strong>%M%</strong> : 表示查询包含M的所有内容。</p>
<p> <strong>%M_</strong> : 表示查询以M在倒数第二位的所有内容</p>
<h6 id="select-order-by"><a href="#select-order-by" class="headerlink" title="select order by"></a>select order by</h6><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。默认升序<br>    SELECT column1, column2, …<br>    FROM table_name<br>    ORDER BY column1, column2, … ASC|DESC;</p>
<p>有多列的话先按1排序，若是相同则按column2排，以此类推</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>oracle表操作</title>
    <url>/2026/02/07/language/oracle/oracle%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-create创建表"><a href="#1-create创建表" class="headerlink" title="1.create创建表"></a>1.create创建表</h4><p>表存放在表空间之下，所以要指定放在那个表空间下，没指定就是默认表空间（一般是user）</p>
<p>查看默认表空间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> default_tablespace <span class="keyword">from</span> user_users;</span><br></pre></td></tr></table></figure>



<p><strong>注意，select一般是从 Oracle 的数据字典视图（DBA__&#x2F;ALL__&#x2F;USER_*）中，  查询数据库对象的元数据（名称、状态、位置、属性等）</strong>，其中前缀dba查整个数据库，all查当前用户 + 被授权对象，user查当前用户自己的对象</p>
<p>创建表：</p>
<p>&#x2F;&#x2F;注意是圆括号<br>    CREATE TABLE books (<br>        book_id NUMBER PRIMARY KEY,&#x2F;&#x2F;主键<br>        title VARCHAR2(100),<br>        price NUMBER(6,2),<br>        publish_date DATE<br>    )<br>    TABLESPACE Spacelib;</p>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表注释</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">table</span> 名字 <span class="keyword">is</span> <span class="string">&#x27;..&#x27;</span>;</span><br><span class="line">列注释</span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">column</span> <span class="keyword">table</span>名.列名 <span class="keyword">is</span> <span class="string">&#x27;..&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>查看注释（不存在表里面，而是存在数据字典里面的)</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看表注释</span><br><span class="line"><span class="keyword">select</span> 表名,comments</span><br><span class="line"><span class="keyword">from</span> user_tab_comments</span><br><span class="line"><span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line">查看列注释</span><br><span class="line"><span class="keyword">select</span> 列名,comments</span><br><span class="line"><span class="keyword">from</span> user_col_comments</span><br><span class="line"><span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><h6 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h6><p>1.char 定长字符类型（未达到指定长度时，自动在末尾用空格补全）；非unicode。<br>2.nchar 定长字符类型（未达到指定长度时，自动在末尾用空格补全）；根据unicode，所有字符都占两个字节。<br>3.<strong>常用</strong>varchar2 变长字符类型（未达到指定长度时，不自动补全空格）；定义时需指定长度；最大为4000字节；非unicode。<br>nvarchar2 变长字符类型（未达到指定长度时，不自动补全空格）；定义时需指定长度；最大为2000字节；根据unicode，所有字符都占两个字节。</p>
<p>long储存大文本，4GB</p>
<p>总而言之，varchar不补全空格，带n表示nation，用两个字节储存（包括英文，这会导致效率下降），更支持多国语言</p>
<h6 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h6><p>1.number(p,s)</p>
<p>p精度，表示包括小数在内的总共<strong>有效位数</strong></p>
<p>s，对于s而言，<strong>正 s 控制小数位，负 s 控制整数位四舍五入精度</strong>。表示小数点后多少位，s为负数就表示数字将被“四舍五入到 10 的 |s| 次幂</p>
<p>例如输入1234567.89 NUMBER(6,-2)–123400</p>
<p><strong>number不指定大小代表number(38)</strong></p>
<p>2.int子类型（int，samllint，decimal..本质都是number）</p>
<p>3.小数 float,binary_float,binary_double</p>
<h6 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h6><p>date 存储 ：长度7字节默认DD-MON-RR</p>
<h6 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h6><p>clob:储存字符，最大存4个G</p>
<p>blog：储存图像声音视频等二进制数据</p>
<h4 id="3-对表的创建删除操作"><a href="#3-对表的创建删除操作" class="headerlink" title="3.对表的创建删除操作"></a>3.对表的创建删除操作</h4><h6 id="1-drop删除"><a href="#1-drop删除" class="headerlink" title="1.drop删除"></a>1.drop删除</h6><p>drop table table_name;</p>
<h6 id="2-desc（describe）查看表结构"><a href="#2-desc（describe）查看表结构" class="headerlink" title="2.desc（describe）查看表结构"></a>2.desc（describe）查看表结构</h6><p>desc table_name;</p>
<h6 id="3-default-赋默认值"><a href="#3-default-赋默认值" class="headerlink" title="3.default 赋默认值"></a>3.default 赋默认值</h6><p>gender char(1) default ‘M’,</p>
<h6 id="4-NOT-NULL"><a href="#4-NOT-NULL" class="headerlink" title="4.NOT NULL"></a>4.NOT NULL</h6><p>gender varchar2(4) NOT NULL</p>
<p>代表该字段必须有有效值</p>
<h4 id="4-ddl-修改表操作"><a href="#4-ddl-修改表操作" class="headerlink" title="4.ddl 修改表操作"></a>4.ddl 修改表操作</h4><h6 id="1-rename-修改表名"><a href="#1-rename-修改表名" class="headerlink" title="1.rename 修改表名"></a>1.rename 修改表名</h6><p>rename old_name to new_name</p>
<h6 id="2-alter-add-增加列"><a href="#2-alter-add-增加列" class="headerlink" title="2.alter add 增加列"></a>2.alter add 增加列</h6><p>alter table table_name add( colume_name type …)</p>
<p>alter table employee add(name number(4))</p>
<h6 id="3-alter-drop-删除列"><a href="#3-alter-drop-删除列" class="headerlink" title="3.alter drop 删除列"></a>3.alter drop 删除列</h6><p>alter table table_name drop(colume_name);</p>
<h6 id="4-alter-modify-修改列"><a href="#4-alter-modify-修改列" class="headerlink" title="4.alter modify 修改列"></a>4.alter modify 修改列</h6><p>alter table table_name modify (colume_name type…)</p>
<h4 id="5-dml-可回退-修改记录"><a href="#5-dml-可回退-修改记录" class="headerlink" title="5.dml(可回退) 修改记录"></a>5.dml(可回退) 修改记录</h4><h6 id="1-insert-into增加记录"><a href="#1-insert-into增加记录" class="headerlink" title="1.insert into增加记录"></a>1.insert into增加记录</h6><p>insert into table_name(colume 1…) values(value 1…);</p>
<h6 id="2-update-set-where修改记录"><a href="#2-update-set-where修改记录" class="headerlink" title="2.update set where修改记录"></a>2.update set where修改记录</h6><p>uptare table_name set colume_name&#x3D;value where condition</p>
<p>update employee set salary&#x3D;1000 where name&#x3D;’bob’;</p>
<h6 id="3-delete-from-where删除"><a href="#3-delete-from-where删除" class="headerlink" title="3.delete from where删除"></a>3.delete from where删除</h6><p>delete from employee where job is null;</p>
<h4 id="6-DML"><a href="#6-DML" class="headerlink" title="6.DML"></a>6.DML</h4><h6 id="1-insert-插入"><a href="#1-insert-插入" class="headerlink" title="1.insert 插入"></a>1.insert 插入</h6><p>insert into table_name(id,name,gender)values(1,a,m);</p>
<h4 id="7-一些语法"><a href="#7-一些语法" class="headerlink" title="7.一些语法"></a>7.一些语法</h4><p>1.<strong>单引号 <code>&#39; &#39;</code></strong> → 用于 <strong>字符串或字符常量</strong>  </p>
<p>INSERT INTO Employee (gender) VALUES (‘F’);</p>
<p><strong>一般情况用单引号</strong></p>
<p><strong>双引号 <code>&quot; &quot;</code></strong> → 用于 <strong>引用标识符（列名、表名）</strong>，可以包含大小写或空格</p>
<p>CREATE TABLE Employee (“Employee Name” VARCHAR2(50));</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>索引对象</title>
    <url>/2026/02/07/language/oracle/%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>什么是数据对象？他是指存储在 <strong>Schema（用户）</strong> 中、由 Oracle 数据字典管理的一切结构化对象。索引就是一种</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>oracle前言</title>
    <url>/2026/02/07/language/oracle/oracle/</url>
    <content><![CDATA[<h2 id="1-题外话"><a href="#1-题外话" class="headerlink" title="1.题外话"></a>1.题外话</h2><h4 id="1a-登录"><a href="#1a-登录" class="headerlink" title="1a.登录"></a>1a.登录</h4><p>在cmd里面输入sqlplus进入sqlplus，提示输入用户名</p>
<p>我们可以输入<code>sqlplus as sysdba</code>登录超级管理员，这条命令将以<code>sys</code>用户的身份登录数据库，并且具备DBA权限。也可以输入其他管理员名</p>
<h6 id="有多个数据库的情况"><a href="#有多个数据库的情况" class="headerlink" title="有多个数据库的情况"></a>有多个数据库的情况</h6><p>输入lsnrctl status，查看所有数据库名字</p>
<p>修改默认数据库set ORACLE_SID&#x3D;lib202409091</p>
<p>（注意不是Lib_2024090914003，这个是数据库名不是系统表示符，应该是lib202409091(输入lsnrctl status，即oracle listener control监听器状态查看)）</p>
<p>然后正常sqlplus登入即可</p>
<p>输入set ORACLE_SID查看默认数据库名（新的cmd不会有ORACLE_SID变量，要设置才有）</p>
<p>（输入sqlplus登陆的是默认数据库）</p>
<p>确认状态 SELECT instance_name FROM v$instance;</p>
<h6 id="不小心创建了CDB数据库"><a href="#不小心创建了CDB数据库" class="headerlink" title="不小心创建了CDB数据库"></a>不小心创建了CDB数据库</h6><p>CDB是可插拔数据库，有个根容器CDB$ROOT,下面有若干数据库，初始默认是（可加）PDB$SEED（模板数据库，不可修改）和ORCLPDB（相当于我们原来的非CDB数据库）</p>
<p>所以想正常使用，只需进入CDBROOT后再进入根下的ORCLPDB即可</p>
<p>show CON_NAME;</p>
<p>show PDBS;</p>
<p>alter session set container&#x3D;orclpdb;</p>
<p>已进入orclpdb</p>
<p>ALTER PLUGGABLE DATABASE OPEN;</p>
<p>打开orclpdb</p>
<p>注意这时候show user是sys</p>
<p>所以我们不妨用easy connect</p>
<p> CONN master&#x2F;123456@localhost:1521&#x2F;ORCLPDB</p>
<p>一步到位</p>
<h6 id="返回cdb"><a href="#返回cdb" class="headerlink" title="返回cdb"></a>返回cdb</h6><p>connect &#x2F;as sysdba</p>
<h6 id="sql-developer登录"><a href="#sql-developer登录" class="headerlink" title="sql developer登录"></a>sql developer登录</h6><p>注：</p>
<p><strong>CDB（容器数据库）</strong>：是根容器，<strong>总是自动打开</strong>。</p>
<p><strong>PDB（可插拔数据库）</strong>：实际存放数据的可插拔容器，<strong>默认不会自动打开</strong>。</p>
<p>首先要打开orclpdb数据库</p>
<p>打开命令行，登录sqlplus as sysdba,输入</p>
<p>alter session set container&#x3D;orclpdb;</p>
<p>切换会话</p>
<p>ALTER PLUGGABLE DATABASE OPEN;</p>
<p>打开当前所在的pdb容器</p>
<p>然后：注意要指明服务器名是orclpdb</p>
<p>这里的用户名就是我们创建的，角色其实就是权限等级，默认就是默认权限等级，可以向下选择</p>
<p><strong>这里的SID是Oracle数据库实例的唯一标识符</strong> 一个实例下面有可能有很多服务。比如我们输入lsnrctl status</p>
<p>节选一段</p>
<p>服务 “orcl” 包含 1 个实例。<br>  实例 “orcl”, 状态 READY, 包含此服务的 1 个处理程序…<br>服务 “orclXDB” 包含 1 个实例。<br>  实例 “orcl”, 状态 READY, 包含此服务的 1 个处理程序…<br>服务 “orclpdb” 包含 1 个实例。<br>  实例 “orcl”, 状态 READY, 包含此服务的 1 个处理程序…<br>命令执行成功</p>
<p>语义相反，实际意思其实就是：</p>
<p>服务<code>orcl</code> → 连接到实例<code>orcl</code>的CDB根容器</p>
<p>服务<code>orclpdb</code> → 连接到同一个实例<code>orcl</code>，但是自动导向到PDB容器</p>
<p>所以我们服务名选择orclpdb（sid和服务名只能选一个，链接方式有优先级冲突，且sid的xe是xe版本，默认实例是xe，而我的是orcl（select instance_name from v$instance;)若用sid则需修改)</p>
<p><img src="file:///C:/Users/mec/Pictures/Typedown/77aa5567-a9f0-4d64-b4e8-c95fce726e81.png" alt="77aa5567-a9f0-4d64-b4e8-c95fce726e81"></p>
<h4 id="1b-创建用户"><a href="#1b-创建用户" class="headerlink" title="1b.创建用户"></a>1b.创建用户</h4><p>我们需要登录具有相关权限的用户，比如sysdba，然后用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> 名字</span><br><span class="line">identified <span class="keyword">by</span> 密码</span><br><span class="line"><span class="keyword">default</span> tablespace 指定的表空间</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user 名字account unlock;</span><br><span class="line">grant dba权限 to user1;</span><br></pre></td></tr></table></figure>



<p><code>create user ...(用户名) identified by ...(密码)</code> 创建用户。比如输入create user user1 identified by 123456</p>
<p>该用户现处于锁定状态，用命令<code>alter user ... account unlock</code> 解锁</p>
<p>后面可以用<code>grant dba to user1</code> 给user1赋予dba权限（最高权限，基本能干任何事）</p>
<h4 id="1c-增加dbf文件"><a href="#1c-增加dbf文件" class="headerlink" title="1c.增加dbf文件"></a>1c.增加dbf文件</h4><p>1.dbf文件是什么？通常来说，一个表空间其实就是很多dbf文件和一些系统文件比如控制文件.ctl等，而这些.dbf文件大部分是数据文件，即表空间的实际储存文件，存储表，索引。小部分是临时文件。</p>
<p>2.为什么增加？当表空间要爆了的时候，且它设置为不会自动扩容（autoextend off）的时候</p>
<p>3.增加后系统怎么使用？</p>
<p>总所周知，Oracle 在表空间中分配空间时，是以 区段为单位的。</p>
<p>所以Oracle 在管理空间时，并不会只往第一个文件写，而是以区段为单位在多个文件之间分配空间。当一个文件中的空闲区段用完后，自动切换到下一个文件继续写入。</p>
<p>这些不需要手动指定放在哪个文件，Oracle 会自动完成</p>
<h6 id="添加dbf文件代码"><a href="#添加dbf文件代码" class="headerlink" title="添加dbf文件代码"></a>添加dbf文件代码</h6><p>查看表空间信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLESPACE_NAME <span class="keyword">FROM</span> DBA_TABLESPACES;</span><br></pre></td></tr></table></figure>

<p>用alter tablespace语句增加</p>
<p>标准语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> TABLESPACE 表空间名</span><br><span class="line"><span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;绝对路径/文件名.dbf&#x27;</span></span><br><span class="line">SIZE <span class="number">100</span>M</span><br><span class="line">AUTOEXTEND <span class="keyword">ON</span> NEXT <span class="number">50</span>M MAXSIZE <span class="number">1</span>G;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看是否添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> file_name <span class="keyword">from</span> dba_data_files;</span><br></pre></td></tr></table></figure>

<h4 id="1d-创建表空间"><a href="#1d-创建表空间" class="headerlink" title="1d.创建表空间"></a>1d.创建表空间</h4><p>本质上就就是在创建文件</p>
<p>语法和创建dbf文件有点像</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLESPACE 表空间名</span><br><span class="line">DATAFILE <span class="string">&#x27;路径/文件名.dbf&#x27;</span></span><br><span class="line">SIZE <span class="number">50</span>M</span><br><span class="line">AUTOEXTEND <span class="keyword">ON</span> NEXT <span class="number">10</span>M达到<span class="number">50</span>后每次增加多少 </span><br><span class="line">MAXSIZE <span class="number">1</span>G最大空间;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><h6 id="退出当前命令"><a href="#退出当前命令" class="headerlink" title="退出当前命令"></a>退出当前命令</h6><p>1.ctrl c</p>
<p>值得注意的是，你连续两次输错命令想退出后，在第二次输入ctrl c不会回到sqlplus，而是直接回到cmd。建议补一个;</p>
<p>2.保证不会运行的情况下，加一个;直接执行，让他报错就行</p>
<h4 id="1-e-逻辑储存"><a href="#1-e-逻辑储存" class="headerlink" title="1.e 逻辑储存"></a>1.e 逻辑储存</h4><p>对于oracle来说，系统会初始创建很多表空间（物理上是很多数据文件），你在某个表空间里面创建一个数据对象（表，索引，回滚）的时候其实是分配了一个段，当你想扩容扩建的时候，分配的基本大小单元就是区，而一个区由数个数据块（最小i&#x2F;o单位）组成。</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>tcl</title>
    <url>/2026/02/07/language/oracle/tcl/</url>
    <content><![CDATA[<p>维护数据一致性，包括commit(提交更改）,rollback（取消更改）,savepoint（设置保存点）</p>
]]></content>
      <categories>
        <category>language</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title>01背包</title>
    <url>/2026/02/05/algorithm/1.dp/%E8%83%8C%E5%8C%85dp.md/01%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>有 𝑛<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="n"> 个物品和一个容量为 𝑊<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="W"> 的背包，每个物品有重量 𝑤𝑖<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="w_{i}"> 和价值 𝑣𝑖<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="v_{i}"> 两种属性，要求选若干物品放入背包，使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p>
<p>每个物体只有取与不取两种可能的状态，即01背包问题</p>
<h5 id="朴素思路"><a href="#朴素思路" class="headerlink" title="朴素思路"></a>朴素思路</h5><p>首先思考这个问题里面的要素，有容量，重量，总重量，其中总重量是要求的，即f( ).</p>
<p>我们考虑dp状态：  𝑓𝑖,𝑗<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="f_{i,j}"> 为在只能放前 𝑖<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="i"> 个物品的情况下，容量为 𝑗<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="j"> 的背包所能达到的最大总价值。</p>
<p>对于这样一个dp状态，我们考虑这样一个划分（转移），每个状态可以划分为第i个物品取或不取的两种子情况，首先，若不取，显然f(i,j)&#x3D;f(i-1,j)，若取，即f(i,j)&#x3D;取第i个物品且要从前i个物品中取。为利用f表示，我们除去第i个物品，最后再加上起价值即可，即f(i,j)&#x3D;f(i-1,j-w[i])+v[i]</p>
<p>得到dp转移方程f(i,j)&#x3D;max(f(i-1,j),f(i-1,j-w[i])+v[i])，也就是说f(i,j)的最大总重量必然能通过i取与不取两条路不断被划分为子问题，以求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> manc=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> w[maxn],v[maxn],f[maxn][maxc];<span class="comment">//全局数组默认为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,cap;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;cap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cap;j++)&#123;</span><br><span class="line">    f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=w[i])f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;f[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="滚动数组优化版"><a href="#滚动数组优化版" class="headerlink" title="滚动数组优化版"></a>滚动数组优化版</h5><p>我们这个f[][]开得很大容易mle，不妨用滚动数组优化。</p>
<p>注意到我们这个状态转移的更新只用到了f[i-1][…],所以我们不妨舍弃第一维，只用一个一维数组fj储存f(i,j)，即每次更新一层即可，前面的i-2层用之则弃，这样滚动地更新。</p>
<p>故新状态转移 <strong>𝑓𝑗&#x3D;max(𝑓𝑗,𝑓𝑗−𝑤[𝑖]+𝑣[𝑖])</strong></p>
<p>之前的核心代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cap;j++)&#123;</span><br><span class="line">    f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=w[i])f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>砍掉f[i][j]&#x3D;f[i-1][j] (恒成立）</p>
<p><strong>调换内层循环顺序（j&#x3D;cap从大递减，否则f[j]&#x3D;max(f[j],f[j-w[i]]+v[i]);将会用到更新后的f[j-w[i]]+v[i]），我们需要的是更新前的</strong></p>
<p>优化为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=cap;j&gt;=w[i];j--)&#123;</span><br><span class="line">    f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>algorithm</category>
        <category>背包dp</category>
      </categories>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2026/02/05/algorithm/6.%E8%B4%AA%E5%BF%83/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>贪心算法指每一步行动总是选取最优的操作，一般使用贪心法的时候，都要确保自己能证明其正确性。</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>贪心算法证明方法：</p>
<ol>
<li>反证法：假设贪心解不是最优，选取一个最优解并找到矛盾</li>
<li>归纳法：先算得出边界情况（例如 𝑛 &#x3D;1<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="n &#x3D; 1">）的最优解 𝐹1<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="F_1">，然后再证明：对于每个 𝑛<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="n">，𝐹𝑛+1<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="F_{n+1}"> 都可以由 𝐹𝑛<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="F_{n}"> 推导出结果。</li>
<li>直接证明：（数学原理）</li>
<li>交换论证：如果交换方案中任意两个元素&#x2F;相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。</li>
</ol>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>最常见的贪心有两种。</p>
<p>1.我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。<br>2.我们每次都取 XXX 中最大&#x2F;小的东西，并更新 XXX。（有时「XXX 中最大&#x2F;小的东西」可以优化，比如用优先队列维护）</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>区间选点<br><a href="https://www.cnblogs.com/hardestnut/articles/19149534">https://www.cnblogs.com/hardestnut/articles/19149534</a></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title>分组背包</title>
    <url>/2026/02/05/algorithm/1.dp/%E8%83%8C%E5%8C%85dp.md/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>有很多组背包，每一组里面只能选一个</p>
<p>我们考虑dp:旨在前i<strong>组</strong> 物品里面，在容量为cap的情况下最大选多少</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">110</span>;<span class="comment">//组数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">21</span>;<span class="comment">//每组最多</span></span><br><span class="line"><span class="type">int</span> s[maxn],v[maxn][maxm],w[maxn][maxm];</span><br><span class="line"><span class="type">int</span> f[maxn*maxm];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,cap;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;cap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=cap;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=w[i][k])f[j]=<span class="built_in">max</span>(f[j],f[j-w[i][k]]+v[i][k]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>algorithm</category>
        <category>背包dp</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2026/02/05/algorithm/1.dp/%E8%83%8C%E5%8C%85dp.md/dp%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>一般来说，dp问题可以从状态表示f[i][j]和状态计算两个角度来思考</p>
]]></content>
  </entry>
  <entry>
    <title>完全背包</title>
    <url>/2026/02/05/algorithm/1.dp/%E8%83%8C%E5%8C%85dp.md/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p>
<p>和01背包一样，我们仍然考虑f[i][j]为前i个物品，总体积不大于j的选法的max。</p>
<p>朴素思路(慢的一比，n^3)：考虑状态转移方程f[i][j]为第i个物品选择0，1，2，…..k个（总有一个k，因为背包容量是有限的）共k+1个状态因此f[i][j]&#x3D;f[i-1][j]+f[i-1][j-w[i]]+v[i]+….因此里面还要增加一层循环去便利这k个状态，所以复杂度来到n^3</p>
<p>优化版</p>
<p>我们考虑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-w[i]]+v[i],f[i<span class="number">-1</span>][j<span class="number">-2</span>w[i]]<span class="number">+2</span>v[i],...)<span class="number">1</span>式</span><br></pre></td></tr></table></figure>

<p>再考虑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j-w[i]]=       <span class="built_in">max</span>(f[i<span class="number">-1</span>][j-w[i]],f[i<span class="number">-1</span>][j-w[i]-w[i]]+v[i],...)<span class="number">2</span>式</span><br></pre></td></tr></table></figure>

<p>我们发现，1式的后面n-1项刚好等于1式+v[i]，所以这里我们“错位相减”</p>
<p>得 <strong>f[i][j]&#x3D;max(f[i-1][j],f[i][j-w[i]]+v[i])</strong> </p>
<p>省略一维进一步得 <strong>f[j]&#x3D;max(f[j],f[j-w[i]]+v[i])</strong></p>
<p>实际上可以这样思考，我们f(j)是从f(j-w),f(j-2w),f(j-3w)…优化过来的，但是我们之前f(j-w)得优化已经包含了f(j-2w),f(j-3w)…等，所以可以直接从f(j-w)优化</p>
<p>值得注意的是，<strong>我们第二层for循环不必像01背包那样逆着来</strong>，因为我们状态转移方程里面第二个f[i][j-w]+v就是需要这一层的（01背包是f[i-1][j-w[i]]+v[i]])，逻辑刚好</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=cap;j++)&#123;</span><br><span class="line">    f[j]=std::<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>背包dp</category>
      </categories>
  </entry>
  <entry>
    <title>多重背包</title>
    <url>/2026/02/05/algorithm/1.dp/%E8%83%8C%E5%8C%85dp.md/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 𝑘𝑖<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="k_i"> 个，而非一个。</p>
<p>（我们尝试用完全背包的思路优化，发现失败。因为多重背包数量是有限的，假设我们背包空间十分大，把ki个物品全部取完，就会导致f[j]和f[j-w[i]]两个都能取完所有的ki物品，和完全背包是不一致的）</p>
<p>所以我们回归到01背包问题，朴素思路，将k个物品看成k个不一样的，时间复杂度（∑s[i]*cap*n)</p>
<p>利用二进制优化：</p>
<p>我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 𝐴𝑖,1,𝐴𝑖,2<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="A_{i,1},A_{i,2}">」与「同时选 𝐴𝑖,2,𝐴𝑖,3<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" title="A_{i,2},A_{i,3}">」这两个完全等效的情况。</p>
<p>我们尝试将物品捆绑为1,2,4,8…2^k,cap-(2^(k+1)-1),这样你选取任意数量的物品，都能从这些二进制数里面组合得到。（比如你选10个—2和8）同时可以证明，在2^k和cap之间的部分，也不存在遗漏，都有组成方案。</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv=<span class="number">10010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2000</span>;</span><br><span class="line"><span class="type">int</span> f[maxv];</span><br><span class="line"><span class="type">int</span> v[maxn],w[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,cap;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;cap;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>,a,b,s;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">        <span class="keyword">while</span>(s&gt;=cnt)&#123;</span><br><span class="line">            index++;</span><br><span class="line">            v[index]=cnt*a;</span><br><span class="line">            w[index]=cnt*b;</span><br><span class="line">            s-=cnt;</span><br><span class="line">            cnt*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        v[index]=s*a;</span><br><span class="line">        w[index]=s*b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=index;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=cap;j&gt;=w[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">    cout&lt;&lt;f[cap]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码细节：</p>
<p>1.一次for循环是在初始化那k个数的捆绑，我们不知道一共扩展为多少个物品，所以我们需要一个全局变量index去记录第几个物品。</p>
<p>2.我们v[],w[]都是从1开始的</p>
<p>3.cnt代表当前第index个物品由多少个物品捆绑成。</p>
<p>4.while循环后那一步是在让剩余的物品当作一捆</p>
<p>5.我们while循环s&gt;&#x3D;cnt可以，代表剩余的量必须大于等于当前捆绑的数量，否则停止，并让剩余的量凑作一捆。当s&#x3D;cnt时，代表整个数列刚好为一个等比（s-∑cnt&#x3D;2^(k+1))，此时继续循环，下一次s被减为0，这种情况会被if(s&gt;0)排除在外，因为s&#x3D;0，已经初始化完了</p>
<p>6.当然，也可以while(s&gt;cnt)，这时候不需要if(s&gt;0)</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>背包dp</category>
      </categories>
  </entry>
  <entry>
    <title>第三章</title>
    <url>/2026/02/07/note/csapp/3.%E6%B1%87%E7%BC%96/%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>1.反汇编</p>
<p>objdump -d name.o</p>
]]></content>
      <categories>
        <category>note</category>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title>csapp</title>
    <url>/2026/02/07/note/csapp/7.%E9%93%BE%E6%8E%A5/2.%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>目标文件分为可重定位目标文件，可执行目标文件，共享目标文件（动态链接）</p>
<p>对于目标文件而言，每个系统的都不一样，windows是PE格式，linux是ELF格式</p>
<p>对于linux的ELF目标文件，通常分为ELF头，.text,.rodate,.data等数个节（在可执行文件加载到内存里则称之为段），以及最后的节头部表</p>
<p>elf头描述系统子，大端还是小端，elf头大小，机器类型等等</p>
<p>对于节，每个节都有不同的作用，例如.text储存已编译的机器代码，.rodata储存只读数据等</p>
<p>而节头部表记录了 ELF 文件中每一个节的位置、大小、类型和属性</p>
<p>命令:readelf -h main.o能查看main.o的elfheader</p>
<p>readelf -S main.o 查看main.o 的section header</p>
]]></content>
      <categories>
        <category>note</category>
        <category>csapp</category>
      </categories>
  </entry>
  <entry>
    <title>第七章1</title>
    <url>/2026/02/07/note/csapp/7.%E9%93%BE%E6%8E%A5/1.%E6%80%BB%E4%BD%93%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>源代码–(预处理)–main.i–(编译处理)–main.s–(汇编)–main.o–linked–可执行文件</p>
<p>1.预处理（c preprocessor，cpp）命令：</p>
<p>cpp  main.c -o main.i</p>
<p>or</p>
<p>gcc -E -o main.i main.c  (-E告诉处理器只弄到main.i)</p>
<p>2.编译（c compiler）命令：（大写！！）</p>
<p>cc -S -o main.s main.c</p>
<p>or  </p>
<p>gcc -S -o main.s main.c</p>
<p>3.汇编 （assembler）</p>
<p>as -o main.o main.c</p>
<p>4.链接</p>
<p>手动： ld -static -o prog main.o sum.o &#x2F;usr&#x2F;lib&#x2F;…..o(有六七个系统带的.o文件作为启动等功能，缺的话无法运行)</p>
]]></content>
      <categories>
        <category>note</category>
        <category>csapp</category>
      </categories>
  </entry>
</search>
