{"posts":[{"title":"","text":"12：16 概率论及其作业 oracle学习 机组学习 python和小车学习 上午下午各选两个。晚上刷一道题后可以玩 12：20开始复习软工 12：25 软工考试 12：25开始要着重复习oracle和机组，建议多学机组 12：29 oracle考试 12：30计组考试 准备python小车代码了要 概率论复习 1：5概率考试 小车 答辩 算法学习 看csapp，做project和lab 看完csapp看计网 看样子学一点java或者python 顺便把编译器实验做了 重新学下微积分 3：6寒假结束","link":"/2025/12/09/-!-DDL-!-/"},{"title":"","text":"ChatGPT 回答风格规范（技术向）一、总体原则以技术准确性与工程严谨性为最高优先级；若涉及不确定的知识、结论或工程应用前提，必须明确标注不确定性或适用条件。 回答风格偏向理工科 / 计算机专业语境，避免口语化表达。 不进行无关寒暄，不使用表情符号，不做情绪化评价。二、回答结构规范结论优先：若问题存在明确答案或判断，先给出严谨结论；再补充通俗解释（无需比喻）和必要的推导。 格式要求：尽量少用 Markdown 结构符号；标题不强制加粗，列表可使用自然分段表达。仅在以下情形使用 Markdown： 极少量关键术语强调 代码必须使用代码块 数学符号可使用 LaTeX不同观点或层次使用普通文本分段。 层次清晰：使用编号或自然标题；一问一答，不发散。 信息密度优先：避免空泛描述；每一段都应承载实质信息。三、内容深度要求技术问题默认采用偏底层 / 原理级解释。 概念复杂度处理规则： 若概念属于工科或计算机领域较复杂、难以直观理解，则直接严格按照原规范解释：严谨结论 → 通俗解释 → 代码示例 → 性质/用途/作用 → 工程影响 → 下钻层面 → 询问是否继续深入 若概念较简单，可用一段话和一个例子直接解释清楚，解释完询问用户是否需要完整严格解释；若用户要求，则严格执行上述完整流程 介绍抽象概念时，遵循以下顺序： 先给出严谨结论 给出通俗解释（无需比喻） 提供至少一个完整正确的代码示例；可根据概念特点拓展出其他示例，代码长度不限，正确性优先于简短 说明概念性质、用法、作用和必要性 讨论可能的工程层面影响或特性 结束后询问用户是否需要进一步下钻 下钻按层次逐步推进：运行期层面 → 编译期层面 → 体系结构 / 机器层面。 必要时涉及： 数据结构不变式 体系结构或标准定义 不因“可能看不懂”而主动简化内容。四、代码与示例规范代码优先确保正确，然后解释清楚；长度不限。示例代码应： 最小化但可覆盖概念核心 可根据抽象特性拓展出其他示例 若为对比说明，明确指出差异与结论 五、题型特殊约定选择题：直接给出答案，不提供解析。 概念性提问：给出严格定义，必要时提供反例。 是 / 否问题：先明确回答“是”或“否”，再说明成立条件或例外。六、语言与术语中文为主；关键术语在首次出现时保留英文原名。不进行中英混写式解释性废话。统一使用学术界或工程实践中通行的术语与表述。七、不应出现的内容无前提支撑的不确定性模糊表述（如“可能”“大概”“一般来说”）。与问题无关的类比、故事性描述或泛泛而谈。重复用户已明确掌握的基础知识。八、优先级说明本规范在本对话及后续对话中：高于默认回答风格；低于用户在单次提问中明确指定的特殊要求。 —— 本文档可随时增补或修订 ——","link":"/2026/02/03/gpt/"},{"title":"","text":"哈希表（Hash Table，也叫散列表）是一种基于哈希函数的数据结构，用来实现快速的查找、插入和删除操作。 关键思想是，如果我们有很多十分分散的数据，直接储存查找需要大量空间，那么我们不妨使存储位置与存储值之间建立直接关系，从而可以把一堆比较大的数据压缩到一个较小的数据中，这样我们可以很大的压缩空间。 即 p=H(key) H是散列函数，p是散列地址，key就是储存的关键字 但是一个hash表很有可能遇到”冲突“，即我们不同的关键字，在进行hash(key)压缩后来到了同一个位置，导致无法区分，对此我们常采用开放地址法和链地址法 构造hash1.规律：若已知数据的构成都具有某种规律，可根据规律定义hash 2.平方法：把数串平方，取固定的某几位作为映射方式 3.折叠：把数串平均分成几部分，相加，可作为最终hash地址 4.模：H(key)=key%x. 最常用的一集 注1：p最好取质数，并离2^n尽量远， 注2：含负数的模的公式：A%B=A-A/B*B，有个结论是结果只与A的正负有关 冲突处理1.链地址：我们先进行一次处理如mod(p)得到p个可能的hash地址，然后以这0-p建立p个单链表，分别储存冲突的数字（类比图的储存，一个节点后跟着他到的所有边) 由于”注1“，我们先找到大于hash范围的最小质数 1234567891011121314int find_prime(int x){ if(x&lt;=2)return 2; while(1){ bool flag=1; for(int j=2;j*j&lt;=x;j++){ if(x%j==0){ flag=0;break;}} if(flag)return x; if(x%2)x+=2; else x++;}} 我们发现find_prime(10000)=10007 插入操作： 123456const int N=10007;int h[N],e[N],ne[N],idx;void insert(int number){ int hnum=(number%N+N)%N;//可处理number是负数的情况，将其映射到正数，如果A是正数就和A%B一样的，如果A是负数等于A%B+B一定是正数e[idx]=number,ne[idx]=h[hnum],h[hnum]=idx,idx++;} 查找操作 1234bool find(int number){ int hnum=(number%N+N)%N; for(int i=)}","link":"/2025/08/26/hash/"},{"title":"","text":"","link":"/2025/11/12/shell/"},{"title":"","text":"头文件保护#ifndef NAME_H #define NAME_H 内容 #endif 为什么要保护？ 如果a.c包含a.h,b.h，而b.h里面又包含了a.h，就会导致声明重复展开导致错误 保护什么？ 函数声明 包含的头文件 类型 宏等 注意不要保护定义。比如int 和函数实现。 因为a.c,b.c都展开了int abc,链接之后abc就是多重定义了 int可代替为static 或 extern。其中static很易错，因为他是只给a.c这个程序单独可见，很容易出bug extern 是全局声明，给编译器说我已经有这个变量了，让他不要报错，extern声明的变量就可以在链接后的总代码中唯一使用","link":"/2026/01/12/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E5%92%8C%E8%A7%84%E8%8C%83%E6%9D%82%E8%B0%88/"},{"title":"","text":"quicksort快速排序 双指针 1.从待排的数里随便取分界点x，常用两边或中间 2.考虑两个指针i,j分居数两侧，如果指针i指向的数左小于x或右边的j大于x，则向中间走一格。如果i大于x或者j小于x，则停下，等两边停下，交换数。从而保证在x的左边都小于等于x，右边同理 3.由此，一串数通过x划分为左右两串数，对每一串数递归处理即可 代码实现 12345678910111213141516void quick_sort(int q[],int left,int right){ if(left==right)return ; int i=left-1,j=right+1; int s=q[(left+right)/2]; while(i&lt;j)//结束循环意味着i&gt;=j，此时代表完成{ do i++;while(q[i]&lt;s); do j--;while(q[j]&gt;s); if(i&lt;j){ int temp=q[j]; q[j]=q[i]; q[i]=temp; } } quick_sort(q,left,j); quick_sort(q,j+1,right);} 需要注意， 1.s应该是q[(left+right)/2]这个固定值,而不是left+right)/2这个索引，因为虽然s不变，但后面while交换时可能打乱变动q[s]值。 2.建议递归的(q,left,j)不写成(q,left,j-1),因为当排序只有两个，左边指针一来就停止时，右边会到最左边，造成左边的数分串是零，右边跟原来一模一样，造成无限递归。同理,s=q[r]时，尽量避开(q,left,j) 即s=q[left]或left+right/2—-j,j+1;s=q[right]或者left+right+1/2—-i-1,i。 3.为什么是j,j+1而不是j-1,j? 考虑结束时仅有i=j(指向同一个地点)和—-ji—–i在j后面一个，显然划分数串的就是ji中间的缝，对应索引j,j+1或者i-1,i(这里选择ij需要注意2的问题，如果是取中间还是j，毕竟c是向小取整) mergesort并归排序 这里应用双指针算法 总体思路是不断分割数串，直到小到两个数，再利用递归合并成数串 关键思路是如何把两个排好序得数组合并成大的有序数组 1.对于两串排好序的数列，我们分别在数串两边添加一个指针，如果数串1的值小于数串2，把该值放入一个空数组temp中，数串1指针+1，反之数串2放入空数组，直到某一边到边界停下，这意味着没到边界的数串后面的每一个数都比停下的数串最大的数更大，直接把没到边界的数串后面的数放到temp后面。由此，能把两个排好序的数串整成一个排好序的大数串temp 2.两个数能通过 1 排好，如果只有一个数，不做处理，作为基情况。 3.递归 代码实现 1234567891011121314151617int temp[MAXN];void merge_sort(int q[],int left,int right){ if(left==right)return ; int mid=(left+right)/2; merge_sort(q,left,mid); merge_sort(q,mid+1,right); int i=left,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=right){ if(q[i]&lt;=q[j]) temp[k++]=q[i++]; else temp[k++]=q[j++]; }//这时可能只有一边完成 需要补刀 while(i&lt;=mid)temp[k++]=q[i++]; while(j&lt;=right)temp[k++]=q[j++]; for(int i=left,j=0;i&lt;=right;i++,j++)q[i]=temp[j];} 二分查找 用于查找一段排好序的数列中，指定数的位置 逻辑很简单，判断中间索引的数列值和指定数的大小，不断减小两边区间范围，实现二分逼近 123456789int bsearch(int left,int right,int a[],int target){ while(left&lt;right){ int middle=(left+right)/2; if(a[middle]&gt;target)right=middle; else if(a[middle]&lt;target)left=middle+1; else return middle; } return -1;} 循环条件是left&lt;right，跳出循环的时候一定是left==right,并且没有触发a[middle]==target，说明没有target这个值，返回-1。 如果a[middle]&gt;target,说明target在左边，需要缩小右边，让middle赋值给right。注意&lt;时基本同理，但是应该把middle+1赋值给left，因为left+right/2向左边取整，不加一可能造成递归重复数列，无限循环 浮点二分查找 12345678910double double_search(double x){ double left=0,right=x; while(right-left&gt;=1e-6){ double middle=(left+right)/2; if(middle*middle&gt;x)right=middle; else left=middle;}return left;} 无边界问题，简单。这里是平方根的示例 大数 查看博客三连击 双指针 利用两个变量i,j,以及题目中给出的性质，避免使用ij双层for循环的算法. 例如，考虑一串数，给出数串中不含重复数字的子串的长度最大值 123456789101112int main(){ int n; scanf(&quot;%d&quot;,&amp;n); int a[n]; for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); int maxlength=0; for(int i=0,j=0;j&lt;n;j++){ while(i&lt;j&amp;&amp;check_chong(a,i,j))i++; maxlength=max(maxlength,j-i); } printf(&quot;%d&quot;,maxlength+1);} main函数中双指针实现如上，0&lt;=i&lt;=j&lt;=n,由于每一次i更新后，j的位置不可能相对于上一次j的位置发生后退，因为如果后退，那么上一次j的位置在这个假想的后退后的位置也可以存在。因此每次i更新j不必从零开始，而是优化为从上一次的位置开始，这样ij只需要扫描2n格即可。 下面是完整代码 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int max(int a,int b){ return a&gt;b?a:b;}int check_chong(int* a,int i,int j){ if(i==j){ return 0; } int b[9]={0}; for(int k=i;k&lt;=j;k++)b[a[k]-1]++; int found=0; for(int k=0;k&lt;9;k++){ if(b[k]&gt;1){ found++; break; } } return found;}int main(){ int n; scanf(&quot;%d&quot;,&amp;n); int a[n]; for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); int maxlength=0; for(int i=0,j=0;j&lt;n;j++){ while(i&lt;j&amp;&amp;check_chong(a,i,j))i++; maxlength=max(maxlength,j-i); } printf(&quot;%d&quot;,maxlength+1);} 位运算&gt;&gt;常见操作 1.n的二进制表示中第k位是多少n&gt;&gt;k&amp;1 &gt;&gt;位运算符，表示把n的二进制数串往后移k位 &amp;是与运算，&amp;1表示判断奇偶，例如011011&amp;1(即000001),除了最高位其他位都是0所以011011只有0位（011011分别是543210位）的那个1参与有效运算，如果是1，与运算后也是1，对应十进制中的奇数，如果是零，与运算后也是零，对应十进制中的偶数，从而实现判断奇偶。这里用来判断第k位是多少显然也是可以的 2.lowbit：x&amp;-x即x&amp;(~x+1),表示x的第一个1，例如1010000返回10000，1010100返回100。 首先，-x=x+1，表示所有位取反。即负数的二进制表示，是找到其正数的二进制数串，每一位取反，最终＋1。如5-00000101，-5-&gt;11111010-&gt;11111011，这样5+-5=00000000。 值得注意的是，251和-5比特串都是11111011，如果类型是unsigned ，串的第7位1为符号位，1表示负，从而该串表示-5，如果是signed，则表示251 然后lowbit原理如下，我们假设x的第一个1在k位，那么x的0-k-1位全是1，第k位变成0，x+1（即-x）后，0-k-1位所有1变成0，然后第k位变成1。现在相加，神奇的是，第0-k-1位，x和-x所有都是0，与运算后都是0，k+1位到最后一位全都相反，与运算后也是零，只有第k位是1，从而实现 eg;x:01011110000 ~x:1010001111 -x:1010010000 x&amp;-x：0000010000，输出10000。 离散化 离散化思想是比较少的一堆数要作为下标时，这些数有很大，如果要开数组直接储存这些数的时候，将会占用极大的内存，无法实现，这时考虑到这些数很小，所以把这些数按照大小一一与1，2，3，4等对应，这样内存占用将会极大减小。 530417 kmp manacher 算法里面的数据结构手搓 链表 用数组模拟链表，常规动态链表比较慢 value[MAXN]存储值 next[MAXN]存储下一个节点的坐标 idx 当前用到了那个点，用于当作新分配的节点下标","link":"/2025/04/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"","text":"贪心贪心算法指每一步行动总是选取最优的操作，一般使用贪心法的时候，都要确保自己能证明其正确性。 证明贪心算法证明方法： 反证法：假设贪心解不是最优，选取一个最优解并找到矛盾 归纳法：先算得出边界情况（例如 𝑛 =1）的最优解 𝐹1，然后再证明：对于每个 𝑛，𝐹𝑛+1 都可以由 𝐹𝑛 推导出结果。 直接证明：（数学原理） 交换论证：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。 类型最常见的贪心有两种。 1.我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。2.我们每次都取 XXX 中最大/小的东西，并更新 XXX。（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护） 例区间选点https://www.cnblogs.com/hardestnut/articles/19149534","link":"/2025/10/13/%E8%B4%AA%E5%BF%83/"},{"title":"","text":"搜点的预瞄 育苗习惯 阅读，反应 哨位不要怕，大胆！直接摸，想清楚做什么，注意控图 看队友位置，做好搜点，直接踩出去 不要怕补枪，协同 听动静，打近的 // 预瞄跑图，每天一张 压枪三十次 急停摆设三十次 侧面和中等五组（侧面靶是真有用） 冰墙peek练提前抢 冰墙远距离练大啦一颗 正面移动靶3组 甩狙 三把死斗 yay和六目标和micro三组","link":"/2025/12/09/%E9%97%AE%E9%A2%98/"},{"title":"","text":"什么是DAG，即有向无环图，有些","link":"/2026/01/14/1.dp/DAG-dp/"},{"title":"","text":"","link":"/2025/12/02/1.dp/%E7%BA%BF%E6%80%A7dp/"},{"title":"","text":"对于图的储存而言，算法上一般用邻接表和邻接矩阵两种方法 邻接矩阵使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 𝑢 到 𝑣 的边，为 0 表示不存在．如果是带边权的图，可以在 adj[u][v] 中存储 𝑢 到 𝑣 的边的边权． //u-&gt;v adj[u][v]=1; 注意不能有重边，优点是查某边很快，缺点是稀疏图效率低 邻接表一般情况下，都用邻接表方法储存图 实现方法有很多，有vector，指针 链表（理论），链式前向星（数组+链式索引），我们采用链式索引 定义head[a]储存a指向的边的信息 e[i]为索引i所对应的点 ne[i]为索引i的下一个索引 idx为目前储存的边数 我们储存a-&gt;b,a-&gt;c两条边如图所示 先储存a-&gt;c,分配idx2=1，然后e[idx2]代表a指向的c 后面插入a-&gt;b,分配idx1=2，然后e[idx1]=b代表a-&gt;b,然后让ne[idx1]=head[a]即idx2。两个边就建好了 1234567const int n=x+10,m=2*y+10;//我们假设有x个节点，y条无向边（一般题目会给）//2*y表明无向边可以看成两条特殊的有向边int h[n],e[m],ne[m],idx;void add(int a,int b){ e[idx]=b;ne[idx]=h[a];h[a]=idx;idx++;} h[i]表示第i个节点的头节点，后面接入i节点指向的所有节点的idx索引，无顺序之分。e[idx]表示第idx个空间分配的值，ne[idx]表示第idx个空间的值所指向的的下一个值的索引。idx从零开始递增。 整体而言可以把e[]看作一个内存池，从这个内存池里面取出边，一个一个赋值，接在h[]后面 add函数是把e的第idx位置存成b，ne[idx]=h[a]表示把原来h[a]指向的索引成为ne的下一个索引，在让h[a]指向idx，idx自增，即可完成插入","link":"/2026/01/19/2.%E5%9B%BE/%E5%9B%BE%E5%82%A8%E5%AD%98/"},{"title":"","text":"1.class语法123456789101112class Name{ public: int a; int getB(){return b;} private: int b; int func2(); protected: int c; int func3(){/**/}};int Name::func2(){} public 可被其他程序使用，private只能被当前类的函数使用，protected只能被当前类的函数，和继承类使用. 我们常把数据设置为私有的或保护的，需要数据时调用public的函数获得数据即可，就不需要暴露数据的来去,例如getB 类函数1.函数写法 内联：函数实现直接写在class里面,比如func3 外联：函数定义在class内，实现在class外，比如func2(注意语法ClassName::func2) 构造函数1.默认构造函数 ClassName(){} 若无任何构造函数会自动生成默认构造函数，当自定义了构造函数将不会生成默认构造函数。 注意构造函数不会对POD类型（c原有的类型，int…）进行初始化 2.初始化列表（就是构造函数的简写方式） int a;double b; ClassName():a(0),b(114.514){} 3.单参数的构造函数最最最好加上explicit（能避免隐式转换） 12345678910111213class MyClass(){public: MyClass(int a){}};int main(){ MyClass class1=10;} 上面那个构造是正确的，因为有隐式转换：编译器看到10（int）赋值给class1（MyClass类）会寻找转换方式，即从int到MyClass的构造函数，从而发生以下 int num=10; MyClass temp(10); MyClass class1=temp; 常量成员函数只检测，不改变对象为访问函数，如isEmpty() 改变对象为修改函数，如makeEmpty() 所有函数默认为修改函数，要使函数为访问函数需要用const : void makeEmpty( ) const { } 一个函数为常量成员函数，那么他只能使用其他的const函数，只能修改mutable变量 对象声明IntCell obj1 √，默认构造 IntCell obj1(1) √，int参数构造 IntCell obj2=1×(若是构造函数用Explicit修饰是错的，若没用他修饰，则是对的！默认转换) IntCell obj2()×会误以为是函数声明，返回值是IntCell 甚至可以用指针 IntCell *m; m=new IntCell(0); m-&gt;write(5); delete m;","link":"/2026/01/20/3.stl/1.cpp%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"},{"title":"","text":"函数模板函数模板是一个用于产生函数的公式。 语法： template &lt;typename T&gt; +函数声明 所以template和函数声明可以分为两行写，中间不能有其他语句。 (和template&lt;class T&gt;完全等价) 然后把想泛化的类型换成T即可 1234template &lt;typename T&gt;T max(T a,T b){ return a&gt;b?a:b;}","link":"/2026/01/31/3.stl/4.%E6%A8%A1%E6%9D%BF/"},{"title":"","text":"vector#include&lt;vector&gt; vector 的数据储存在堆空间中，不会爆栈。一般情况 vector 可以替换掉普通数组。 注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销 声明vector&lt;类型&gt; arr(长度，[初值]) 括号及里面的内容可省，默认构造函数 1234567vector&lt;int&gt; arr; // 构造int数组 vector&lt;int&gt; arr(100); // 构造初始长100的int数组 vector&lt;int&gt; arr(100, 1); // 构造初始长100的int数组，初值为1 vector&lt;vector&lt;int&gt;&gt; dp(100, vector&lt;int&gt; ()); // 构造初始100行，不指定列数的二维数组 vector&lt;vector&lt;int&gt;&gt; dp(100, vector&lt;int&gt; (200, -1)) // 构造初始100行，初始200列的二维数组，初值为-1vector&lt;int&gt; arr[100],没初始化的二维数组，有100个元素，每一个arr[i]都是一个vector，相当行数不变，列数不定的二维数组arr[i].push_back; 注意，vector创建完后，可以当作普通数组用，如 vector&lt;int&gt; arr(100) 创建100个长度的可变长数组–&gt;arr[0]=1; 尾增尾删push_back(),pop_back() .push_back(元素)：在 vector 的最后一个内存后增加一格内存，并给这个内存赋值，数组长度+1(!) .pop_back()：删除 vector 的最后一格内存及其元素，数组长度-1 arr.push_back(100); arr.pop_back(); arr={0,0,0,0},arr.push_back(9)–&gt;arr={0,0,0,0,9} 获取长度.size()获取当前 vector 的长度 注意返回值是无符号整数size_t o(1)复杂度 清空.clear()arr.clear(); o(n)复杂度 判空 .empty()如果是空返回 true 反之返回 false. 时间复杂度：o(1) 改变长度.resize(新长度, [默认值]) 修改 vector 的长度 如果是缩短，则删除多余的值 如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变） 时间复杂度：o(n) stringstd::string是cpp的一种类，可以存储任意长度的文本内容，长度可以动态改变。可以通过下标访问字符，或者使用成员函数修改字符串内容，而不必手动管理内存。 声明：std::string str; 初始化：std::string s=”hello world” 可通过+增加字符std::string s = “Hello”;s += “ World”; 1.访问元素可以通过s[i]或者s.at(i), 两者都可以修改原string串内容 s[i]无越界检查，但更高效，s.at(i)会检查越界 2.方法.数组长度 s.length()或者s.size() 是否为空 s.empty() 追加字符 s.append() 插入 s.insert(pos,str) 删除 s.erase(pos,len) 清空 s.clear() 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;int main() { std::string s = &quot;Hello&quot;; s += &quot; World&quot;; // 动态扩展 s.insert(5, &quot;,&quot;); // 在指定位置插入字符 std::cout &lt;&lt; s &lt;&lt; std::endl; // 输出: Hello, World std::cout &lt;&lt; s[0] &lt;&lt; std::endl; // 随机访问字符: H return 0;}","link":"/2026/01/25/3.stl/2.vector%E5%92%8Cstring/"},{"title":"","text":"参数传递一般来说，c++常见几种参数传递 1.一般值（int ，double，对象） 2.引址调用 int &amp; 3.常数引用调用const int &amp; 4.（cpp里面少用)裸指针","link":"/2026/01/28/3.stl/3.%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"title":"","text":"算法algorithm容器containervector#include&lt;vector&gt; vector 的数据储存在堆空间中，不会爆栈。一般情况 vector 可以替换掉普通数组。 注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销 声明vector&lt;类型&gt; arr(长度，[初值]) 括号及里面的内容可省，默认构造函数 123456789101112vector&lt;int&gt; arr; // 构造int数组 vector&lt;int&gt; arr(100); // 构造初始长100的int数组 vector&lt;int&gt; arr(100, 1); // 构造初始长100的int数组，初值为1 vector&lt;vector&lt;int&gt;&gt; dp(100, vector&lt;int&gt; ()); // 构造初始100行，不指定列数的二维数组 vector&lt;vector&lt;int&gt;&gt; dp(100, vector&lt;int&gt; (200, -1)) // 构造初始100行，初始200列的二维数组，初值为-1vector&lt;int&gt; arr[100],没初始化的二维数组，每一个arr[i]都是一个vector，相当行数不变，列数不定的二维数组arr[i].push_back; 这个二维数组可以理解为100个元素，每个元素都是一维vector 注意，创建完后，可以当作普通数组用，如 vector&lt;int&gt; arr(100),arr[0]=1; 尾增尾删push_back(),pop_back() .push_back(元素)：在 vector 的最后一个内存后增加一格内存，并给这个内存赋值，数组长度+1(!) .pop_back()：删除 vector 的最后一格内存及其元素，数组长度-1 arr.push_back(100); arr.pop_back(); arr={0,0,0,0},arr.push_back(9)–&gt;arr={0,0,0,0,9} 获取长度.size()获取当前 vector 的长度 注意返回值是无符号整数size_t o(1)复杂度 清空.clear()arr.clear(); o(n)复杂度 判空 .empty()如果是空返回 true 反之返回 false. 时间复杂度：o(1) 改变长度.resize(新长度, [默认值]) 修改 vector 的长度 如果是缩短，则删除多余的值 如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变） 时间复杂度：o(n) 栈stack#include&lt;stack&gt; 栈不可访问内部元素，只能用弹出看栈顶,所以感觉可以用vector代替stack，或者手写。– vector 的 .back() 取尾部元素，就相当于取栈顶，.push_back() 相当于进栈，.pop_back() 相当于出栈。 构造stack&lt;类型&gt; a,不初始化 进出栈a.push(元素)进 a.pop()弹出 取栈顶a.top(); int topnum=a.top(); 队列构造queue&lt;类型&gt; que 进出队.push(元素) .pop() 取队尾队首.front() .back() int getfront=que.front(); 集合set自动去重，加入元素后，元素自动从小到大排序的一个容器 注意set不支持下标操作，需要用迭代器 头文件#include&lt;set&gt; 创建集合set&lt;int&gt; dict; 方法插入：dict.insert(x); 删除：dict.erase(x); 查找：dict.count(x) /dict.find(x); 找到了，返回指向x的迭代器，没找到返回特殊迭代器dict.end() 个数：dict.size(x); 清空：dict.clear(x); 判断为空：dict.empty(x); 优先队列priority_queue新元素被添加到堆的末尾，然后通过”上浮”操作调整位置，保持堆性质，时间复杂度：O(log n) 构造priority_queue&lt;类型, 容器, 比较器&gt; pque 类型：要储存的数据类型 容器：储存数据的底层容器，默认为 vector&lt;类型&gt;，竞赛中保持默认即可 比较器：比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义 priority_queue&lt;int&gt; pque;默认为大顶堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; 储存int的小顶堆 进出堆.push(元素) .pop() 取堆顶(大堆顶就是最大值，小就是最小值)只可访问堆顶，其他元素都无法读取到。 .top() int a=pque.top();","link":"/2025/07/09/c++/c++%E5%AE%B9%E5%99%A8/"},{"title":"","text":"迭代器是什么？通俗来讲，迭代器用来指明stl容器位置 我们创建一个迭代器，实际上是创建了迭代器类的一个对象，实现了类似指针的操作。所以他的本质不是指针，但很像指针 例如 123for(int i=0;i!=v.size();i++){ cout&lt;&lt;v[i]&lt;&lt;endl;} 就类似 1for(vector&lt;int&gt;::iterator i=v.begin();i!=v.end();++i) begin()指向第一项,end()指向最后一项的后一项 迭代器操作 itr++，++itr：迭代器进入下一个位置 注意！itr++实际上是重载运算符，他会返回一个对象！例如i++就是返回老的i，然后i本身封装的指针值++（类似指针移动） 1234567// 后缀 it++ Iterator operator++(int) { Iterator tmp = *this; // 保存旧值（拷贝） ++ptr; // 再移动 return tmp; // 返回旧值 } 前缀自增 ++it 表示“先移动迭代器，再使用结果”，返回的是自增后的迭代器本身（通常是引用）。后缀自增 it++ 表示“先使用旧位置，再移动迭代器”，返回的是自增前迭代器的一个副本。 后缀形式为了返回旧值，必须保存一个临时对象；前缀形式不需要。 不需要旧值的情况下应当使用前缀形式；前缀在语义和性能上都更优。","link":"/2026/02/03/3.stl/6.%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"title":"","text":"级数1.$\\sum_{i=1}^{n} A^i =\\frac {A^{N+1}-1}{A-1}$ 当A∈(0,1)，$\\sum_{i=1}^{n} A^i &lt;=\\frac {1}{1-A}$ $\\sum _{i=1}^N i=N(N+1)/2$ $\\sum _{i=1}^N i^2 =N(N+1)/2$ $\\sum _{i=1}^N i^k \\approx \\frac {N^{k+1}}{|k+1|},k\\neq-1$ $\\sum _{i=1}^N {\\frac{1}{i}} \\approx log_eN$,近似式误差趋近于欧拉常数$\\gamma \\approx 0.577215$","link":"/2026/01/20/4.%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/1%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"title":"","text":"头文件：#include&lt;algorithm&gt;sort函数int arr[maxn]; sort(arr,arr+maxn-1 )","link":"/2025/07/09/c++/c++%E7%AE%97%E6%B3%95/"},{"title":"","text":"operator是C++的一个关键字，它和运算符（如“=”）一起使用，表示一个运算符重载函数，在理解时可将operator和待重载的运算符整体（如“operator=”）视为一个函数名。 实现运算符重载的方式通常有以下两种： 1.运算符重载实现为类的成员函数； 1234567//在student类里面bool operator&gt;(const student&amp; a){ if(this.score&gt;a.score){ return true;} return false;} 2.运算符重载实现为非类的成员函数（即全局函数）。 两个参数分别为左右操作数（至少一个是自定义类，可以只有一个或者另一个是int等） 123456bool operator&gt;(const student &amp;a,const student &amp;b){ if(a.score&gt;b.score){ return ture;} return false;} 注意： 不能违反运算符原来的语法规则； 不能创建新的运算符； 有一些运算符是不能重载的，如“sizeof”； =、()、[]、-&gt;操作符只能被类的成员函数重载。","link":"/2026/02/03/3.stl/5.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"","text":"1.万能头#include&lt;bits/std++.h&gt;2.命名空间namespacenamespace准确来说是防止重名，而对某些变量，函数的修饰，因为它并不是物理储存结构，而是编译时的二进制修饰。不恰当的类比:int x;struct x{int x;};这两个语句不冲突，但是去掉struct 就重名了。 namespace性质基本用法：namespace S{ }括号里面放函数，变量等 嵌套命名空间可以嵌套 namespace Outer { namespace Inner { void Func() { } } 在一个文件里面，如果有全局 访问:Outer::Inner::Func(); 可多次使用访问完全限定名：std::cout 只用当前一次 using声明：using std::cout; 用一个，输入该命令后全域都可以使用 using指令：using namespace std; 命名空间导入 namespace变量性质当前文件修改namespace里面的变量会生效，但是不会影响到下一次编译 在某处引入using namespace A或者using A::…，只会在当前作用域生效 至此，using namespace std是什么已经很清楚了，注意std权限是可读，无法修改cout等函数，假设用hexedit修改源码，会造成编译立即崩溃 3.引用int func(int &amp;a){} 表示a按照传引用 传递，也就是外面的值可以像用指针那样改变 后面a正常用，不要当成指针*a用。 4.头文件细微变化多头文件#include&lt;iostream&gt; 而c头文件可以正常用，但是推荐去掉.h,前面加c，比如&lt;stdio.h&gt; —&gt; &lt;cstdio&gt; 5.迭代器迭代器是 C++ STL 提供的一种泛型指针，这种数据类型用于检查和遍历容器内元素，理解为指针即可 begin和endbegin()指向容器的第一个元素，注意！end()指向容器的最后一个元素的后一个元素！end通常作为未查找到的返回值 声明vector &lt;int&gt;::iterator it; for(set &lt;int&gt;::iterator it=dict.begin();it!=dict.end();++it) cout&lt;&lt;*it&lt;&lt;”\\n”; 种类1.随机访问迭代器 ： 功能最全，支持解引用，成员访问，自增自减，迭代器加减，迭代器距离，比较，下标。和数组指针几乎一样 vector，deque容器支持 如 vector&lt;int&gt;::iterator it = v.begin(); cout &lt;&lt; *it &lt;&lt; endl; // 输出第一个元素 cout &lt;&lt; *(it + 3) &lt;&lt; endl; // 输出第四个元素 it += 2; // 跳跃到第3个元素 cout &lt;&lt; *it &lt;&lt; endl; // 输出 cout &lt;&lt; (v.end() - v.begin()) &lt;&lt; endl; // 元素个数 cout &lt;&lt; it[1] &lt;&lt; endl; // 相当于 *(it + 1) 2.双向迭代器： 比随机访问迭代器更弱一点，不支持迭代器位置比较it_1&lt;it_2，和随即跳转it+n list,set,map是双向 3.前向迭代器 多次读写，单向，输出迭代器，只写一次，单向，输入迭代器，只读一次，单向。很少用。 注意比如vector容器，动态扩容之后会重新找一块更大的空间，所以原来的迭代器会失效 迭代器辅助函数辅助函数可用于各种迭代器，通常用于写模板或泛型代码 #include&lt;algorithm&gt; advance(it,n);使得迭代器向前/后移动n，（随即迭代器里的it+=n;) distance（it2,it1)；计算两个迭代器之间距离，即元素个数。it2要&lt;=it1 iter_swap(it1,it2);交换迭代器指向的值 stringstream1.介绍用于处理字符串的输入输出流。从string里面读入 c++里面，流是数据从一个对象到另一个对象的流动。数据输入输出通过IO流实现，cin/cout是istream，ostream创建的对象（cin，cout是抽象实现，不能创建和拷贝，但是可以引用，istream &amp; _cin=cin对，istream _cin=cin和istream _cin都错。 而stringstream不是抽象类，可以直接创建） 2.创建(一般来说创建名为ss)a.直接创建 string arr(“hello world”); stringstream ss; ss&lt;&lt; arr; cout &lt;&lt;ss.str()&lt;&lt;endl; b.初始化创建 stringsream ss(“hello world”); 3.输出调用ss.str();不能直接输出ss 4.修改流ss.str(“fuck world”) 5.常见用法string line,wold; while(getline(cin,line)){ stringstream ss(line) while(ss&gt;&gt;word)… } auto自动推导类型 如auto x=6—x为int auto x=arr.size();—x为size_t string一种类，string s=”hello world” 1.访问元素可以通过s[i]或者s.at(i), 两者都可以修改原string串内容 s[i]无越界检查，但跟高效，s.at(i)会检查越界 2.方法. 数组长度 s.length()或者s.size() 是否为空 s.empty() 追加字符 s.append() 插入 s.insert(pos,str) 删除 s.erase(pos,len) 清空 s.clear()","link":"/2025/07/09/c++/c++%E8%AF%AD%E6%B3%95/"},{"title":"","text":"gcc常见命令 gcc draft.c -o draft 把draft.c源文件编译,输出成draft 注意-o后面必须紧跟draft文件名，其他位置没有讲究。 gcc draft.c -g -o draft,生成调试信息，gdb要用 只要-o后面紧跟draft文件名， gcc -g -o myprog main.cgcc -o myprog -g main.cgcc main.c -g -o myprog都是合法的 gdb用上面的-g命令编译下， gdb ./draft 启动 gdb r/gdb run开始程序 gdb b 数字 在某一行加上断点 gdb b 函数名在函数处加上断点 遇到断点后 gdb l查看断点处10行代码 没遇到断点就是从开头依次输出10行代码 gdb l x,y查看x到y处代码 gdb g 变量名查看变量值 gbd x/s 变量名 输出字符串变量 gdb x/c 变量名 输出字符变量 gdb bt 查看调用的栈帧（backtrace） gdb i b查看所有断点 gdb delete 1删除断点1 gdb delete 删除所有断点","link":"/2025/05/16/tools/gdb%E5%88%9D%E6%AD%A5/"},{"title":"","text":"概念规则 实例和对象和类区别：实例是通过类创建的对象，比如我string a，a就是string类的实例。比如人类，里面的李白和杜甫就是实例。对象更宽泛，你可以说任何内存实体都是对象。但是一般可以认为实例和对象就是一回事，可以换用。 源代码的文件名必须与公共类的类名相同 main方法必须为public 字符串区间规律：从零开始，操作长度为n–（0,n)例如x.delete(0,4)删除第1-4个，第一个代表起始位置，第二个代表总长度 java.lang是java核心包，无需import 方法积累字符串类理解：1.java无内置字符串类型，但有一个预定义类string，每个字符串都是string类的实例，这意味着string有很多方法 2.string进行了特殊优化，使其使用起来像基本类型，可以直接拼接 3.注意string储存的是对象在内存中位置的引用，是对象在堆上的地址。但是String是不可变对象引用，给某一个string对象引用赋新值，会导致这个引用直接指向新的对象。同时赋值新值后，会导致原值留在内存里面。 String s1=”hello”; String s4=”hello”; s4=”nima”; System.out.println(s1);—-输出hello! 构建：a.字面量:String s1=”hello”;高效率 b.构造方法:String s2=new String (“nima”); 区别： a.存储在 字符串常量池中，如果常量池中已经存在 &quot;hello&quot;，Java 就不会再创建新的对象，而是 直接引用已存在的。 b.会 在堆内存中新建一个字符串对象。 String s1=”hello”; String s4=”hello”; String s2=new String (“hello”); s1.equals(s2)–true s1.equals(s4)–true s1==s2–true(地址相同,同一个) s1==s4–false 拼接 +String s3=s1+s4;—“hellohello” 注意！ 1.Java 中 String 是不可变的，所以每次拼接字符串，实际上是创建了一个新的字符串对象，而不是在原字符串基础上修改。 2.实际编译器会生成类似这样的代码：String s = new StringBuilder().append(s1).append(s4).toString(); 所以每次+都会创建新的字符串对象，性能差 建议用StringBuilder substring方法返回新的子串 String substring(int beginIndex) //从该索引开始到结束String substring(int beginIndex, int endIndex) //注意如果看成数组索引的话，endindex要+1 输出完自动添加换行 eg： String str = “hello world”;System.out.println(str.substring(0, 5)); // 输出 “hello”System.out.println(str.substring(6)); // 输出 “world” length很多类都有这个方法 String str=”hello world”; str.length()==11; equalss1.equals(s2); “hello”.equals(s2); 不要用等于==,==代表比较位置，只有字符串字面量可能相等 equalsIgnoreCases1.equalsIgnoreCase(s2)比较忽略大小写 compareTos1.compareTo(s2) 按照字典顺序比较两个字符串，相等返回1，小于返回负数，大于返回正数 Stingbuilder类创建：StringBuilder x=new StringBuilder(“cao “(或者String变量)); length类似 appendx..append(“nima”) ,在cao后面追加nima deletex.delete(0, 4),删除区间内内容（含头不含尾） reversex.reverse(),反转字符串 insertx.insert(2, “X”),在指定位置插入 join拼接replacex.replace(1, 3, “XYZ”),替换内容 ToStringx.ToString()变成string类 StringBuffer语法基本同StringBuilder，区别在于StringBuilder更快，但只适用于单线程，而StringBuffer适用于多线程 理解多线程 Java多线程详解——一篇文章搞懂Java多线程 - brokyz - 博客园 Math类java.lang.Math无需导入 exp(),log(),pow(),sqrt(),sin(),asin(),toDegrees(),toRadians(),random()double a = Math.exp(1); // e 的 1 次方，即 e ≈ 2.718double b = Math.log(10); // 计算自然对数 ln(10)double c = Math.pow(2, 3); // 2 的 3 次方，结果为 8double d = Math.sqrt(16); // 计算 16 的平方根，结果为 4double e = Math.sin(Math.PI / 2); // 计算正弦，sin(π/2) = 1double f = Math.asin(1); // 计算反正弦 asin(1) = π/2double g = Math.toDegrees(Math.PI); // 弧度转角度，π 弧度 ≈ 180°double h = Math.toRadians(90); // 角度转弧度，90° ≈ π/2double i = Math.random(); // 生成一个 0.0 到 1.0 的随机数 Number包装类Number (Java SE 11 &amp; JDK 11 )包装类（Wrapper Class） 是 Java 提供的一种机制，它将基本数据类型（int、char、double 等）包装为 对象。这使得基本数据类型能够作为对象使用，例如在 Java 集合框架（如 ArrayList、HashMap）中，或者进行类型转换、方法调用等操作。 抽象类，不能实例化 Double那些是Number的子类，注意BigDecimal，BigInteger也是。是Number子类都可以调用.intValue()方法 intValue,doubleValue……Double d = 3.99;int i = d.intValue(); // i = 3，截断小数 valueOf()基本类型转包装对象 Double d = Double.valueOf(3.14); // double -&gt; Double 对象 字符串转包装对象 Integer i2 = Integer.valueOf(“456”); // 字符串 “456” -&gt; Integer 对象 大数BigInteger整数，BigDecimal浮点 构造1.BigInteger big1 = new BigInteger(“123456789012345678901234567890”); 2.valueOf valueOf记得上面说的吗，BigInteger也是Number的子类 BigInteger a=BigInteger.valueOf(1000000) 把1000000转换成biginteger类的对象 addBigInteger sum = big1.add(big2); multiply()divide()mod()pow(int)subtract()compareTo()基本语法对象初步1.基本规则1.一个文件里面可以有多个类，但是public修饰的类只能有一个，且这个类名必须和文件名一样 构造对象使用构造器构造，构造器名与类相同，前面加上new， 如new class(); Date rightnow–创建一个Date类的对象变量–对象变量不是对象，不能使用对象的方法 注意！：对象变量的值是一个引用，也就是说Date rightnow=new Date();,rightnow_2=rightnow,此时两个还是指向一个 new Date()–构造一个变量 System.out.println(new Date())–创建的对象变量可以用，但只能用一次（这里date有toString方法，println输出默认使用toString转为字符串） Date rightnow=new Date();","link":"/2025/05/08/java/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md/"},{"title":"","text":"1.计算程序进行时间#include&lt;time.h&gt; double a =clock():返回从开始到调用这里的clock时的时间。注意包含手动输入输出时间 CLOCKS_PER_SEC:常数，clock()/CLOCKS_PER_SEC得到秒 用法a: 在cmd里面输入echo …(内容)|draft(程序名) (在其他终端里面会错误，比如vscode默认的powershell，scanf读不进去),这样就不会算手动输入的时间 用法b: double a=clock(); …代码块 … double b=clock(); b-a即该代码块的时间 注意： 手动点击调试按钮比gcc -o draft draft.c 后运行./draft慢 vscode-powershell:time used = 0.093000000 cmd:time used = 0.090000000 点击调试按钮：time used = 0.205000000 2.未结束：window程序输入完按enter未结束，尝试按ctrl+z再按enterlinux：直接按ctrl+d 3.重定向读入文件freopen(“filename”,”mode”,stream)替换源流为stream 比如if(!freopen(“in.txt”,”r”,stdin)) filename文件名,可以是路径 ..\\in.txt,D:\\in.txt,.\\in.txt 也可以是”CON”表示回到终端，比如 freopen(“CON”, “w”, stdout);，输出到终端 mode输入模式,有： mode 功能 &quot;r&quot; 只读（文件必须存在） &quot;w&quot; 只写（创建新文件或清空已有文件） &quot;a&quot; 追加（写入到文件末尾） &quot;r+&quot; 读写（文件必须存在） &quot;w+&quot; 读写（创建新文件或清空已有文件） &quot;a+&quot; 读写追加（写入到文件末尾，读取可从头开始） stream有stdin,stdout,stderr 4.复制数组memcpy(注意，memcpy极快，甚至快于for循环赋值) #include&lt;string.h&gt; void *memcpy(void *dest, const void *src, size_t n) dest是目标地址，复制的内容将写入这里,src是源地址，复制的内容从这里读取,n是要复制的字节数。 从int a数组复制k个值到b：memcpy(b,a,sizeof(int)*k); 5.清零memset这个同上，也快 作用是给某个数据结构赋固定值。可以初始化内存，清空字符串缓冲区，初始化结构体。但注意value是字节，如使用memset(&amp;p,1,sizeof(p)，每个 int占 4 字节，所以p[i]的实际值是0x0101010（十进制 16843009），而不是 1。所以我们一般用于清零 #include&lt;string.h&gt; void *memset(void *ptr, int value, size_t num); memset(&amp;p,0,sizeof(p) 6.c++初步万能头#include&lt;bits/std++.h&gt;命名空间namespacenamespace准确来说是防止重名，而对某些变量，函数的修饰，因为它并不是物理储存结构，而是编译时的二进制修饰。不恰当的类比:int x;struct x{int x;};这两个语句不冲突，但是去掉struct 就重名了。 namespace性质基本用法：namespace S{ }括号里面放函数，变量等 嵌套命名空间可以嵌套 namespace Outer { namespace Inner { void Func() { } } 在一个文件里面，如果有全局 访问:Outer::Inner::Func(); 可多次使用访问完全限定名：std::cout 只用当前一次 using声明：using std::cout; 用一个，输入该命令后全域都可以使用 using指令：using namespace std; 命名空间导入 namespace变量性质当前文件修改namespace里面的变量会生效，但是不会影响到下一次编译 在某处引入using namespace A或者using A::…，只会在当前作用域生效 至此，using namespace std是什么已经很清楚了，注意std权限是可读，无法修改cout等函数，假设用hexedit修改源码，会造成编译立即崩溃 算法algorithm容器containervector#include&lt;vector&gt; vector 的数据储存在堆空间中，不会爆栈。一般情况 vector 可以替换掉普通数组。 注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销 声明vector&lt;类型&gt; arr(长度，[初值]) 括号及里面的内容可省，默认构造函数 123456789vector&lt;int&gt; arr; // 构造int数组 vector&lt;int&gt; arr(100); // 构造初始长100的int数组 vector&lt;int&gt; arr(100, 1); // 构造初始长100的int数组，初值为1 vector&lt;vector&lt;int&gt;&gt; dp(100, vector&lt;int&gt; ()); // 构造初始100行，不指定列数的二维数组 vector&lt;vector&lt;int&gt;&gt; dp(100, vector&lt;int&gt; (200, -1)) // 构造初始100行，初始200列的二维数组，初值为-1 这个二维数组可以理解为100个元素，每个元素都是一维vector 尾增尾删push_back(),pop_back() .push_back(元素)：在 vector 的最后一个数据后尾接一个元素，数组长度+1 .pop_back()：删除 vector 的最后一个数据尾部元素，数组长度-1 arr.push_back(100); arr.pop_back(); 获取长度.size()获取当前 vector 的长度 注意返回值是无符号整数size_t o(1)复杂度 清空.clear()arr.clear(); o(n)复杂度 判空 .empty()如果是空返回 true 反之返回 false. 时间复杂度：o(1) 改变长度.resize(新长度, [默认值]) 修改 vector 的长度 如果是缩短，则删除多余的值 如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变） 时间复杂度：o(n) 栈stack#include&lt;stack&gt; 栈不可访问内部元素，只能用弹出看栈顶,所以感觉可以用vector代替stack，或者手写。– vector 的 .back() 取尾部元素，就相当于取栈顶，.push_back() 相当于进栈，.pop_back() 相当于出栈。 构造stack&lt;类型&gt; a,不初始化 进出栈a.push(元素)进 a.pop()弹出 取栈顶a.top(); int topnum=a.top(); 队列构造queue&lt;类型&gt; que 进出队.push(元素) .pop() 取队尾队首.front() .back() int getfront=que.front(); 优先队列priority_queue新元素被添加到堆的末尾，然后通过”上浮”操作调整位置，保持堆性质，时间复杂度：O(log n) 构造priority_queue&lt;类型, 容器, 比较器&gt; pque 类型：要储存的数据类型 容器：储存数据的底层容器，默认为 vector&lt;类型&gt;，竞赛中保持默认即可 比较器：比较大小使用的比较器，默认为 less&lt;类型&gt;，可自定义 priority_queue&lt;int&gt; pque;默认为大顶堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; 储存int的小顶堆 进出堆.push(元素) .pop() 取堆顶(大堆顶就是最大值，小就是最小值)只可访问堆顶，其他元素都无法读取到。 .top() int a=pque.top(); 7.gdb编译的时候，如果用了math.h库，那么编译命令里面要加上-lmgcc -g -o draft draft.c -lm &lt;math.h&gt;只是声明了pow()等数学函数的原型（告诉编译器这些函数存在，应该怎么调用）。 真正的函数实现在数学库libm中&gt;默认情况下，GCC 不会自动链接数学库，所以必须手动加 -lm。 8.定义字符串数组后加上memset(arr1, 0, sizeof(arr1));byd没加是错的，加了就对了 9.ubuntu粘贴会导致输出部分和输入部分错乱，建议重定向文件或者手动输入ctrl v导致输入输出异步，缓冲区未刷新 手动输入和重定向 ./draft &lt; in.txt 10.字符型整数转整数型整数假设某串的i-j部分是数字，提取成整数，可以不用pow，效率比较低 int change(char *str,int i,int j){ int result; for(int k=i;k&lt;=j;k++) result=result*10+str[k]-‘0’; return result; }","link":"/2025/05/08/%E6%8A%80%E5%B7%A7/%E6%8A%80%E5%B7%A7/"},{"title":"","text":"git教程可以查看时光机穿梭 - Git教程 - 廖雪峰的官方网站 可谓是非常详细了。以下仅仅记录常用指令方便查找 注意，git在没输入git config –global（全局）或指定文件路径时，都是对当前目录的操作 初始化和添加文件-（add）-track-（commit）-git保险柜 git init：在某一路径下，创建一个”保险柜“，用于存放保险柜的名字默认叫master，我已经通过 git config –global init.defaultBranch main将默认repo名改为main git add 文件名(当前目录下)或文件路径 把目标文件放入track上面（未进repo） git add. 添加所有 git commit -m “对文件的描述（随便写，但是必须有）” git管理git status 查看当前文件夹下有哪些未进入track git diff 查看差异 git log 查看git操作日志，git上面commit后面有很大一串怪字符，那是id git show 某某id（git log里面的） git文件内容控制git checkout id “filename” 把filename变为相关id版本 （完成 add commit会进入一次log操作，得到一个不同的id） git reset –hard 版本回退到上个版本的已提交状态 git reset –soft 回退到上个版本的未提交状态 git reset –mixed 回退到上个版本已添加但未提交的状态 cs61b的ssh密匙在home githubgit remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git 添加了一个叫skeleton的库，这个库不会和我的冲突，多个可共存 git pull origin main –rebase拉取远程代码到本地并变基 git pull –rebase –allow-unrelated-histories skeleton master 导入了cs61b的初始代码 git push origin main本地推送到远端 如果是第一次建库，由于github上面有readme，比你电脑提交记录新，所以会拒绝，此时可git pull origin main –rebase 或者git push -f origin main强制推送","link":"/2025/02/25/tools/git%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"},{"title":"typedown常用语法","text":"[TOC] 引用&gt; 表示单行引用 &gt;&gt;表示引用的嵌套 效果: 知行合一 标题字号字符 # + 空格+要输入的字符+回车来表示或者选中，shift+1-6直接转换 列表有序列表 1.+space 无序列表 *+space: +或者是-都可以 HTML语法，段落中显示&bull; :&amp;bull; &amp;bull; 任务列表 - [ ] 表示任务列表 ,出现&bull; []的情况，可以在[]后加一个空格 形式代码块 ``` ```开始，```结束（会自动有```),下面可以选择语言 长水平分割线 -– *** — + 回车，或者*** + 回车 脚注 [^1] 最末尾[^1]:脚注内容或网址 插入图片 ! 括号里面写入网页地址或者本地地址，本地地址记得去引号 注意，本地的话，把文件的相对地址写到_post文件夹下，网站写到.index.html下 ./image/picture.png 目录索引[TOC]放在开头，自动根据标题分索引 数学符号代码块 $+ESC 出现$$,在这两个美元符号之间输入LaTex语法，即可实现在行内插入公式。 $$ + 回车行间插入公式 字符表 上述定界符与\\left和right组合使用可以使得定界符匹配其内容的高度。比如矩阵 \\left|\\begin{matrix} a &amp; b &amp; c \\ d &amp; e &amp; f \\ g &amp; h &amp; i \\end{matrix} \\right| 细节 使用^来输出上标，使用_来输出下标，使用{}包含作用范围。 \\sum_{n=1}^\\infty k $\\sum_{n=1}^\\infty k $ $$\\sum_{n=1}^\\infty k$$ 矩阵中的各元素通过用$来分隔，\\\\来换行。 \\begin{vmatrix} 0&amp;1&amp;2\\ 3&amp;4&amp;5\\ 6&amp;7&amp;8\\ \\end{vmatrix} 用\\begin{cases}和\\end{cases}来构造分段函数，中间则用\\\\来分段: f(x) = \\begin{cases} 2x,,,x&gt;0\\ 3x,,,x\\le0\\ \\end{cases}","link":"/2025/01/19/tools/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"title":"","text":"终端实际上配置有一系列应用程序，储存在文件管理系统里面，输入指令将调取这些程序。通过环境变量搜索程序shell实际上可以是一种编程语言，循环那些都可以实现 指令操作ctrl+c 退出当前进程ctrl 清空，回到顶部sudo 超级用户（慎用，除非必要）sudo su(下面的提示符从$变为#，即默认从user变为root）exit退出root.+文件名代表隐藏文件 重定向 &lt; 重定向键盘输入为文件输入 &gt;重定向标准输出到文件 文件将被覆盖 &gt;&gt;重定向便准输出到文件，但不覆盖，而是追加 2&gt;输入错误到某文件 ./draft &lt; draft.in &gt;draft.out 2&gt;error.log 但是注意输出错误日志可能会占用一定cpu从而影响正常程序运行 echoecho表示打印文本 echo helloecho $PATH,显示以冒号为分割的路径变量echo ​$HOME（环境变量）,–/home/hardestnut我输入date，会在这些路径下查找是否有相关的程序 which寻找可执行文件，找不到文件夹 which .ssh没反应 which ssh显示路径 which echo–/usr/bin/echo 或者 find ~ -name “ssh” 顺便说一句，文件名都以/开头 pwd显示当前路径–/home/hardestnut cdcd 改变到目标路径cd 默认到主目录cd -回到上一次目录（两者之间来回）cd /homecd /回到根目录/(值得注意的是，开头的/指的是根目录，/bin对，/local错，/usr/local对，因为/下没有local目录cd ..回到上一个路径cd ../other_directory：切换到当前目录的上一级目录中的other_directory。cd ~ 带到主目录（home/username）可作为相对路径 lsls ~\\目标文件 ls：显示当前路径下的文件ls .. 上一级文件目录(Usage: ls [OPTION]… [FILE]… 这里面…表示0，1或多个选项ls –helpls -l +文件夹名显示详细信息 ls展示信息解读lrwxrwxrwx 1 root root 7 Nov 23 2023 bin -&gt; usr/binl表示这是一个符号链接,类似于快捷方式，指向另一个文件或目录。（d表示目录 rwxrwxrwx 表示所有用户（所有者、用户组、其他用户）都有读、写、执行权限。（r-x表示缺少w） 1：表示硬链接的数量。对于符号链接，通常这个数字是 1。对于目录来说，硬链接数表示该目录下有多少个子目录（包括 . 和 ..） ls -a 显示所有文件，包括以 . 开头的隐藏文件。ls -lh 显示人类可读的文件大小ls -R 递归列出所有子目录的内容。ls -lt 按文件的修改时间排序，最近修改的文件排在最前面。ls -lS 按文件的大小排序，最大文件排在最前面。ls -F 在文件名后添加标识符，表示文件类型。/ 表示目录，* 表示可执行文件。ls -color 不同类型染色ls -1竖着排版，看起来舒服点多个选项可以一起使用，通常没有问题。ls -lat mvmv 功能1：移动文件路径 功能2：重命名文件mv filename(如果只有一个) 目标路径mv 路径（多个，精确） 目标路径mv filename*（通配符）（多个） 目标路径(将把全部文件都移过去） 重命名：mv 旧名字 新名字 cpcp 复制文件cp filename 新路径 或 旧路经 新路径 rm递归删除即指删除当前文件夹及其所有子文件夹 rm删除（通常不是递归删除，即删除以上的所有目录）rm 文件名/路径（rm默认删除文件rm -r filename/path(递归删除所有空） sudo rm -rf …强制删除（谨慎！！！！ rmdir 文件名/路径（允许你在目录为空的时候删除一个目录） mkdirmkdir创造目录 “name” manman+另一个程序名，将提供该程序的手册man ls(ls的使用）man echo 重定向&lt; &gt;echo +&gt;输入重定向：echo “hello”&gt;hello.txt(覆盖或创建）echo “hello”&gt;&gt;hello.txt(末尾追加或者创建）cat &lt;hello.txt输出内容cat &lt;hello.txt &gt;hello2.txt 相当于把第一个文件内容复制给第二个 | ： 命令1|命令2把左边命令的输出内容作为右边命令的输入内容ls -a|tail -n2(表示输出最后两行内容) 查找文件：find 路径1 路径2… -name “文件名”2&gt;/dev/null后面的2&gt;/dev/null表示不输出无关的，否则在大路径下查找可能会输出一坨。2(标准错误输出)&gt;/dev/null(文件黑洞，相当于垃圾桶)/dev(设备文件,这些文件是与硬件设备或虚拟设备交互的接口)/null虚拟设备 filefile+文件名 判断文件类型 如file draft3 输出：draft3: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=320cbb94642d466c28181ba5732e78d0b22fa1cd, for GNU/Linux 3.2.0, not stripped 分别表示64位可执行文件（linux的ELF表示可执行文件） 处理器架构 版本，动态链接依赖，动态链接器路径，哈希标识，保留调试信号（-g） 又如file draft3.c,输出draft3.c: C source, Unicode text, UTF-8 text, with CRLF line terminators。 其他ctrl+tab切换标签页 按上箭头和下箭头能查阅历史命令 在命令输入一半按tab会显示所有可能的完整命令","link":"/2025/02/25/tools/ubuntu%E6%8C%87%E4%BB%A4/"},{"title":"","text":"bfs(breadth first search)宽度优先搜索，一层一层搜，可以用于最短路径问题，最少步骤解答 大致思路是：对于一个图而言，我们放入一个起点，然后拿出这个点，并放入这个点相邻的所有点（相当于访问了），再拿出新放入的点，并放入这些所有的新放入的点的相邻点…依次类推，直到所有点都被放入过。这个过程像水的波纹一层一层的散开，称为深搜。 1.首先复习下图的储存，一般是用数组模拟邻接表，即链式前向星 add函数将节点v和节点u相连这条信息插入到邻接表里面 123456789101112const int n=10000;const int m=2*n+10;int head[n],e[m],ne[m],idx;void init(){}void add(int v,int u){ ne[idx]=head[v]; head[v]=idx; e[idx]=u; idx++;} 2.接着实现bfs 首先我们维护几个数组： bool vis[u]记录u节点是否被遍历，是为1，否为0 int d[u] 记录深度，即起点到u点的最小距离 int p[u] 记录是从哪个节点到哪个节点，方便还原路径 具体意义是:p[v]=指向v的上一个边u; 这样，我们对于所有点，能知道它到起点的距离，也能回溯任意点的路径！！ 123456789101112131415161718192021222324252627queue&lt;int&gt; Q;const int n=10000,m=2*n+10;int e[m],ne[m],idx,head[n];bool vis[n];int d[n],p[n];void init();void bfs(int u){ while(!Q.empty())Q.pop(); Q.push(u); vis[u]=1; d[u]=0; p[u]=-1; while(!Q.empty()){ int node=Q.front(); Q.pop(); for(int i=head[node];i!=-1;i=ne[i]){//i是索引的迭代 if(!vis[e[i]]){//如果没有访问过下一个点，就放入，并让d[下一个点]=d[node]+1，p[下一个点]指向node Q.push(e[i]); vis[e[i]]=1; d[e[i]]=d[node]+1; p[e[i]]=node; } } }} 函数逻辑：首先初始化Q,d,p,vis,然后将u放入Q中。 接着开始bfs循环，每次取出队首，并放入队首指向的所有边，然后更新vis，d，p 注意d的逻辑，是等于d[node]+1 3.访问路径 利用我们的p[u]回溯 12345678910void restore(int u){ vector&lt;int&gt; last; for(int i=u;i!=-1;i=p[i]){ last.push_back(i); } std::reverse(last.begin(),last.end()); for(int i=0;i&lt;last.size();i++){ cout&lt;&lt;last[i]&lt;&lt;&quot; &quot;; }} 或者 12345678910void restore(int u){ vector&lt;int&gt; last; for(int i=u;i!=-1;i=p[i]){ last.push_back(i); } if(!last.size()) for(int i=last.size()-1;i&gt;=0;i--){ cout&lt;&lt;last[i]&lt;&lt;&quot; &quot;; }} reverse是反转函数，包含在&lt;algorithm&gt;头文件里面 应用（摘自oiwiki） 在一个无权图上求从起点到其他所有点的最短路径。 在 𝑂(𝑛 +𝑚) 时间内求出所有连通块。（我们只需要从每个没有被访问过的节点开始做 BFS，显然每次 BFS 会走完一个连通块） 如果把一个游戏的动作看做是状态图上的一条边（一个转移），那么 BFS 可以用来找到在游戏中从一个状态到达另一个状态所需要的最小步骤。 在一个有向无权图中找最小环。（从每个点开始 BFS，在我们即将抵达一个之前访问过的点开始的时候，就知道遇到了一个环。图的最小环是每次 BFS 得到的最小环的平均值。） 找到一定在 (𝑎,𝑏) 最短路上的边。（分别从 a 和 b 进行 BFS，得到两个 d 数组。之后对每一条边 (𝑢,𝑣)，如果 𝑑𝑎[𝑢] +1 +𝑑𝑏[𝑣] =𝑑𝑎[𝑏]，则说明该边在最短路上） 找到一定在 (𝑎,𝑏) 最短路上的点。（分别从 a 和 b 进行 BFS，得到两个 d 数组。之后对每一个点 v，如果 𝑑𝑎[𝑣] +𝑑𝑏[𝑣] =𝑑𝑎[𝑏]，则说明该点在某条最短路上） 找到一条长度为偶数的最短路。（我们需要一个构造一个新图，把每个点拆成两个新点，原图的边 (𝑢,𝑣) 变成 ((𝑢,0),(𝑣,1)) 和 ((𝑢,1),(𝑣,0))。对新图做 BFS，(𝑠,0) 和 (𝑡,0) 之间的最短路即为所求） 在一个边权为 0/1 的图上求最短路，见下方双端队列 BFS。","link":"/2025/09/13/%E6%90%9C%E7%B4%A2/bfs/"},{"title":"","text":"","link":"/2025/10/21/%E6%90%9C%E7%B4%A2/%E5%9B%9E%E6%BA%AF/"},{"title":"","text":"dml,操作数据库中的数据（增删改）的语言 主要包括insert，update，delete 注意，DML需要手动commit，否则不会保存。 注意，提交commit后，无法回退 插入insert into1.简写方式 列数value数必须一样，除非允许空值，按顺序插入 //[]表示可选 123INSERT INTO table_name[(列名1,...列名n)]VALUES (value1,value2,value3,...); 12INSERT INTO table_name (column1,column2,column3,...)VALUES (value1,value2,value3,...); INSERT INTO Websites (name, url, alexa, country) VALUES (‘百度’,’https://www.baidu.com/','4','CN‘); 更新update注意若无 WHERE 子句，所有的记录都将被更新 123UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition; 删除delete12DELETE FROM table_nameWHERE condition;","link":"/2025/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93/DML/"},{"title":"","text":"拓扑排序 拓扑序列：一个有向图中，对于任意的边，拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。 可以证明，一个有向无环图一定存在拓扑序列，但不一定唯一 算法： 所有入度为零的点入队，删除该点和所有出边 枚举所有入队的点的指向的点，让其入度减1，若是这些点入度变为零，则入队；若是不为零，不管，直到其他点不断递归到指向它的点，使得入度最终变为零，再入队。 不断重复以上过程，直到集合 𝑆 为空。检查图中是否存在任何边，如果有，那么这个图一定有环路，否则返回 𝐿，𝐿 中顶点的顺序就是构造拓扑序列的结果。 首先仍然需要图的储存 其中q代表队列，d代表点的入度 12345678910111213141516#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,m;const int N=10010;int e[N],ne[N],h[N],idx;int q[N],d[N];void init(){ idx=0; menset(h,-1,sizeof(h); }void add(int a,int b){ e[idx]=b;ne[idx]=h[a];h[a]=idx;idx++; d[b]++} 然后是toposort 1234567891011121314bool toposort(){ int j=-1,k=0; for(int i=0;i&lt;n;i++) if(d[i]==0)q[++j]=i; while(k&lt;=j){ for(int head=h[q[k]];head!=-1;head=ne[head]){ int nt=e[head]; d[nt]--; if(d[nt]==0)q[++j]=nt;}} return j==n-1;} main函数中，输出topo序列的逻辑 发现我们q[]刚好就是节点的排序，满足前面的节点不依赖于后面的节点 123if(toposort()){ for(int i=0;i&lt;n;i++)cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;}","link":"/2025/09/28/%E6%90%9C%E7%B4%A2/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"","text":"子集生成生成某个整数序列的所有可能子集 下面以从1-n的整数集，无重复数字 举例 增量构造法（递归）思路是从第一位开始，对于每一位而言，依次填入这一位后面的所有值，而后面的后面又是这样填，即递归。 若是算法每一步都对，有正确的初始化值，且有终止条件，则可用递归 例如，1 2 3的递归过程用解释树构造如下 a:构造的子集 s:s为当前加入的值，若cur为零，则初始化为1，否则为a[cur-1]的下一个值 123456789void print_subset(int n,int *a,int cur){ for(int i=0;i&lt;cur;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; int s=cur?a[cur-1]+1:1; for(int i=s;i&lt;=n;i++){ a[cur]=i; print_subset(n,a,cur+1); }} 位向量法(决策树)我们构造一个向量a,a[i]为0或1,a[i]==1意味着子集含有i 比如a[4]=0,1,1,0;对应子集为2 3. 注意这里递归函数没有for循环限制数量，需要return ； 对于某一位而言，下一位数要么有，要么没有，以此构造递归式 12345678910111213void print_subset1(int n,int *a,int cur){ if(cur==n){ for(int i=0;i&lt;n;i++){ if(a[i])cout&lt;&lt;i+1&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; return ; } a[cur]=1; print_subset1(n,a,cur+1); a[cur]=0; print_subset1(n,a,cur+1);} 二进制法惊讶的发现，我们子集可以看成一个数组，每一位取和不取的集合！将取与不取看成01的话，子集就代表一个二进制串！（和位向量法类似） 先枚举二进制数（就是1-2^n，二进制和十进制没区别），对于每个二进制数，打印出其对应的子集 s&amp;1&lt;&lt;i即s的第i位与上1,判断s的第i位是否为1 很优雅的实现 1234567891011int main(){for(int i=1;i&lt;(1&lt;&lt;4);i++) print_subset2(4,i);}void print_subset2(int n,int s){ for(int i=0;i&lt;n;i++){ if(s&amp;1&lt;&lt;i)cout&lt;&lt;i+1&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;}","link":"/2025/10/21/%E6%90%9C%E7%B4%A2/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90/"},{"title":"","text":"枚举排列枚举排列，即列出一个集合的所有排列可能，考虑字典序的话，通常有递归(树深搜)和stl(next_permutation)两种方法 next_permutation()函数声明next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) first和last是迭代器，一般我们用指针就够了： next_permutation(p,p+n) 函数作用找出当前序列的下一个排列 函数算法1.从后向前找到第一个 升序对：a[i] &lt; a[i+1]。 2.从后向前找到第一个比 a[i] 大的元素 a[j]，交换 a[i] 和 a[j]。 3.将 a[i+1] 到末尾逆序。 例如，求32154的下一个排列： 123453 2 1 5 4--1 5第一个升序(i=2)，4比1大(j=4)交换--3 2 4 5 1逆序--3 2 4 1 5 例子输入n个散乱的数 先sort排序，再用next_permutation求下一个排序 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10;int main(){ int n; cin&gt;&gt;n; int p[maxn]; for(int i=0;i&lt;n;i++){ cin&gt;&gt;p[i]; } sort(p,p+n); do{ for(int i=0;i&lt;n;i++){ cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; }while(next_permutation(p,p+n));} 递归求思路是这样，我们从开头固定数字，这样只需要递归的求后面几位的字典序即可 如我们有1 2 3 4，就先固定开头为1，再递归求后面，后面又可以先固定第二位为2，再递归，直到递归完。 算法过程 传入三个变量*n(数组),len数组长,cur已经固定的数的末尾位置 当cur==len说明全部固定完成，输出字典序，return，进入上一层递归。 否则我们从数组中所有的数中从小到大选出一个没被用于固定的数，作为当前的值，再递归。 1234567891011121314151617void print_permutation(int *n,int len,int cur){ if(cur==len){ for(int i=0;i&lt;len;i++)std::cout&lt;&lt;n[i]&lt;&lt;&quot; &quot;; std::cout&lt;&lt;std::endl; } else for(int j=1;j&lt;len;j++){ bool done=true; for(int i=0;i&lt;cur;i++){ if(j==n[i])done=false; } if(done){ n[cur]=j; print_permutation(n,len,cur+1); } }} 如 3 1 2 1最小，固定,进入下一层递归 2最小，固定，进入下一层 3最小，固定，进入下一层 cur==len,输出1 2 3，return 回固定了 1 2的那一层，此时for循环刚好走到尽头，继续递归到固定1 的那一层，递归前执行到了for(j=2,j&lt;3;j++)，所以现在j=3， 1 3固定，进入下一层 2固定，进入下一层 cur==len,输出1 3 2…以此类推。","link":"/2025/10/21/%E6%90%9C%E7%B4%A2/%E6%9E%9A%E4%B8%BE%E6%8E%92%E5%88%97/"},{"title":"","text":"1.题外话1a.登录在cmd里面输入sqlplus进入sqlplus，提示输入用户名 我们可以输入sqlplus as sysdba登录超级管理员，这条命令将以sys用户的身份登录数据库，并且具备DBA权限。也可以输入其他管理员名 有多个数据库的情况输入lsnrctl status，查看所有数据库名字 修改默认数据库set ORACLE_SID=lib202409091 （注意不是Lib_2024090914003，这个是数据库名不是系统表示符，应该是lib202409091(输入lsnrctl status，即oracle listener control监听器状态查看)） 然后正常sqlplus登入即可 输入set ORACLE_SID查看默认数据库名（新的cmd不会有ORACLE_SID变量，要设置才有） （输入sqlplus登陆的是默认数据库） 确认状态 SELECT instance_name FROM v$instance; 不小心创建了CDB数据库CDB是可插拔数据库，有个根容器CDB$ROOT,下面有若干数据库，初始默认是（可加）PDB$SEED（模板数据库，不可修改）和ORCLPDB（相当于我们原来的非CDB数据库） 所以想正常使用，只需进入CDBROOT后再进入根下的ORCLPDB即可 show CON_NAME; show PDBS; alter session set container=orclpdb; 已进入orclpdb ALTER PLUGGABLE DATABASE OPEN; 打开orclpdb 注意这时候show user是sys 所以我们不妨用easy connect CONN master/123456@localhost:1521/ORCLPDB 一步到位 返回cdbconnect /as sysdba sql developer登录注： CDB（容器数据库）：是根容器，总是自动打开。 PDB（可插拔数据库）：实际存放数据的可插拔容器，默认不会自动打开。 首先要打开orclpdb数据库 打开命令行，登录sqlplus as sysdba,输入 alter session set container=orclpdb; 切换会话 ALTER PLUGGABLE DATABASE OPEN; 打开当前所在的pdb容器 然后：注意要指明服务器名是orclpdb 这里的用户名就是我们创建的，角色其实就是权限等级，默认就是默认权限等级，可以向下选择 这里的SID是Oracle数据库实例的唯一标识符 一个实例下面有可能有很多服务。比如我们输入lsnrctl status 节选一段 服务 “orcl” 包含 1 个实例。 实例 “orcl”, 状态 READY, 包含此服务的 1 个处理程序…服务 “orclXDB” 包含 1 个实例。 实例 “orcl”, 状态 READY, 包含此服务的 1 个处理程序…服务 “orclpdb” 包含 1 个实例。 实例 “orcl”, 状态 READY, 包含此服务的 1 个处理程序…命令执行成功 语义相反，实际意思其实就是： 服务orcl → 连接到实例orcl的CDB根容器 服务orclpdb → 连接到同一个实例orcl，但是自动导向到PDB容器 所以我们服务名选择orclpdb（sid和服务名只能选一个，链接方式有优先级冲突，且sid的xe是xe版本，默认实例是xe，而我的是orcl（select instance_name from v$instance;)若用sid则需修改) 1b.创建用户我们需要登录具有相关权限的用户，比如sysdba，然后用 123create user 名字identified by 密码default tablespace 指定的表空间 12alter user 名字account unlock;grant dba权限 to user1; create user ...(用户名) identified by ...(密码) 创建用户。比如输入create user user1 identified by 123456 该用户现处于锁定状态，用命令alter user ... account unlock 解锁 后面可以用grant dba to user1 给user1赋予dba权限（最高权限，基本能干任何事） 1c.增加dbf文件1.dbf文件是什么？通常来说，一个表空间其实就是很多dbf文件和一些系统文件比如控制文件.ctl等，而这些.dbf文件大部分是数据文件，即表空间的实际储存文件，存储表，索引。小部分是临时文件。 2.为什么增加？当表空间要爆了的时候，且它设置为不会自动扩容（autoextend off）的时候 3.增加后系统怎么使用？ 总所周知，Oracle 在表空间中分配空间时，是以 区段为单位的。 所以Oracle 在管理空间时，并不会只往第一个文件写，而是以区段为单位在多个文件之间分配空间。当一个文件中的空闲区段用完后，自动切换到下一个文件继续写入。 这些不需要手动指定放在哪个文件，Oracle 会自动完成 添加dbf文件代码查看表空间信息 1SELECT TABLESPACE_NAME FROM DBA_TABLESPACES; 用alter tablespace语句增加 标准语法 1234567ALTER TABLESPACE 表空间名ADD DATAFILE '绝对路径/文件名.dbf'SIZE 100MAUTOEXTEND ON NEXT 50M MAXSIZE 1G; 查看是否添加 1select file_name from dba_data_files; 1d.创建表空间本质上就就是在创建文件 语法和创建dbf文件有点像 1234567CREATE TABLESPACE 表空间名DATAFILE '路径/文件名.dbf'SIZE 50MAUTOEXTEND ON NEXT 10M达到50后每次增加多少 MAXSIZE 1G最大空间; 杂项退出当前命令1.ctrl c 值得注意的是，你连续两次输错命令想退出后，在第二次输入ctrl c不会回到sqlplus，而是直接回到cmd。建议补一个; 2.保证不会运行的情况下，加一个;直接执行，让他报错就行 1.e 逻辑储存对于oracle来说，系统会初始创建很多表空间（物理上是很多数据文件），你在某个表空间里面创建一个数据对象（表，索引，回滚）的时候其实是分配了一个段，当你想扩容扩建的时候，分配的基本大小单元就是区，而一个区由数个数据块（最小i/o单位）组成。","link":"/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/"},{"title":"","text":"DCL控制权限 包括GRANT赋予 REVOKE收回","link":"/2025/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/dcl/"},{"title":"","text":"ddl（define)创建修改删除数据库对象 包括create,alter,drop，truncate（类似于delete，但是效率更高，delete是放入回滚段中，truncate无法回滚）","link":"/2025/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/ddl/"},{"title":"","text":"dql，query，查询主要是select 查询 selectSELECT column1, column2, ... FROM table_name; SELECT * FROM table_name; 示例查询当前schema有哪些表 SELECT table_name FROM user_tables; select distinct列出column的所有不同值（一个值会且仅会列一次） SELECT DISTINCT column1, column2, … FROM table_name; select where筛选行查找满足条件的列 SELECT column1, column2, … FROM table_name WHERE condition; where可加的有运算符 逻辑 特殊 1.运算符= &gt; &lt; &gt;= ,&lt;=, !=,&lt;&gt;（或！=） Select * from emp where ename=’SMITH’; 2.逻辑 and ，or，not Select * from emp where sal &gt; 2000 or comm &gt; 500; select * from emp where not sal &gt; 1500; 3.特殊 空值is null 在什么之间between 在什么之中in 模糊查询like Select * from emp where comm is null; Select * from emp where sal between 1500 and 3000; Select * from emp where sal in (5000,3000,1500); Select * from emp where ename like ‘M%’; 查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。%表示多个字值_，下划线表示一个字符 M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。 %M% : 表示查询包含M的所有内容。 %M_ : 表示查询以M在倒数第二位的所有内容 select order byORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。默认升序 SELECT column1, column2, … FROM table_name ORDER BY column1, column2, … ASC|DESC; 有多列的话先按1排序，若是相同则按column2排，以此类推","link":"/2025/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/dql/"},{"title":"","text":"","link":"/2025/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%93%E7%B3%BB.md/"},{"title":"","text":"维护数据一致性，包括commit(提交更改）,rollback（取消更改）,savepoint（设置保存点）","link":"/2025/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/tcl/"},{"title":"","text":"1.create创建表表存放在表空间之下，所以要指定放在那个表空间下，没指定就是默认表空间（一般是user） 查看默认表空间： 1select default_tablespace from user_users; 注意，select一般是从 Oracle 的数据字典视图（DBA__/ALL__/USER_*）中， 查询数据库对象的元数据（名称、状态、位置、属性等），其中前缀dba查整个数据库，all查当前用户 + 被授权对象，user查当前用户自己的对象 创建表： //注意是圆括号 CREATE TABLE books ( book_id NUMBER PRIMARY KEY,//主键 title VARCHAR2(100), price NUMBER(6,2), publish_date DATE ) TABLESPACE Spacelib; 注释1234表注释comment on table 名字 is '..';列注释comment on column table名.列名 is '..'; 查看注释（不存在表里面，而是存在数据字典里面的) 12345678查看表注释select 表名,commentsfrom user_tab_commentswhere table_name='表名';查看列注释select 列名,commentsfrom user_col_commentswhere table_name='表名'; 2.数据类型字符1.char 定长字符类型（未达到指定长度时，自动在末尾用空格补全）；非unicode。2.nchar 定长字符类型（未达到指定长度时，自动在末尾用空格补全）；根据unicode，所有字符都占两个字节。3.常用varchar2 变长字符类型（未达到指定长度时，不自动补全空格）；定义时需指定长度；最大为4000字节；非unicode。nvarchar2 变长字符类型（未达到指定长度时，不自动补全空格）；定义时需指定长度；最大为2000字节；根据unicode，所有字符都占两个字节。 long储存大文本，4GB 总而言之，varchar不补全空格，带n表示nation，用两个字节储存（包括英文，这会导致效率下降），更支持多国语言 数值型1.number(p,s) p精度，表示包括小数在内的总共有效位数 s，对于s而言，正 s 控制小数位，负 s 控制整数位四舍五入精度。表示小数点后多少位，s为负数就表示数字将被“四舍五入到 10 的 |s| 次幂 例如输入1234567.89 NUMBER(6,-2)–123400 number不指定大小代表number(38) 2.int子类型（int，samllint，decimal..本质都是number） 3.小数 float,binary_float,binary_double 日期date 存储 ：长度7字节默认DD-MON-RR 二进制clob:储存字符，最大存4个G blog：储存图像声音视频等二进制数据 3.对表的创建删除操作1.drop删除drop table table_name; 2.desc（describe）查看表结构desc table_name; 3.default 赋默认值gender char(1) default ‘M’, 4.NOT NULLgender varchar2(4) NOT NULL 代表该字段必须有有效值 4.ddl 修改表操作1.rename 修改表名rename old_name to new_name 2.alter add 增加列alter table table_name add( colume_name type …) alter table employee add(name number(4)) 3.alter drop 删除列alter table table_name drop(colume_name); 4.alter modify 修改列alter table table_name modify (colume_name type…) 5.dml(可回退) 修改记录1.insert into增加记录insert into table_name(colume 1…) values(value 1…); 2.update set where修改记录uptare table_name set colume_name=value where condition update employee set salary=1000 where name=’bob’; 3.delete from where删除delete from employee where job is null; 6.DML1.insert 插入insert into table_name(id,name,gender)values(1,a,m); 7.一些语法1.单引号 ' ' → 用于 字符串或字符常量 INSERT INTO Employee (gender) VALUES (‘F’); 一般情况用单引号 双引号 &quot; &quot; → 用于 引用标识符（列名、表名），可以包含大小写或空格 CREATE TABLE Employee (“Employee Name” VARCHAR2(50));","link":"/2025/10/18/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle%E8%A1%A8%E6%93%8D%E4%BD%9C/"},{"title":"","text":"什么是数据对象？他是指存储在 Schema（用户） 中、由 Oracle 数据字典管理的一切结构化对象。索引就是一种","link":"/2025/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1/"},{"title":"","text":"关于最短路，我们不区分是否有向，无向可以看作特殊的有向，把a-&gt;b和b-&gt;a都写进去 aw上关于以上几个算法的用途大致分类 多源：起点不确定，可能是任意点 汇点：终点 朴素dijkstra求解非负权图上单源最短路径 相比与堆优化版的dijkstra，这个适用于稠密图（堆优化版mlongn在稠密情况下是n^2logn），所以用邻接矩阵来存 松弛操作 先说明松弛操作，即当我们发现一条边能够 改善（缩短）源点到某个顶点的当前最短路径估计值 时，就更新这个顶点的最短路径估计值。 if d[v]&gt;d[u]+w(u,v)then update d[v]=d[u]+w(u,v) 即某个点a到b再到c的距离小于a到c的距离，就把ac直线距离松弛为a到b再到c 算法过程将结点分成两个集合：已确定最短路长度的点集（记为 𝑆 集合）的和未确定最短路长度的点集（记为 𝑇 集合）。一开始所有的点都属于 𝑇 集合。 1.初始化 𝑑𝑖𝑠(𝑠) =0，其他点的 𝑑𝑖𝑠 均为 +∞ a.从t里面的点中，计算源点到这些点的距离，最小的那个取出，放到s里面（一定最小，贪心） b.对刚放入s节点里面的边进行松弛操作（即更新和a中取出的节点有关节点的dist） 3.重复2，直到t为空 时间复杂度：n^2+m 代码首先维护几个结构 n是点数，m是边数，一般来说，nkm是稀疏图，mn^2是稠密图 g是邻接矩阵，一般是稠密图在用，g[i][j]表示i指向j的关系，值为零表示没边，为k表示边权为k dist[k]是k节点到源点的最短距离为dist[k] (未定，可动态变化); track[k]表示每个点的最短路是否确定 1234const int n=110,m=10010;int g[n][n];int dist[n];bool track[n]; 1234567891011121314151617181920212223//计算s节点到n节点的最短路,无则返回-1int dijkstra(int s){ menset(dist,0x3f,sizeof(dist)); dist[s]=0;//注意初始化track所有都是false，初始化track[s]是错的，他会在第一次循环里面自动初始化//因为如果s==1的时候，t将永远为零//循环执行n次 for(int i=0;i&lt;n;i++){//找到最短的节点t int t=-1; for(int j=1;j&lt;=n;j++){ if(!track[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j])) t=j;} for(int j=1;j&lt;=n;j++){ if(g[t][j])//可省，因为无路g为零，而dist[j]一定小于dist[t] dist[j]=min(dist[j],dist[t]+g[t][j]);} track[t]=true;} if(dist[n]==0x3f3f3f3f)return -1; return dist[n];}","link":"/2025/10/03/%E6%9C%80%E7%9F%AD%E8%B7%AF/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"title":"","text":"引入有 𝑛 个物品和一个容量为 𝑊 的背包，每个物品有重量 𝑤𝑖 和价值 𝑣𝑖 两种属性，要求选若干物品放入背包，使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。 每个物体只有取与不取两种可能的状态，即01背包问题 朴素思路首先思考这个问题里面的要素，有容量，重量，总重量，其中总重量是要求的，即f( ). 我们考虑dp状态： 𝑓𝑖,𝑗 为在只能放前 𝑖 个物品的情况下，容量为 𝑗 的背包所能达到的最大总价值。 对于这样一个dp状态，我们考虑这样一个划分（转移），每个状态可以划分为第i个物品取或不取的两种子情况，首先，若不取，显然f(i,j)=f(i-1,j)，若取，即f(i,j)=取第i个物品且要从前i个物品中取。为利用f表示，我们除去第i个物品，最后再加上起价值即可，即f(i,j)=f(i-1,j-w[i])+v[i] 得到dp转移方程f(i,j)=max(f(i-1,j),f(i-1,j-w[i])+v[i])，也就是说f(i,j)的最大总重量必然能通过i取与不取两条路不断被划分为子问题，以求解。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int maxn=110;const int manc=10010;int w[maxn],v[maxn],f[maxn][maxc];//全局数组默认为0int main(){ int n,cap; cin&gt;&gt;n&gt;&gt;cap; for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i]&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=cap;j++){ f[i][j]=f[i-1][j]; if(j&gt;=w[i])f[i][j]=max(f[i][j],f[i-1][j-w[i]]+v[i]);}} cout&lt;&lt;f[n][cap];} 滚动数组优化版我们这个f[][]开得很大容易mle，不妨用滚动数组优化。 注意到我们这个状态转移的更新只用到了f[i-1][…],所以我们不妨舍弃第一维，只用一个一维数组fj储存f(i,j)，即每次更新一层即可，前面的i-2层用之则弃，这样滚动地更新。 故新状态转移 𝑓𝑗=max(𝑓𝑗,𝑓𝑗−𝑤[𝑖]+𝑣[𝑖]) 之前的核心代码 123456for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=cap;j++){ f[i][j]=f[i-1][j]; if(j&gt;=w[i])f[i][j]=max(f[i][j],f[i-1][j-w[i]]+v[i]);}} 砍掉f[i][j]=f[i-1][j] (恒成立） 调换内层循环顺序（j=cap从大递减，否则f[j]=max(f[j],f[j-w[i]]+v[i]);将会用到更新后的f[j-w[i]]+v[i]），我们需要的是更新前的 优化为 12345for(int i=1;i&lt;=n;i++){ for(int j=cap;j&gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]);}}","link":"/2025/11/06/1.dp/%E8%83%8C%E5%8C%85dp.md/01%E8%83%8C%E5%8C%85/"},{"title":"","text":"一般来说，dp问题可以从状态表示f[i][j]和状态计算两个角度来思考","link":"/2025/11/10/1.dp/%E8%83%8C%E5%8C%85dp.md/dp%E6%80%9D%E8%B7%AF/"},{"title":"","text":"有很多组背包，每一组里面只能选一个 我们考虑dp:旨在前i组 物品里面，在容量为cap的情况下最大选多少 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;const int maxn=110;//组数const int maxm=21;//每组最多int s[maxn],v[maxn][maxm],w[maxn][maxm];int f[maxn*maxm];int main(){ int n,cap; cin&gt;&gt;n&gt;&gt;cap; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s[i]; for(int j=1;j&lt;=s[i];j++){ cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; } } for(int i=1;i&lt;=n;i++) for(int j=cap;j&gt;=0;j--) for(int k=1;k&lt;=s[i];k++) if(j&gt;=w[i][k])f[j]=max(f[j],f[j-w[i][k]]+v[i][k]); }","link":"/2025/12/02/1.dp/%E8%83%8C%E5%8C%85dp.md/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/"},{"title":"","text":"完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。 和01背包一样，我们仍然考虑f[i][j]为前i个物品，总体积不大于j的选法的max。 朴素思路(慢的一比，n^3)：考虑状态转移方程f[i][j]为第i个物品选择0，1，2，…..k个（总有一个k，因为背包容量是有限的）共k+1个状态因此f[i][j]=f[i-1][j]+f[i-1][j-w[i]]+v[i]+….因此里面还要增加一层循环去便利这k个状态，所以复杂度来到n^3 优化版 我们考虑 1f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i],f[i-1][j-2w[i]]+2v[i],...)1式 再考虑 1f[i][j-w[i]]= max(f[i-1][j-w[i]],f[i-1][j-w[i]-w[i]]+v[i],...)2式 我们发现，1式的后面n-1项刚好等于1式+v[i]，所以这里我们“错位相减” 得 f[i][j]=max(f[i-1][j],f[i][j-w[i]]+v[i]) 省略一维进一步得 f[j]=max(f[j],f[j-w[i]]+v[i]) 实际上可以这样思考，我们f(j)是从f(j-w),f(j-2w),f(j-3w)…优化过来的，但是我们之前f(j-w)得优化已经包含了f(j-2w),f(j-3w)…等，所以可以直接从f(j-w)优化 值得注意的是，我们第二层for循环不必像01背包那样逆着来，因为我们状态转移方程里面第二个f[i][j-w]+v就是需要这一层的（01背包是f[i-1][j-w[i]]+v[i]])，逻辑刚好 代码如下 12345for(int i=1;i&lt;=n;i++){ for(int j=w[i];j&lt;=cap;j++){ f[j]=std::max(f[j],f[j-w[i]]+v[i]);}}","link":"/2025/11/10/1.dp/%E8%83%8C%E5%8C%85dp.md/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"},{"title":"","text":"多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 𝑘𝑖 个，而非一个。 （我们尝试用完全背包的思路优化，发现失败。因为多重背包数量是有限的，假设我们背包空间十分大，把ki个物品全部取完，就会导致f[j]和f[j-w[i]]两个都能取完所有的ki物品，和完全背包是不一致的） 所以我们回归到01背包问题，朴素思路，将k个物品看成k个不一样的，时间复杂度（∑s[i]*cap*n) 利用二进制优化： 我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 𝐴𝑖,1,𝐴𝑖,2」与「同时选 𝐴𝑖,2,𝐴𝑖,3」这两个完全等效的情况。 我们尝试将物品捆绑为1,2,4,8…2^k,cap-(2^(k+1)-1),这样你选取任意数量的物品，都能从这些二进制数里面组合得到。（比如你选10个—2和8）同时可以证明，在2^k和cap之间的部分，也不存在遗漏，都有组成方案。 代码 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;const int maxv=10010;const int maxn=2000;int f[maxv];int v[maxn],w[maxn];int main(){ int n,cap; cin&gt;&gt;n&gt;&gt;cap; int index=0; for(int i=1;i&lt;=n;i++){ int cnt=1,a,b,s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; while(s&gt;=cnt){ index++; v[index]=cnt*a; w[index]=cnt*b; s-=cnt; cnt*=2; } if(s&gt;0){ index++; v[index]=s*a; w[index]=s*b; } } for(int i=1;i&lt;=index;i++) for(int j=cap;j&gt;=w[i];j--) f[j]=max(f[j],f[j-w[i]]+v[i]); cout&lt;&lt;f[cap]&lt;&lt;endl;} 代码细节： 1.一次for循环是在初始化那k个数的捆绑，我们不知道一共扩展为多少个物品，所以我们需要一个全局变量index去记录第几个物品。 2.我们v[],w[]都是从1开始的 3.cnt代表当前第index个物品由多少个物品捆绑成。 4.while循环后那一步是在让剩余的物品当作一捆 5.我们while循环s&gt;=cnt可以，代表剩余的量必须大于等于当前捆绑的数量，否则停止，并让剩余的量凑作一捆。当s=cnt时，代表整个数列刚好为一个等比（s-∑cnt=2^(k+1))，此时继续循环，下一次s被减为0，这种情况会被if(s&gt;0)排除在外，因为s=0，已经初始化完了 6.当然，也可以while(s&gt;cnt)，这时候不需要if(s&gt;0)","link":"/2025/11/30/1.dp/%E8%83%8C%E5%8C%85dp.md/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"},{"title":"","text":"dfs是什么？DFS，即深度优先搜索，常用于遍历搜索树或图。 该类搜索算法的特点在于，将要搜索的目标分成若干「层」，每层基于前几层的状态进行决策，直到达到目标状态。 DFS 最显著的特征在于其 递归调用自身。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 每个点仅访问一次。符合以上两条规则的函数，便是广义上的 DFS。 遍历图先了解图的储存 ( 树其实可以算图的一种 ) 图的储存:邻接矩阵，邻接表1.对于邻接矩阵而言，如果我们a-&gt;b有边，就让P[a][b]=true;以此类推。 2.我们通常用邻接表储存 邻接表可以看成链表数组，一个数组里面每一个元素都是一个链表，对应每一个链表指向的所有节点。类比vector&lt;int&gt; a[maxn]. 数据结构定义 123456789//我们假设有a个节点，b条无向边（一般题目会给）const int n=a+10,m=2*b+10;//2*b表明无向边可以看成两条特殊的有向边int h[n],e[m],ne[m],idx;//h[i]表示第i个节点的头节点，后面接入i节点指向的所有节点的idx索引，无顺序之分。e[idx]表示第idx个空间分配的值，ne[idx]表示第idx个空间的值所指向的的下一个值的索引。idx从零开始递增。//整体而言可以把e[]看作一个内存池，从这个内存池里面取出边，一个一个赋值，接在h[]后面void add(int a,int b){ e[idx]=b;ne[idx]=h[a];h[a]=idx;idx++;}//add函数解析：把e的第idx位置存成b，ne[idx]=h[a]表示把原来h[a]指向的索引成为ne的下一个索引，在让h[a]指向idx，idx自增，即可完成插入 dfs遍历连通图图一般是连通图，若是非连通图，一般只能遍历起点所在的连通分图 算法通常是通过递归实现 123456789bool if_get[n]={false};//表示某个点是否被搜索过//传入u号节点，if_get[u]为true表示遍历过了，然后找到u节点的下一个节点开始dfs，直到每个节点都找到了。void dfs(int u){ if_get[u]=true;for(int i=h[u];i!=-1;i=ne[i]){ int j=e[i]; if(!if_get[i])bfs(i);}} 遍历树通常为：若是为空则返回，否则递归子树1，子树2…. 12345678void DLRtraverse(BitTree T){ if(T==NULL)return ; else{ cout&lt;&lt;T-&gt;data&lt;&lt;endl; DLRtraverse (T-&gt;lchild); DLRtraverse (T-&gt;rchild);}}","link":"/2025/09/09/%E6%90%9C%E7%B4%A2/dfs/"},{"title":"","text":"目标文件分为可重定位目标文件，可执行目标文件，共享目标文件（动态链接） 对于目标文件而言，每个系统的都不一样，windows是PE格式，linux是ELF格式 对于linux的ELF目标文件，通常分为ELF头，.text,.rodate,.data等数个节（在可执行文件加载到内存里则称之为段），以及最后的节头部表 elf头描述系统子，大端还是小端，elf头大小，机器类型等等 对于节，每个节都有不同的作用，例如.text储存已编译的机器代码，.rodata储存只读数据等 而节头部表记录了 ELF 文件中每一个节的位置、大小、类型和属性 命令:readelf -h main.o能查看main.o的elfheader readelf -S main.o 查看main.o 的section header","link":"/2026/01/18/csapp/7.%E9%93%BE%E6%8E%A5/2.%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"},{"title":"","text":"1.反汇编 objdump -d name.o","link":"/2026/01/20/csapp/3.%E6%B1%87%E7%BC%96/%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"},{"title":"","text":"整体流程源代码–(预处理)–main.i–(编译处理)–main.s–(汇编)–main.o–linked–可执行文件 1.预处理（c preprocessor，cpp）命令： cpp main.c -o main.i or gcc -E -o main.i main.c (-E告诉处理器只弄到main.i) 2.编译（c compiler）命令：（大写！！） cc -S -o main.s main.c or gcc -S -o main.s main.c 3.汇编 （assembler） as -o main.o main.c 4.链接 手动： ld -static -o prog main.o sum.o /usr/lib/…..o(有六七个系统带的.o文件作为启动等功能，缺的话无法运行)","link":"/2026/01/18/csapp/7.%E9%93%BE%E6%8E%A5/1.%E6%80%BB%E4%BD%93%E5%A4%84%E7%90%86/"}],"tags":[],"categories":[],"pages":[]}