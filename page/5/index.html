<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-08-26T07:12:49.203Z" title="2025/8/26 15:12:49">2025-08-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-26T08:57:01.386Z" title="2025/8/26 16:57:01">2025-08-26</time></span><span class="level-item">4 minutes read (About 616 words)</span></div></div><div class="content"><p>哈希表（Hash Table，也叫散列表）是一种基于哈希函数的数据结构，用来实现快速的查找、插入和删除操作。</p>
<p>关键思想是，如果我们有很多十分分散的数据，直接储存查找需要大量空间，那么我们不妨使存储位置与存储值之间建立直接关系，从而可以把一堆比较大的数据压缩到一个较小的数据中，这样我们可以很大的压缩空间。</p>
<p>即 <strong>p&#x3D;H(key)</strong> H是散列函数，p是散列地址，key就是储存的关键字</p>
<p>但是一个hash表很有可能遇到”冲突“，即我们不同的关键字，在进行hash(key)压缩后来到了同一个位置，导致无法区分，对此我们常采用开放地址法和链地址法</p>
<h4 id="构造hash"><a href="#构造hash" class="headerlink" title="构造hash"></a>构造hash</h4><p>1.规律：若已知数据的构成都具有某种规律，可根据规律定义hash</p>
<p>2.平方法：把数串平方，取固定的某几位作为映射方式</p>
<p>3.折叠：把数串平均分成几部分，相加，可作为最终hash地址</p>
<p>4.模：H(key)&#x3D;key%x. 最常用的一集</p>
<p><strong>注1：p最好取质数，并离2^n尽量远</strong>，</p>
<p><strong>注2：含负数的模的公式：A%B&#x3D;A-A&#x2F;B*B，有个结论是结果只与A的正负有关</strong> </p>
<h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><p>1.链地址：我们先进行一次处理如mod(p)得到p个可能的hash地址，然后以这0-p建立p个单链表，分别储存冲突的数字（类比图的储存，一个节点后跟着他到的所有边)</p>
<p>由于”注1“，我们先找到大于hash范围的最小质数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_prime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j*j&lt;=x;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">    flag=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>)x+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现find_prime(10000)&#x3D;10007</p>
<p>插入操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10007</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hnum=(number%N+N)%N;<span class="comment">//可处理number是负数的情况，将其映射到正数，如果A是正数就和A%B一样的，如果A是负数等于A%B+B一定是正数</span></span><br><span class="line">e[idx]=number,ne[idx]=h[hnum],h[hnum]=idx,idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hnum=(number%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-07-09T09:31:20.613Z" title="2025/7/9 17:31:20">2025-07-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-07-27T07:55:43.221Z" title="2025/7/27 15:55:43">2025-07-27</time></span><span class="level-item">6 minutes read (About 942 words)</span></div></div><div class="content"><h4 id="算法algorithm"><a href="#算法algorithm" class="headerlink" title="算法algorithm"></a>算法algorithm</h4><h1 id="容器container"><a href="#容器container" class="headerlink" title="容器container"></a>容器container</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>#include&lt;vector&gt; </p>
<p><code>vector</code> 的数据储存在堆空间中，不会爆栈。一般情况 <code>vector</code> 可以替换掉普通数组。</p>
<p>注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销</p>
<h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>vector&lt;类型&gt; arr(长度，[初值]) </p>
<p>括号及里面的内容可省，默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr; <span class="comment">// 构造int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 构造初始长100的int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ()); <span class="comment">// 构造初始100行，不指定列数的二维数组 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">200</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始200列的二维数组，初值为-1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>],没初始化的二维数组，每一个arr[i]都是一个vector，相当行数不变，列数不定的二维数组</span><br><span class="line">arr[i].push_back;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个二维数组可以理解为100个元素，每个元素都是一维vector</p>
<p>注意，创建完后，可以当作普通数组用，如</p>
<p>vector&lt;int&gt; arr(100),arr[0]&#x3D;1;</p>
<h5 id="尾增尾删push-back-pop-back"><a href="#尾增尾删push-back-pop-back" class="headerlink" title="尾增尾删push_back(),pop_back()"></a>尾增尾删push_back(),pop_back()</h5><ul>
<li><strong><code>.push_back(元素)</code></strong>：在 vector 的最后一个内存后增加一格内存，并给这个内存赋值，数组长度+1(!)</li>
<li><strong><code>.pop_back()</code></strong>：删除 vector 的最后一格内存及其元素，数组长度-1</li>
</ul>
<p>arr.push_back(100);</p>
<p>arr.pop_back();</p>
<p>arr&#x3D;{0,0,0,0},arr.push_back(9)–&gt;arr&#x3D;{0,0,0,0,9}</p>
<h5 id="获取长度-size"><a href="#获取长度-size" class="headerlink" title="获取长度.size()"></a>获取长度.size()</h5><p>获取当前 vector 的长度</p>
<p>注意返回值是无符号整数size_t</p>
<p>o(1)复杂度</p>
<h5 id="清空-clear"><a href="#清空-clear" class="headerlink" title="清空.clear()"></a>清空.clear()</h5><p>arr.clear();</p>
<p>o(n)复杂度</p>
<h5 id="判空-empty"><a href="#判空-empty" class="headerlink" title="判空 .empty()"></a>判空 .empty()</h5><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p>
<p>时间复杂度：o(1)</p>
<h5 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h5><p><strong><code>.resize(新长度, [默认值])</code></strong></p>
<p>修改 vector 的长度</p>
<p>如果是缩短，则删除多余的值</p>
<p>如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变）</p>
<p>时间复杂度：o(n)</p>
<h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><p>#include&lt;stack&gt;</p>
<p>栈不可访问内部元素，只能用弹出看栈顶,所以感觉可以用vector代替stack，或者手写。–</p>
<p>vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p>
<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>stack&lt;类型&gt; a,不初始化</p>
<h5 id="进出栈"><a href="#进出栈" class="headerlink" title="进出栈"></a>进出栈</h5><p>a.push(元素)进</p>
<p>a.pop()弹出</p>
<h5 id="取栈顶"><a href="#取栈顶" class="headerlink" title="取栈顶"></a>取栈顶</h5><p>a.top();</p>
<p>int topnum&#x3D;a.top();</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p>queue&lt;类型&gt; que</p>
<h5 id="进出队"><a href="#进出队" class="headerlink" title="进出队"></a>进出队</h5><p>.push(元素)</p>
<p>.pop()</p>
<h5 id="取队尾队首"><a href="#取队尾队首" class="headerlink" title="取队尾队首"></a>取队尾队首</h5><p>.front()</p>
<p>.back()</p>
<p>int getfront&#x3D;que.front();</p>
<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>自动去重，加入元素后，元素自动从小到大排序的一个容器</p>
<p>注意set不支持下标操作，需要用迭代器</p>
<h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>#include&lt;set&gt;</p>
<h5 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h5><p>set&lt;int&gt; dict;</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>插入：dict.insert(x);</p>
<p>删除：dict.erase(x);</p>
<p>查找：dict.count(x) &#x2F;dict.find(x);</p>
<p>找到了，返回指向x的迭代器，没找到返回特殊迭代器dict.end()</p>
<p>个数：dict.size(x);</p>
<p>清空：dict.clear(x);</p>
<p>判断为空：dict.empty(x);</p>
<h2 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h2><p>新元素被添加到堆的末尾，然后通过”上浮”操作调整位置，保持堆性质，时间复杂度：O(log n)</p>
<h5 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h5><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p>
<p>类型：要储存的数据类型</p>
<p>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</p>
<p>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</p>
<p>priority_queue&lt;int&gt; pque;默认为大顶堆</p>
<p>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; 储存int的小顶堆</p>
<h5 id="进出堆"><a href="#进出堆" class="headerlink" title="进出堆"></a>进出堆</h5><p>.push(元素)</p>
<p>.pop()</p>
<h5 id="取堆顶-大堆顶就是最大值，小就是最小值"><a href="#取堆顶-大堆顶就是最大值，小就是最小值" class="headerlink" title="取堆顶(大堆顶就是最大值，小就是最小值)"></a>取堆顶(大堆顶就是最大值，小就是最小值)</h5><p>只可访问堆顶，其他元素都无法读取到。</p>
<p>.top()</p>
<p>int a&#x3D;pque.top();</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-07-09T09:29:53.805Z" title="2025/7/9 17:29:53">2025-07-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-07-11T03:46:13.195Z" title="2025/7/11 11:46:13">2025-07-11</time></span><span class="level-item">a few seconds read (About 15 words)</span></div></div><div class="content"><h3 id="头文件：-include"><a href="#头文件：-include" class="headerlink" title="头文件：#include&lt;algorithm&gt;"></a>头文件：#include&lt;algorithm&gt;</h3><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p>int arr[maxn];</p>
<p>sort(arr,arr+maxn-1</p>
<p>)</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-07-09T09:29:24.336Z" title="2025/7/9 17:29:24">2025-07-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-02T01:19:16.367Z" title="2025/8/2 09:19:16">2025-08-02</time></span><span class="level-item">7 minutes read (About 993 words)</span></div></div><div class="content"><h4 id="1-万能头-include"><a href="#1-万能头-include" class="headerlink" title="1.万能头#include&lt;bits&#x2F;std++.h&gt;"></a>1.万能头#include&lt;bits&#x2F;std++.h&gt;</h4><h4 id="2-命名空间namespace"><a href="#2-命名空间namespace" class="headerlink" title="2.命名空间namespace"></a>2.命名空间namespace</h4><p>namespace准确来说是防止重名，而对某些变量，函数的修饰，因为它并不是物理储存结构，而是编译时的二进制修饰。不恰当的类比:int x;struct x{int x;};这两个语句不冲突，但是去掉struct 就重名了。</p>
<h5 id="namespace性质"><a href="#namespace性质" class="headerlink" title="namespace性质"></a>namespace性质</h5><h6 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h6><p>namespace S{</p>
<p>}括号里面放函数，变量等</p>
<h6 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h6><p>命名空间可以嵌套</p>
<p>namespace Outer { namespace Inner { void Func() { } }</p>
<p>在一个文件里面，如果有全局</p>
<p>访问:Outer::Inner::Func();</p>
<h6 id="可多次使用"><a href="#可多次使用" class="headerlink" title="可多次使用"></a>可多次使用</h6><h6 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h6><p>完全限定名：<code>std::cout</code></p>
<p>只用当前一次</p>
<p>using声明：<code>using std::cout;</code></p>
<p>用一个，输入该命令后全域都可以使用</p>
<p>using指令：<code>using namespace std;</code></p>
<p>命名空间导入</p>
<h5 id="namespace变量性质"><a href="#namespace变量性质" class="headerlink" title="namespace变量性质"></a>namespace变量性质</h5><p>当前文件修改namespace里面的变量会生效，但是不会影响到下一次编译</p>
<p>在某处引入using namespace A或者using A::…，只会在当前作用域生效</p>
<p>至此，using namespace std是什么已经很清楚了，注意std权限是可读，无法修改cout等函数，假设用hexedit修改源码，会造成编译立即崩溃</p>
<h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h4><p>int func(int &amp;a){}</p>
<p>表示a按照传引用 传递，也就是外面的值可以像用指针那样改变</p>
<p>后面a正常用，不要当成指针*a用。</p>
<h4 id="4-头文件细微变化"><a href="#4-头文件细微变化" class="headerlink" title="4.头文件细微变化"></a>4.头文件细微变化</h4><p>多头文件#include&lt;iostream&gt;</p>
<p>而c头文件可以正常用，但是推荐去掉.h,前面加c，比如&lt;stdio.h&gt; —&gt; &lt;cstdio&gt;</p>
<h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h4><p>迭代器是 C++ STL 提供的一种泛型指针，这种数据类型用于检查和遍历容器内元素，理解为指针即可</p>
<h6 id="begin和end"><a href="#begin和end" class="headerlink" title="begin和end"></a>begin和end</h6><p>begin()指向容器的第一个元素，注意！end()指向容器的最后一个元素的后一个元素！end通常作为未查找到的返回值</p>
<h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>vector &lt;int&gt;::iterator it;</p>
<p>for(set &lt;int&gt;::iterator it&#x3D;dict.begin();it!&#x3D;dict.end();++it)</p>
<p>cout&lt;&lt;*it&lt;&lt;”\n”;</p>
<h6 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h6><p>1.随机访问迭代器 ：</p>
<p>功能最全，支持解引用，成员访问，自增自减，迭代器加减，迭代器距离，比较，下标。和数组指针几乎一样</p>
<p>vector，deque容器支持</p>
<p>如</p>
<p>vector&lt;int&gt;::iterator it &#x3D; v.begin();<br>    cout &lt;&lt; *it &lt;&lt; endl;      &#x2F;&#x2F; 输出第一个元素<br>    cout &lt;&lt; *(it + 3) &lt;&lt; endl; &#x2F;&#x2F; 输出第四个元素<br>    it +&#x3D; 2;                  &#x2F;&#x2F; 跳跃到第3个元素<br>    cout &lt;&lt; *it &lt;&lt; endl;      &#x2F;&#x2F; 输出<br>    cout &lt;&lt; (v.end() - v.begin()) &lt;&lt; endl; &#x2F;&#x2F; 元素个数<br>    cout &lt;&lt; it[1] &lt;&lt; endl;    &#x2F;&#x2F; 相当于 *(it + 1)</p>
<p>2.双向迭代器：</p>
<p>比随机访问迭代器更弱一点，不支持迭代器位置比较it_1&lt;it_2，和随即跳转it+n</p>
<p>list,set,map是双向</p>
<p>3.前向迭代器 多次读写，单向，输出迭代器，只写一次，单向，输入迭代器，只读一次，单向。很少用。</p>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>比如vector容器，动态扩容之后会重新找一块更大的空间，所以原来的迭代器会失效</p>
<h6 id="迭代器辅助函数"><a href="#迭代器辅助函数" class="headerlink" title="迭代器辅助函数"></a>迭代器辅助函数</h6><p>辅助函数可用于各种迭代器，通常用于写模板或泛型代码</p>
<p>#include&lt;algorithm&gt;</p>
<p>advance(it,n);使得迭代器向前&#x2F;后移动n，（随即迭代器里的it+&#x3D;n;)</p>
<p>distance（it2,it1)；计算两个迭代器之间距离，即元素个数。it2要&lt;&#x3D;it1</p>
<p>iter_swap(it1,it2);交换迭代器指向的值</p>
<h5 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h5><h6 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h6><p>用于处理字符串的输入输出流。从string里面读入</p>
<p>c++里面，流是数据从一个对象到另一个对象的流动。数据输入输出通过IO流实现，cin&#x2F;cout是istream，ostream创建的对象（cin，cout是抽象实现，不能创建和拷贝，但是可以引用，istream &amp; _cin&#x3D;cin对，istream _cin&#x3D;cin和istream _cin都错。 而stringstream不是抽象类，可以直接创建）</p>
<h6 id="2-创建-一般来说创建名为ss"><a href="#2-创建-一般来说创建名为ss" class="headerlink" title="2.创建(一般来说创建名为ss)"></a>2.创建(一般来说创建名为ss)</h6><p>a.直接创建</p>
<p>string arr(“hello world”);</p>
<p>stringstream ss;</p>
<p>ss&lt;&lt; arr;</p>
<p>cout &lt;&lt;ss.str()&lt;&lt;endl;</p>
<p>b.初始化创建</p>
<p>stringsream ss(“hello world”);</p>
<h6 id="3-输出"><a href="#3-输出" class="headerlink" title="3.输出"></a>3.输出</h6><p>调用ss.str();不能直接输出ss</p>
<h6 id="4-修改流"><a href="#4-修改流" class="headerlink" title="4.修改流"></a>4.修改流</h6><p>ss.str(“fuck world”)</p>
<h6 id="5-常见用法"><a href="#5-常见用法" class="headerlink" title="5.常见用法"></a>5.常见用法</h6><p>string line,wold;</p>
<p>while(getline(cin,line)){</p>
<p>stringstream ss(line)</p>
<p>while(ss&gt;&gt;word)…</p>
<p>}</p>
<h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p>自动推导类型</p>
<p>如auto x&#x3D;6—x为int</p>
<p>auto x&#x3D;arr.size();—x为size_t</p>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>一种类，string s&#x3D;”hello world”</p>
<p>1.访问元素可以通过s[i]或者s.at(i),</p>
<p>两者都可以修改原string串内容</p>
<p>s[i]无越界检查，但跟高效，s.at(i)会检查越界</p>
<p>2.方法.</p>
<p>数组长度 s.length()或者s.size()</p>
<p>是否为空 s.empty()</p>
<p>追加字符 s.append()</p>
<p>插入         s.insert(pos,str)</p>
<p>删除          s.erase(pos,len)</p>
<p>清空          s.clear()</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-05-16T02:55:09.729Z" title="2025/5/16 10:55:09">2025-05-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-05-28T12:12:55.619Z" title="2025/5/28 20:12:55">2025-05-28</time></span><span class="level-item">2 minutes read (About 259 words)</span></div></div><div class="content"><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><p>常见命令</p>
<p>gcc  draft.c  -o draft</p>
<p>把draft.c源文件编译,输出成draft</p>
<p>注意-o后面必须紧跟draft文件名，其他位置没有讲究。</p>
<p>gcc draft.c -g -o draft,生成调试信息，gdb要用</p>
<p>只要-o后面紧跟draft文件名，</p>
<p>gcc -g -o myprog main.c<br>gcc -o myprog -g main.c<br>gcc main.c -g -o myprog都是合法的</p>
<h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><p>用上面的-g命令编译下，</p>
<p>gdb .&#x2F;draft 启动</p>
<p>gdb r&#x2F;gdb run开始程序</p>
<p>gdb b 数字 在某一行加上断点</p>
<p>gdb b 函数名在函数处加上断点</p>
<p>遇到断点后 gdb l查看断点处10行代码</p>
<p>没遇到断点就是从开头依次输出10行代码</p>
<p>gdb l x,y查看x到y处代码</p>
<p>gdb g 变量名查看变量值</p>
<p>gbd x&#x2F;s 变量名 输出字符串变量 gdb x&#x2F;c 变量名 输出字符变量</p>
<p>gdb bt 查看调用的栈帧（backtrace）</p>
<p>gdb i b查看所有断点</p>
<p>gdb delete 1删除断点1 </p>
<p>gdb delete 删除所有断点</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-05-08T13:01:54.829Z" title="2025/5/8 21:01:54">2025-05-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-07-09T09:24:06.216Z" title="2025/7/9 17:24:06">2025-07-09</time></span><span class="level-item">13 minutes read (About 1886 words)</span></div></div><div class="content"><h5 id="1-计算程序进行时间"><a href="#1-计算程序进行时间" class="headerlink" title="1.计算程序进行时间"></a>1.计算程序进行时间</h5><p>#include&lt;time.h&gt;</p>
<p>double a &#x3D;clock():返回从开始到调用这里的clock时的时间。注意包含手动输入输出时间</p>
<p>CLOCKS_PER_SEC:常数，clock()&#x2F;CLOCKS_PER_SEC得到秒</p>
<p>用法a:</p>
<p>在cmd里面输入echo …(内容)|draft(程序名)</p>
<p>(在其他终端里面会错误，比如vscode默认的powershell，scanf读不进去),这样就不会算手动输入的时间</p>
<p>用法b:</p>
<p>double a&#x3D;clock();  …代码块 … double b&#x3D;clock();</p>
<p>b-a即该代码块的时间</p>
<p>注意：</p>
<p>手动点击调试按钮比gcc -o draft draft.c 后运行.&#x2F;draft慢</p>
<p>vscode-powershell:time used &#x3D; 0.093000000</p>
<p>cmd:time used &#x3D; 0.090000000</p>
<p>点击调试按钮：time used &#x3D; 0.205000000</p>
<h5 id="2-未结束：window程序输入完按enter未结束，尝试按ctrl-z再按enter"><a href="#2-未结束：window程序输入完按enter未结束，尝试按ctrl-z再按enter" class="headerlink" title="2.未结束：window程序输入完按enter未结束，尝试按ctrl+z再按enter"></a>2.未结束：window程序输入完按enter未结束，尝试按ctrl+z再按enter</h5><p>linux：直接按ctrl+d</p>
<h5 id="3-重定向读入文件freopen-“filename”-”mode”-stream"><a href="#3-重定向读入文件freopen-“filename”-”mode”-stream" class="headerlink" title="3.重定向读入文件freopen(“filename”,”mode”,stream)"></a>3.重定向读入文件freopen(“filename”,”mode”,stream)</h5><p>替换源流为stream</p>
<p>比如if(!freopen(“in.txt”,”r”,stdin))</p>
<p>filename文件名,可以是路径 ..\in.txt,D:\in.txt,.\in.txt</p>
<p>也可以是”CON”表示回到终端，比如   freopen(“CON”, “w”, stdout);，输出到终端</p>
<p>mode输入模式,有：</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;r&quot;</code></td>
<td>只读（文件必须存在）</td>
</tr>
<tr>
<td><code>&quot;w&quot;</code></td>
<td>只写（创建新文件或清空已有文件）</td>
</tr>
<tr>
<td><code>&quot;a&quot;</code></td>
<td>追加（写入到文件末尾）</td>
</tr>
<tr>
<td><code>&quot;r+&quot;</code></td>
<td>读写（文件必须存在）</td>
</tr>
<tr>
<td><code>&quot;w+&quot;</code></td>
<td>读写（创建新文件或清空已有文件）</td>
</tr>
<tr>
<td><code>&quot;a+&quot;</code></td>
<td>读写追加（写入到文件末尾，读取可从头开始）</td>
</tr>
</tbody></table>
<p>stream有stdin,stdout,stderr</p>
<h5 id="4-复制数组memcpy"><a href="#4-复制数组memcpy" class="headerlink" title="4.复制数组memcpy"></a>4.复制数组memcpy</h5><p>(注意，memcpy极快，甚至快于for循环赋值)</p>
<p>#include&lt;string.h&gt;</p>
<p>void *memcpy(void *dest, const void *src, size_t n)</p>
<p>dest是目标地址，复制的内容将写入这里,src是源地址，复制的内容从这里读取,n是要复制的字节数。</p>
<p>从int a数组复制k个值到b：memcpy(b,a,sizeof(int)*k);</p>
<h5 id="5-清零memset"><a href="#5-清零memset" class="headerlink" title="5.清零memset"></a>5.清零memset</h5><p>这个同上，也快</p>
<p>作用是给某个数据结构赋固定值。可以初始化内存，清空字符串缓冲区，初始化结构体。但注意value是字节，如使用memset(&amp;p,1,sizeof(p)，每个 int占 4 字节，所以p[i]的实际值是0x0101010（十进制 16843009），而不是 1。所以我们一般用于清零</p>
<p>#include&lt;string.h&gt;</p>
<p>void *memset(void *ptr, int value, size_t num);</p>
<p>memset(&amp;p,0,sizeof(p)</p>
<h3 id="6-c-初步"><a href="#6-c-初步" class="headerlink" title="6.c++初步"></a>6.c++初步</h3><h4 id="万能头-include"><a href="#万能头-include" class="headerlink" title="万能头#include&lt;bits&#x2F;std++.h&gt;"></a>万能头#include&lt;bits&#x2F;std++.h&gt;</h4><h4 id="命名空间namespace"><a href="#命名空间namespace" class="headerlink" title="命名空间namespace"></a>命名空间namespace</h4><p>namespace准确来说是防止重名，而对某些变量，函数的修饰，因为它并不是物理储存结构，而是编译时的二进制修饰。不恰当的类比:int x;struct x{int x;};这两个语句不冲突，但是去掉struct 就重名了。</p>
<h5 id="namespace性质"><a href="#namespace性质" class="headerlink" title="namespace性质"></a>namespace性质</h5><h6 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h6><p>namespace S{</p>
<p>}括号里面放函数，变量等</p>
<h6 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h6><p>命名空间可以嵌套</p>
<p>namespace Outer {<br>    namespace Inner {<br>        void Func() { }<br>    }</p>
<p>在一个文件里面，如果有全局</p>
<p>访问:Outer::Inner::Func();</p>
<h6 id="可多次使用"><a href="#可多次使用" class="headerlink" title="可多次使用"></a>可多次使用</h6><h6 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h6><p>完全限定名：<code>std::cout</code></p>
<p>只用当前一次</p>
<p>using声明：<code>using std::cout;</code></p>
<p>用一个，输入该命令后全域都可以使用</p>
<p>using指令：<code>using namespace std;</code></p>
<p>命名空间导入</p>
<h5 id="namespace变量性质"><a href="#namespace变量性质" class="headerlink" title="namespace变量性质"></a>namespace变量性质</h5><p>当前文件修改namespace里面的变量会生效，但是不会影响到下一次编译</p>
<p>在某处引入using namespace A或者using A::…，只会在当前作用域生效</p>
<p>至此，using namespace std是什么已经很清楚了，注意std权限是可读，无法修改cout等函数，假设用hexedit修改源码，会造成编译立即崩溃</p>
<h4 id="算法algorithm"><a href="#算法algorithm" class="headerlink" title="算法algorithm"></a>算法algorithm</h4><h4 id="容器container"><a href="#容器container" class="headerlink" title="容器container"></a>容器container</h4><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>#include&lt;vector&gt; </p>
<p><code>vector</code> 的数据储存在堆空间中，不会爆栈。一般情况 <code>vector</code> 可以替换掉普通数组。</p>
<p>注意：若长度已确定，那么就直接在构造函数指定长度。因为如果不确定，后面每push_back一次都会耗尽内存而重新分配，产生额外时间开销</p>
<h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>vector&lt;类型&gt; arr(长度，[初值]) </p>
<p>括号及里面的内容可省，默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr; <span class="comment">// 构造int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 构造初始长100的int数组 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ()); <span class="comment">// 构造初始100行，不指定列数的二维数组 </span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">200</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始200列的二维数组，初值为-1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个二维数组可以理解为100个元素，每个元素都是一维vector</p>
<h5 id="尾增尾删push-back-pop-back"><a href="#尾增尾删push-back-pop-back" class="headerlink" title="尾增尾删push_back(),pop_back()"></a>尾增尾删push_back(),pop_back()</h5><ul>
<li><strong><code>.push_back(元素)</code></strong>：在 vector 的最后一个数据后尾接一个元素，数组长度+1</li>
<li><strong><code>.pop_back()</code></strong>：删除 vector 的最后一个数据尾部元素，数组长度-1</li>
</ul>
<p>arr.push_back(100);</p>
<p>arr.pop_back();</p>
<h5 id="获取长度-size"><a href="#获取长度-size" class="headerlink" title="获取长度.size()"></a>获取长度.size()</h5><p>获取当前 vector 的长度</p>
<p>注意返回值是无符号整数size_t</p>
<p>o(1)复杂度</p>
<h5 id="清空-clear"><a href="#清空-clear" class="headerlink" title="清空.clear()"></a>清空.clear()</h5><p>arr.clear();</p>
<p>o(n)复杂度</p>
<h5 id="判空-empty"><a href="#判空-empty" class="headerlink" title="判空 .empty()"></a>判空 .empty()</h5><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p>
<p>时间复杂度：o(1)</p>
<h5 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h5><p><strong><code>.resize(新长度, [默认值])</code></strong></p>
<p>修改 vector 的长度</p>
<p>如果是缩短，则删除多余的值</p>
<p>如果是扩大，且指定了默认值，则新元素均为默认值（旧元素不变）</p>
<p>时间复杂度：o(n)</p>
<h4 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h4><p>#include&lt;stack&gt;</p>
<p>栈不可访问内部元素，只能用弹出看栈顶,所以感觉可以用vector代替stack，或者手写。–</p>
<p>vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p>
<h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p>stack&lt;类型&gt; a,不初始化</p>
<h5 id="进出栈"><a href="#进出栈" class="headerlink" title="进出栈"></a>进出栈</h5><p>a.push(元素)进</p>
<p>a.pop()弹出</p>
<h5 id="取栈顶"><a href="#取栈顶" class="headerlink" title="取栈顶"></a>取栈顶</h5><p>a.top();</p>
<p>int topnum&#x3D;a.top();</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p>queue&lt;类型&gt; que</p>
<h5 id="进出队"><a href="#进出队" class="headerlink" title="进出队"></a>进出队</h5><p>.push(元素)</p>
<p>.pop()</p>
<h5 id="取队尾队首"><a href="#取队尾队首" class="headerlink" title="取队尾队首"></a>取队尾队首</h5><p>.front()</p>
<p>.back()</p>
<p>int getfront&#x3D;que.front();</p>
<h4 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h4><p>新元素被添加到堆的末尾，然后通过”上浮”操作调整位置，保持堆性质，时间复杂度：O(log n)</p>
<h5 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h5><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p>
<p>类型：要储存的数据类型</p>
<p>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</p>
<p>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</p>
<p>priority_queue&lt;int&gt; pque;默认为大顶堆</p>
<p>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pque2; 储存int的小顶堆</p>
<h5 id="进出堆"><a href="#进出堆" class="headerlink" title="进出堆"></a>进出堆</h5><p>.push(元素)</p>
<p>.pop()</p>
<h5 id="取堆顶-大堆顶就是最大值，小就是最小值"><a href="#取堆顶-大堆顶就是最大值，小就是最小值" class="headerlink" title="取堆顶(大堆顶就是最大值，小就是最小值)"></a>取堆顶(大堆顶就是最大值，小就是最小值)</h5><p>只可访问堆顶，其他元素都无法读取到。</p>
<p>.top()</p>
<p>int a&#x3D;pque.top();</p>
<h4 id="7-gdb编译的时候，如果用了math-h库，那么编译命令里面要加上-lm"><a href="#7-gdb编译的时候，如果用了math-h库，那么编译命令里面要加上-lm" class="headerlink" title="7.gdb编译的时候，如果用了math.h库，那么编译命令里面要加上-lm"></a>7.gdb编译的时候，如果用了math.h库，那么编译命令里面要加上-lm</h4><p>gcc -g -o draft draft.c -lm  </p>
<p>&lt;math.h&gt;只是声明了pow()等数学函数的原型（告诉编译器这些函数存在，应该怎么调用）。</p>
<p>真正的函数实现在数学库libm中&gt;默认情况下，GCC 不会自动链接数学库，所以必须手动加 -lm。</p>
<h4 id="8-定义字符串数组后加上memset-arr1-0-sizeof-arr1"><a href="#8-定义字符串数组后加上memset-arr1-0-sizeof-arr1" class="headerlink" title="8.定义字符串数组后加上memset(arr1, 0, sizeof(arr1));"></a>8.定义字符串数组后加上memset(arr1, 0, sizeof(arr1));</h4><p>byd没加是错的，加了就对了</p>
<h4 id="9-ubuntu粘贴会导致输出部分和输入部分错乱，建议重定向文件或者手动输入"><a href="#9-ubuntu粘贴会导致输出部分和输入部分错乱，建议重定向文件或者手动输入" class="headerlink" title="9.ubuntu粘贴会导致输出部分和输入部分错乱，建议重定向文件或者手动输入"></a>9.ubuntu粘贴会导致输出部分和输入部分错乱，建议重定向文件或者手动输入</h4><p>ctrl v导致输入输出异步，缓冲区未刷新</p>
<p>手动输入和重定向 .&#x2F;draft &lt; in.txt </p>
<h4 id="10-字符型整数转整数型整数"><a href="#10-字符型整数转整数型整数" class="headerlink" title="10.字符型整数转整数型整数"></a>10.字符型整数转整数型整数</h4><p>假设某串的i-j部分是数字，提取成整数，可以不用pow，效率比较低</p>
<p>int change(char *str,int i,int j){</p>
<p>                int result;</p>
<p>                for(int k&#x3D;i;k&lt;&#x3D;j;k++)</p>
<p>                result&#x3D;result*10+str[k]-‘0’;</p>
<p>                return result;</p>
<p>}    </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-05-08T03:20:25.141Z" title="2025/5/8 11:20:25">2025-05-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-07-13T13:18:56.589Z" title="2025/7/13 21:18:56">2025-07-13</time></span><span class="level-item">10 minutes read (About 1539 words)</span></div></div><div class="content"><h2 id="概念规则"><a href="#概念规则" class="headerlink" title="概念规则"></a>概念规则</h2><ol>
<li><p>实例和对象和类区别：<br>实例是通过类创建的对象，比如我string a，a就是string类的实例。比如人类，里面的李白和杜甫就是实例。<br>对象更宽泛，你可以说任何内存实体都是对象。<br>但是一般可以认为实例和对象就是一回事，可以换用。</p>
</li>
<li><p>源代码的文件名必须与公共类的类名相同</p>
</li>
<li><p>main方法必须为public</p>
</li>
<li><p>字符串区间规律：从零开始，操作长度为n–（0,n)例如x.delete(0,4)删除第1-4个，第一个代表起始位置，第二个代表总长度</p>
</li>
<li><p>java.lang是java核心包，无需import</p>
</li>
</ol>
<h2 id="方法积累"><a href="#方法积累" class="headerlink" title="方法积累"></a>方法积累</h2><h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h6 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h6><p>1.java无内置字符串类型，但有一个预定义类string，每个字符串都是string类的实例，这意味着string有很多方法</p>
<p>2.string进行了特殊优化，使其使用起来像基本类型，可以直接拼接</p>
<p>3.注意string储存的是对象在内存中位置的引用，是对象在堆上的<strong>地址</strong>。但是String是不可变对象引用，给某一个string对象引用赋新值，会导致这个引用直接指向新的对象。同时赋值新值后，会导致原值留在内存里面。</p>
<p>String s1&#x3D;”hello”;</p>
<p>String s4&#x3D;”hello”;</p>
<p>s4&#x3D;”nima”;</p>
<p>System.out.println(s1);—-输出hello!</p>
<h6 id="构建："><a href="#构建：" class="headerlink" title="构建："></a>构建：</h6><p>a.字面量:String s1&#x3D;”hello”;高效率</p>
<p>b.构造方法:String s2&#x3D;new String (“nima”);</p>
<p>区别：</p>
<p>a.存储在 <strong>字符串常量池</strong>中，如果常量池中已经存在 <code>&quot;hello&quot;</code>，Java 就不会再创建新的对象，而是 <strong>直接引用已存在的</strong>。</p>
<p>b.会 <strong>在堆内存中新建一个字符串对象</strong>。</p>
<p>String s1&#x3D;”hello”;</p>
<p>String s4&#x3D;”hello”;</p>
<p>String s2&#x3D;new String (“hello”);</p>
<p>s1.equals(s2)–true</p>
<p>s1.equals(s4)–true</p>
<p>s1&#x3D;&#x3D;s2–true(地址相同,同一个)</p>
<p>s1&#x3D;&#x3D;s4–false</p>
<h6 id="拼接"><a href="#拼接" class="headerlink" title="拼接 +"></a>拼接 +</h6><p>String s3&#x3D;s1+s4;—“hellohello”</p>
<p>注意！</p>
<p>1.Java 中 <code>String</code> 是不可变的，所以每次拼接字符串，实际上是创建了一个新的字符串对象，而不是在原字符串基础上修改。</p>
<p>2.实际编译器会生成类似这样的代码：String s &#x3D; new StringBuilder().append(s1).append(s4).toString();</p>
<p>所以每次+都会创建新的字符串对象，性能差</p>
<p>建议用StringBuilder</p>
<h5 id="substring方法"><a href="#substring方法" class="headerlink" title="substring方法"></a>substring方法</h5><p>返回新的子串</p>
<p>String substring(int beginIndex)</p>
<p>&#x2F;&#x2F;从该索引开始到结束<br>String substring(int beginIndex, int endIndex)</p>
<p>&#x2F;&#x2F;注意如果看成数组索引的话，endindex要+1</p>
<p>输出完自动添加换行</p>
<p>eg：</p>
<p>String str &#x3D; “hello world”;<br>System.out.println(str.substring(0, 5)); &#x2F;&#x2F; 输出 “hello”<br>System.out.println(str.substring(6));   &#x2F;&#x2F; 输出 “world”</p>
<h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><p>很多类都有这个方法</p>
<p>String str&#x3D;”hello world”;</p>
<p>str.length()&#x3D;&#x3D;11;</p>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p>s1.equals(s2);</p>
<p>“hello”.equals(s2);</p>
<p>不要用等于&#x3D;&#x3D;,&#x3D;&#x3D;代表比较位置，只有字符串字面量可能相等</p>
<h5 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase"></a>equalsIgnoreCase</h5><p>s1.equalsIgnoreCase(s2)比较忽略大小写</p>
<h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h5><p>s1.compareTo(s2)</p>
<p>按照字典顺序比较两个字符串，相等返回1，小于返回负数，大于返回正数</p>
<h3 id="Stingbuilder类"><a href="#Stingbuilder类" class="headerlink" title="Stingbuilder类"></a>Stingbuilder类</h3><h6 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h6><p>StringBuilder x&#x3D;new StringBuilder(“cao “(或者String变量));</p>
<h5 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h5><p>类似</p>
<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>x..append(“nima”) ,在cao后面追加nima</p>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>x.delete(0, 4),删除区间内内容（含头不含尾）</p>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>x.reverse(),反转字符串</p>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>x.insert(2, “X”),在指定位置插入</p>
<h5 id="join拼接"><a href="#join拼接" class="headerlink" title="join拼接"></a>join拼接</h5><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>x.replace(1, 3, “XYZ”),替换内容</p>
<h5 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h5><p>x.ToString()变成string类</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>语法基本同StringBuilder，区别在于StringBuilder更快，但只适用于单线程，而StringBuffer适用于多线程</p>
<p>理解多线程</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/brokyz/p/14707360.html">Java多线程详解——一篇文章搞懂Java多线程 - brokyz - 博客园</a></p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>java.lang.Math无需导入</p>
<h5 id="exp-log-pow-sqrt-sin-asin-toDegrees-toRadians-random"><a href="#exp-log-pow-sqrt-sin-asin-toDegrees-toRadians-random" class="headerlink" title="exp(),log(),pow(),sqrt(),sin(),asin(),toDegrees(),toRadians(),random()"></a>exp(),log(),pow(),sqrt(),sin(),asin(),toDegrees(),toRadians(),random()</h5><p>double a &#x3D; Math.exp(1);            &#x2F;&#x2F; e 的 1 次方，即 e ≈ 2.718<br>double b &#x3D; Math.log(10);           &#x2F;&#x2F; 计算自然对数 ln(10)<br>double c &#x3D; Math.pow(2, 3);         &#x2F;&#x2F; 2 的 3 次方，结果为 8<br>double d &#x3D; Math.sqrt(16);          &#x2F;&#x2F; 计算 16 的平方根，结果为 4<br>double e &#x3D; Math.sin(Math.PI &#x2F; 2);  &#x2F;&#x2F; 计算正弦，sin(π&#x2F;2) &#x3D; 1<br>double f &#x3D; Math.asin(1);           &#x2F;&#x2F; 计算反正弦 asin(1) &#x3D; π&#x2F;2<br>double g &#x3D; Math.toDegrees(Math.PI); &#x2F;&#x2F; 弧度转角度，π 弧度 ≈ 180°<br>double h &#x3D; Math.toRadians(90);     &#x2F;&#x2F; 角度转弧度，90° ≈ π&#x2F;2<br>double i &#x3D; Math.random();          &#x2F;&#x2F; 生成一个 0.0 到 1.0 的随机数</p>
<h3 id="Number包装类Number-Java-SE-11-JDK-11"><a href="#Number包装类Number-Java-SE-11-JDK-11" class="headerlink" title="Number包装类Number (Java SE 11 &amp; JDK 11 )"></a>Number包装类<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk1.6/java.base/java/lang/Number.html">Number (Java SE 11 &amp; JDK 11 )</a></h3><p>包装类（Wrapper Class） 是 Java 提供的一种机制，它将基本数据类型（int、<code>char</code>、<code>double</code> 等）包装为 <strong>对象</strong>。这使得基本数据类型能够作为对象使用，例如在 <strong>Java 集合框架</strong>（如 <code>ArrayList</code>、<code>HashMap</code>）中，或者进行类型转换、方法调用等操作。</p>
<p><img src="file:///C:/Users/hardestnut/Pictures/Typedown/39850735-a33b-4c8d-a2f5-5bd5fde0cbe4.png" alt="39850735-a33b-4c8d-a2f5-5bd5fde0cbe4"></p>
<p>抽象类，不能实例化</p>
<p>Double那些是Number的子类，注意BigDecimal，BigInteger也是。是Number子类都可以调用.intValue()方法</p>
<h5 id="intValue-doubleValue……"><a href="#intValue-doubleValue……" class="headerlink" title="intValue,doubleValue……"></a>intValue,doubleValue……</h5><p>Double d &#x3D; 3.99;<br>int i &#x3D; d.intValue();       &#x2F;&#x2F; i &#x3D; 3，截断小数</p>
<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>基本类型转包装对象</p>
<p>Double d &#x3D; Double.valueOf(3.14);        &#x2F;&#x2F; double -&gt; Double 对象</p>
<p>字符串转包装对象</p>
<p>Integer i2 &#x3D; Integer.valueOf(“456”);    &#x2F;&#x2F; 字符串 “456” -&gt; Integer 对象</p>
<h3 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h3><p>BigInteger整数，BigDecimal浮点</p>
<h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><p>1.BigInteger big1 &#x3D; new BigInteger(“123456789012345678901234567890”);</p>
<p>2.valueOf</p>
<h5 id="valueOf"><a href="#valueOf" class="headerlink" title="valueOf"></a>valueOf</h5><p>记得上面说的吗，BigInteger也是Number的子类</p>
<p>BigInteger a&#x3D;BigInteger.valueOf(1000000)</p>
<p>把1000000转换成biginteger类的对象</p>
<h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><p>BigInteger sum &#x3D; big1.add(big2);</p>
<h5 id="multiply"><a href="#multiply" class="headerlink" title="multiply()"></a>multiply()</h5><h5 id="divide"><a href="#divide" class="headerlink" title="divide()"></a>divide()</h5><h5 id="mod"><a href="#mod" class="headerlink" title="mod()"></a>mod()</h5><h5 id="pow-int"><a href="#pow-int" class="headerlink" title="pow(int)"></a>pow(int)</h5><h5 id="subtract"><a href="#subtract" class="headerlink" title="subtract()"></a>subtract()</h5><h5 id="compareTo-1"><a href="#compareTo-1" class="headerlink" title="compareTo()"></a>compareTo()</h5><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h2 id="对象初步"><a href="#对象初步" class="headerlink" title="对象初步"></a>对象初步</h2><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1.基本规则"></a>1.基本规则</h3><p>1.一个文件里面可以有多个类，但是public修饰的类只能有一个，且这个类名必须和文件名一样</p>
<h3 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h3><p>使用构造器构造，构造器名与类相同，前面加上new，</p>
<p>如new class();</p>
<p>Date rightnow–创建一个Date类的对象变量–对象变量不是对象，不能使用对象的方法</p>
<p>注意！：对象变量的值是一个引用，也就是说Date rightnow&#x3D;new Date();,rightnow_2&#x3D;rightnow,此时两个还是指向一个</p>
<p>new Date()–构造一个变量</p>
<p>System.out.println(new Date())–创建的对象变量可以用，但只能用一次（这里date有toString方法，println输出默认使用toString转为字符串）</p>
<p>Date rightnow&#x3D;new Date();</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-04-01T08:36:53.636Z" title="2025/4/1 16:36:53">2025-04-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-26T07:12:30.597Z" title="2025/8/26 15:12:30">2025-08-26</time></span><span class="level-item">7 minutes read (About 1064 words)</span></div></div><div class="content"><p>quicksort快速排序</p>
<p>双指针</p>
<p>1.从待排的数里随便取分界点x，常用两边或中间</p>
<p>2.考虑两个指针i,j分居数两侧，如果指针i指向的数左小于x或右边的j大于x，则向中间走一格。如果i大于x或者j小于x，则停下，等两边停下，交换数。从而保证在x的左边都小于等于x，右边同理</p>
<p>3.由此，一串数通过x划分为左右两串数，对每一串数递归处理即可</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> i=left<span class="number">-1</span>,j=right+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s=q[(left+right)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)<span class="comment">//结束循环意味着i&gt;=j，此时代表完成&#123;</span></span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;s);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;s);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="type">int</span> temp=q[j];</span><br><span class="line">        q[j]=q[i];</span><br><span class="line">        q[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,left,j);</span><br><span class="line">    quick_sort(q,j+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，</p>
<p>1.s应该是q[(left+right)&#x2F;2]这个固定值,而不是left+right)&#x2F;2这个索引，因为虽然s不变，但后面while交换时可能打乱变动q[s]值。</p>
<p>2.建议递归的(q,left,j)不写成(q,left,j-1),因为当排序只有两个，左边指针一来就停止时，右边会到最左边，造成左边的数分串是零，右边跟原来一模一样，造成无限递归。同理,s&#x3D;q[r]时，尽量避开(q,left,j)</p>
<p>即s&#x3D;q[left]或left+right&#x2F;2—-j,j+1;s&#x3D;q[right]或者left+right+1&#x2F;2—-i-1,i。</p>
<p>3.为什么是j,j+1而不是j-1,j?</p>
<p>考虑结束时仅有i&#x3D;j(指向同一个地点)和—-ji—–i在j后面一个，显然划分数串的就是ji中间的缝，对应索引j,j+1或者i-1,i(这里选择ij需要注意2的问题，如果是取中间还是j，毕竟c是向小取整)</p>
<p>mergesort并归排序</p>
<p>这里应用双指针算法</p>
<p>总体思路是不断分割数串，直到小到两个数，再利用递归合并成数串</p>
<p>关键思路是如何把两个排好序得数组合并成大的有序数组</p>
<p>1.对于两串排好序的数列，我们分别在数串两边添加一个指针，如果数串1的值小于数串2，把该值放入一个空数组temp中，数串1指针+1，反之数串2放入空数组，直到某一边到边界停下，这意味着没到边界的数串后面的每一个数都比停下的数串最大的数更大，直接把没到边界的数串后面的数放到temp后面。由此，能把两个排好序的数串整成一个排好序的大数串temp</p>
<p>2.两个数能通过 1 排好，如果只有一个数，不做处理，作为基情况。</p>
<p>3.递归</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp[MAXN];</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(q,left,mid);</span><br><span class="line">    merge_sort(q,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])</span><br><span class="line">            temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++]=q[j++];</span><br><span class="line">    &#125;<span class="comment">//这时可能只有一边完成 需要补刀</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)temp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left,j=<span class="number">0</span>;i&lt;=right;i++,j++)q[i]=temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找</p>
<p>用于查找一段排好序的数列中，指定数的位置</p>
<p>逻辑很简单，判断中间索引的数列值和指定数的大小，不断减小两边区间范围，实现二分逼近</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> a[],<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[middle]&gt;target)right=middle;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[middle]&lt;target)left=middle+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环条件是left&lt;right，跳出循环的时候一定是left&#x3D;&#x3D;right,并且没有触发a[middle]&#x3D;&#x3D;target，说明没有target这个值，返回-1。</p>
<p>如果a[middle]&gt;target,说明target在左边，需要缩小右边，让middle赋值给right。注意&lt;时基本同理，但是应该把middle+1赋值给left，因为left+right&#x2F;2向左边取整，不加一可能造成递归重复数列，无限循环</p>
<p>浮点二分查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">double_search</span><span class="params">(<span class="type">double</span> x)</span>&#123;</span><br><span class="line">    <span class="type">double</span> left=<span class="number">0</span>,right=x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right-left&gt;=<span class="number">1e-6</span>)&#123;</span><br><span class="line">    <span class="type">double</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(middle*middle&gt;x)right=middle;</span><br><span class="line">    <span class="keyword">else</span> left=middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无边界问题，简单。这里是平方根的示例</p>
<p>大数 </p>
<p>查看博客三连击</p>
<p>双指针</p>
<p>利用两个变量i,j,以及题目中给出的性质，避免使用ij双层for循环的算法.</p>
<p>例如，考虑一串数，给出数串中不含重复数字的子串的长度最大值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> maxlength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;check_chong(a,i,j))i++;</span><br><span class="line">        maxlength=max(maxlength,j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxlength+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中双指针实现如上，0&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n,由于每一次i更新后，j的位置不可能相对于上一次j的位置发生后退，因为如果后退，那么上一次j的位置在这个假想的后退后的位置也可以存在。因此每次i更新j不必从零开始，而是优化为从上一次的位置开始，这样ij只需要扫描2n格即可。</p>
<p>下面是完整代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check_chong</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">9</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)b[a[k]<span class="number">-1</span>]++;</span><br><span class="line">    <span class="type">int</span> found=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[k]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            found++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> maxlength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;check_chong(a,i,j))i++;</span><br><span class="line">        maxlength=max(maxlength,j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxlength+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位运算&gt;&gt;常见操作</p>
<p>1.n的二进制表示中第k位是多少n&gt;&gt;k&amp;1</p>
<p>&gt;&gt;位运算符，表示把n的二进制数串往后移k位</p>
<p>&amp;是与运算，&amp;1表示判断奇偶，例如011011&amp;1(即000001),除了最高位其他位都是0所以011011只有0位（011011分别是543210位）的那个1参与有效运算，如果是1，与运算后也是1，对应十进制中的奇数，如果是零，与运算后也是零，对应十进制中的偶数，从而实现判断奇偶。这里用来判断第k位是多少显然也是可以的</p>
<p>2.lowbit：x&amp;-x即x&amp;(~x+1),表示x的第一个1，例如1010000返回10000，1010100返回100。</p>
<p>首先，-x&#x3D;<del>x+1，</del>表示所有位取反。即负数的二进制表示，是找到其正数的二进制数串，每一位取反，最终＋1。如5-00000101，-5-&gt;11111010-&gt;11111011，这样5+-5&#x3D;00000000。</p>
<p>值得注意的是，251和-5比特串都是11111011，如果类型是unsigned ，串的第7位1为符号位，1表示负，从而该串表示-5，如果是signed，则表示251</p>
<p>然后lowbit原理如下，我们假设x的第一个1在k位，那么<del>x的0-k-1位全是1，第k位变成0，</del>x+1（即-x）后，0-k-1位所有1变成0，然后第k位变成1。现在相加，神奇的是，第0-k-1位，x和-x所有都是0，与运算后都是0，k+1位到最后一位全都相反，与运算后也是零，只有第k位是1，从而实现</p>
<p>eg;x:01011110000  ~x:1010001111 -x:1010010000 x&amp;-x：0000010000，输出10000。</p>
<p>离散化</p>
<p>离散化思想是比较少的一堆数要作为下标时，这些数有很大，如果要开数组直接储存这些数的时候，将会占用极大的内存，无法实现，这时考虑到这些数很小，所以把这些数按照大小一一与1，2，3，4等对应，这样内存占用将会极大减小。</p>
<p>530417</p>
<p>kmp</p>
<p>manacher</p>
<p>算法里面的数据结构手搓</p>
<p>链表</p>
<p>用数组模拟链表，常规动态链表比较慢</p>
<p>value[MAXN]存储值</p>
<p>next[MAXN]存储下一个节点的坐标 </p>
<p>idx 当前用到了那个点，用于当作新分配的节点下标</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-25T11:45:36.582Z" title="2025/2/25 19:45:36">2025-02-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-03T10:53:45.361Z" title="2025/9/3 18:53:45">2025-09-03</time></span><span class="level-item">4 minutes read (About 527 words)</span></div></div><div class="content"><p>git教程可以查看<a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/git/time-travel/index.html">时光机穿梭 - Git教程 - 廖雪峰的官方网站</a></p>
<p>可谓是非常详细了。以下仅仅记录常用指令方便查找</p>
<p>注意，git在没输入git config –global（全局）或指定文件路径时，都是对当前目录的操作</p>
<h4 id="初始化和添加"><a href="#初始化和添加" class="headerlink" title="初始化和添加"></a>初始化和添加</h4><p>文件-（add）-track-（commit）-git保险柜</p>
<p>git init：在某一路径下，创建一个”保险柜“，用于存放保险柜的名字默认叫master，我已经通过</p>
<p>git config –global init.defaultBranch main将默认repo名改为main</p>
<p>git add 文件名(当前目录下)或文件路径 把目标文件放入track上面（未进repo）</p>
<p>git add.  添加所有</p>
<p>git commit -m “对文件的描述（随便写，但是必须有）”</p>
<h4 id="git管理"><a href="#git管理" class="headerlink" title="git管理"></a>git管理</h4><p>git status 查看当前文件夹下有哪些未进入track</p>
<p>git diff 查看差异</p>
<p>git log 查看git操作日志，git上面commit后面有很大一串怪字符，那是id</p>
<p>git show 某某id（git log里面的）</p>
<h4 id="git文件内容控制"><a href="#git文件内容控制" class="headerlink" title="git文件内容控制"></a>git文件内容控制</h4><p>git checkout id “filename” 把filename变为相关id版本</p>
<p>（完成 add commit会进入一次log操作，得到一个不同的id）</p>
<p>git reset –hard 版本回退到上个版本的已提交状态</p>
<p>git reset –soft  回退到上个版本的未提交状态</p>
<p>git reset –mixed  回退到上个版本已添加但未提交的状态</p>
<p>cs61b的ssh密匙在home</p>
<h4 id="github"><a href="#github" class="headerlink" title="github"></a>github</h4><p>git remote add skeleton <a target="_blank" rel="noopener" href="https://github.com/Berkeley-CS61B/skeleton-sp18.git">https://github.com/Berkeley-CS61B/skeleton-sp18.git</a></p>
<p>添加了一个叫skeleton的库，这个库不会和我的冲突，多个可共存</p>
<p>git pull origin main –rebase拉取远程代码到本地并变基</p>
<p>git pull –rebase –allow-unrelated-histories skeleton master 导入了cs61b的初始代码</p>
<p>git push origin main本地推送到远端</p>
<p>如果是第一次建库，由于github上面有readme，比你电脑提交记录新，所以会拒绝，此时可git pull origin main –rebase 或者git push -f origin main强制推送</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-25T11:27:49.215Z" title="2025/2/25 19:27:49">2025-02-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-04T11:19:35.187Z" title="2025/8/4 19:19:35">2025-08-04</time></span><span class="level-item">10 minutes read (About 1451 words)</span></div></div><div class="content"><p>终端实际上配置有一系列应用程序，储存在文件管理系统里面，输入指令将调取这些程序。<br>通过环境变量搜索程序<br>shell实际上可以是一种编程语言，循环那些都可以实现</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>ctrl+c 退出当前进程<br>ctrl 清空，回到顶部<br>sudo 超级用户（慎用，除非必要）<br>sudo su(下面的提示符从$变为#，即默认从user变为root）<br>exit退出root<br>.+文件名代表隐藏文件</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>  &lt; 重定向键盘输入为文件输入</p>
<p>&gt;重定向标准输出到文件</p>
<p>文件将被覆盖</p>
<p>&gt;&gt;重定向便准输出到文件，但不覆盖，而是追加</p>
<p>2&gt;输入错误到某文件</p>
<p>.&#x2F;draft &lt; draft.in &gt;draft.out 2&gt;error.log</p>
<p>但是注意输出错误日志可能会占用一定cpu从而影响正常程序运行</p>
<h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>echo表示打印文本</p>
<p>echo hello<br>echo $PATH,显示以冒号为分割的路径变量<br>echo ​$HOME（环境变量）,–&#x2F;home&#x2F;hardestnut<br>我输入date，会在这些路径下查找是否有相关的程序</p>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>寻找可执行文件，找不到文件夹</p>
<p>which .ssh没反应  which ssh显示路径</p>
<p>which echo–&#x2F;usr&#x2F;bin&#x2F;echo</p>
<p>或者 find ~ -name “ssh”</p>
<p>顺便说一句，文件名都以&#x2F;开头</p>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前路径–&#x2F;home&#x2F;hardestnut</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd 改变到目标路径<br>cd 默认到主目录<br>cd -回到上一次目录（两者之间来回）<br>cd  &#x2F;home<br>cd &#x2F;回到根目录&#x2F;<br>(值得注意的是，开头的&#x2F;指的是根目录，&#x2F;bin对，&#x2F;local错，&#x2F;usr&#x2F;local对，因为&#x2F;下没有local目录<br>cd ..回到上一个路径<br>cd ..&#x2F;other_directory：切换到当前目录的上一级目录中的other_directory。<br>cd ~ 带到主目录（home&#x2F;username）可作为相对路径</p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls ~\目标文件 </p>
<p>ls：显示当前路径下的文件<br>ls .. 上一级文件目录<br>(Usage: ls [OPTION]… [FILE]…   这里面…表示0，1或多个选项<br>ls –help<br>ls -l  +文件夹名显示详细信息</p>
<h5 id="ls展示信息解读"><a href="#ls展示信息解读" class="headerlink" title="ls展示信息解读"></a>ls展示信息解读</h5><p>lrwxrwxrwx   1 root root       7 Nov 23  2023 bin -&gt; usr&#x2F;bin<br>l表示这是一个符号链接,类似于快捷方式，指向另一个文件或目录。（d表示目录</p>
<p>rwxrwxrwx 表示所有用户（所有者、用户组、其他用户）都有读、写、执行权限。（r-x表示缺少w）</p>
<p>1：表示硬链接的数量。对于符号链接，通常这个数字是 1。对于目录来说，硬链接数表示该目录下有多少个子目录（包括 . 和 ..）</p>
<p>ls -a  显示所有文件，包括以 . 开头的隐藏文件。<br>ls -lh  显示人类可读的文件大小<br>ls -R  递归列出所有子目录的内容。<br>ls -lt  按文件的修改时间排序，最近修改的文件排在最前面。<br>ls -lS  按文件的大小排序，最大文件排在最前面。<br>ls -F  在文件名后添加标识符，表示文件类型。&#x2F; 表示目录，* 表示可执行文件。<br>ls -color 不同类型染色<br>ls -1竖着排版，看起来舒服点<br>多个选项可以一起使用，通常没有问题。ls -lat</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv 功能1：移动文件路径 功能2：重命名文件<br>mv filename(如果只有一个) 目标路径<br>mv 路径（多个，精确） 目标路径<br>mv filename*（通配符）（多个） 目标路径(将把全部文件都移过去）</p>
<p>重命名：mv 旧名字 新名字</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp 复制文件<br>cp filename 新路径  或 旧路经 新路径</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>递归删除即指删除当前文件夹及其所有子文件夹</p>
<p>rm删除（通常不是递归删除，即删除以上的所有目录）<br>rm 文件名&#x2F;路径（rm默认删除文件<br>rm -r filename&#x2F;path(递归删除所有空）</p>
<p>sudo rm -rf …强制删除（谨慎！！！！</p>
<p>rmdir 文件名&#x2F;路径（允许你在目录为空的时候删除一个目录）</p>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir创造目录 “name”</p>
<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>man+另一个程序名，将提供该程序的手册<br>man ls(ls的使用）man echo</p>
<h4 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向&lt; &gt;"></a>重定向&lt; &gt;</h4><p>echo +&gt;输入重定向：echo “hello”&gt;hello.txt(覆盖或创建）<br>echo “hello”&gt;&gt;hello.txt(末尾追加或者创建）<br>cat &lt;hello.txt输出内容<br>cat &lt;hello.txt &gt;hello2.txt 相当于把第一个文件内容复制给第二个</p>
<p>|  ： 命令1|命令2<br>把左边命令的输出内容作为右边命令的输入内容<br>ls -a|tail -n2(表示输出最后两行内容)</p>
<p>查找文件：find 路径1 路径2… -name “文件名”2&gt;&#x2F;dev&#x2F;null<br>后面的2&gt;&#x2F;dev&#x2F;null表示不输出无关的，否则在大路径下查找可能会输出一坨。2(标准错误输出)&gt;&#x2F;dev&#x2F;null(文件黑洞，相当于垃圾桶)&#x2F;dev(设备文件,这些文件是与硬件设备或虚拟设备交互的接口)<br>&#x2F;null虚拟设备</p>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file+文件名 判断文件类型</p>
<p>如file draft3</p>
<p>输出：draft3: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, BuildID[sha1]&#x3D;320cbb94642d466c28181ba5732e78d0b22fa1cd, for GNU&#x2F;Linux 3.2.0, not stripped</p>
<p>分别表示64位可执行文件（linux的ELF表示可执行文件） 处理器架构 版本，动态链接依赖，动态链接器路径，哈希标识，保留调试信号（-g）</p>
<p>又如file draft3.c,输出draft3.c: C source, Unicode text, UTF-8 text, with CRLF line terminators。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ctrl+tab切换标签页</p>
<p>按上箭头和下箭头能查阅历史命令</p>
<p>在命令输入一半按tab会显示所有可能的完整命令</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">Previous</a></div><div class="pagination-next"><a href="/page/6/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-02-03T14:56:18.354Z">2026-02-03</time></p><p class="title"><a href="/2026/02/03/gpt/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-02-03T14:28:41.278Z">2026-02-03</time></p><p class="title"><a href="/2026/02/03/3.stl/6.%E8%BF%AD%E4%BB%A3%E5%99%A8/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-02-03T13:02:44.628Z">2026-02-03</time></p><p class="title"><a href="/2026/02/03/3.stl/5.%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-31T13:54:09.572Z">2026-01-31</time></p><p class="title"><a href="/2026/01/31/3.stl/4.%E6%A8%A1%E6%9D%BF/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2026-01-28T13:10:56.335Z">2026-01-28</time></p><p class="title"><a href="/2026/01/28/3.stl/3.%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"> </a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2026/02/"><span class="level-start"><span class="level-item">February 2026</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2026/01/"><span class="level-start"><span class="level-item">January 2026</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/12/"><span class="level-start"><span class="level-item">December 2025</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/11/"><span class="level-start"><span class="level-item">November 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/10/"><span class="level-start"><span class="level-item">October 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/09/"><span class="level-start"><span class="level-item">September 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/08/"><span class="level-start"><span class="level-item">August 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/07/"><span class="level-start"><span class="level-item">July 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">May 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">April 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2026 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>